" 初期設定 {{{1
" Last Change: 26-Dec-2013.
" VI互換モードOFF
set nocompatible
" 内部エンコーディングをutf-8に指定
set encoding=utf-8
" キー入力をタイムアウトさせない
set notimeout
set ttimeout

"---------------------------------------------------------------------------
" vundle
"
" COMMAND:
"  :BundleInstall : Bundleされたプラグインをインストール
"  :BundleSearch : vim-scriptにあるプラグインを検索
" KEYMAP:
nnoremap [bundle] <Nop>
nmap <Leader>b [bundle]
nnoremap <silent> [bundle]i<CR> :<C-u>BundleInstall<CR>
nnoremap <silent> [bundle]u<CR> :<C-u>BundleUpdate<CR>

filetype off
if has("win32") || has("win64")
  set rtp&
  set rtp+=~/vimfiles/bundle/vundle
  call vundle#rc('~/vimfiles/bundle')
else
  set rtp&
  set rtp+=~/.vim/bundle/vundle
  call vundle#rc()
endif

" original repos on github
Bundle 'gmarik/vundle'
Bundle 'Shougo/neocomplcache'
Bundle 'Shougo/vimproc'
Bundle 'Shougo/vimshell'

" Unite
Bundle 'Shougo/unite.vim'
Bundle 'Shougo/vimfiler'
Bundle 'Shougo/unite-outline'
Bundle 'ujihisa/unite-colorscheme'
Bundle 'ujihisa/unite-rake'
Bundle 'ujihisa/unite-gem'

Bundle 'thinca/vim-ref'
Bundle 'thinca/vim-quickrun'
Bundle 'thinca/vim-singleton'
"Bundle 'thinca/vim-guicolorscheme'
Bundle 'thinca/vim-qfreplace'
Bundle 'tpope/vim-surround.git'
Bundle 'tpope/vim-fugitive'

" Ruby
Bundle 'tpope/vim-rails.git'
Bundle 'taka84u9/vim-ref-ri'

Bundle 'itchyny/lightline.vim'
Bundle 'fholgado/minibufexpl.vim'
Bundle 'vim-jp/vimdoc-ja'
Bundle 'plasticboy/vim-markdown'
Bundle 'tyru/open-browser.vim'
Bundle 'kana/vim-smartchr'
Bundle 'tyru/caw.vim'
Bundle 'mattn/emmet-vim'
Bundle 'mattn/benchvimrc-vim'
Bundle 'gregsexton/gitv'

" vim-scripts repos
Bundle 'wombat256.vim'
Bundle 'molokai'
Bundle 'Zephyr-Color-Scheme'
Bundle 'ScrollColors'
Bundle 'CSApprox'

" local repos
if isdirectory($HOME . '/dev/github/unite-tiddlywiki/')
  Bundle 'file://' . $HOME . '/dev/github/unite-tiddlywiki/'
endif

filetype plugin indent on

" singleton.vim
if has('gui_running')
  call singleton#enable()
endif

" 自動コマンドの初期化
augroup myvimrc
  au!
augroup END

" Kaoriya設定 {{{1
let g:vimrc_local_finish = 1
"---------------------------------------------------------------------------
" サイトローカルな設定($VIM/vimrc_local.vim)があれば読み込む。読み込んだ後に
" 変数g:vimrc_local_finishに非0な値が設定されていた場合には、それ以上の設定
" ファイルの読込を中止する。
if 1 && filereadable($VIM . '/vimrc_local.vim')
  unlet! g:vimrc_local_finish
  source $VIM/vimrc_local.vim
  if exists('g:vimrc_local_finish') && g:vimrc_local_finish != 0
    finish
  endif
endif

"---------------------------------------------------------------------------
" ユーザ優先設定($HOME/.vimrc_first.vim)があれば読み込む。読み込んだ後に変数
" g:vimrc_first_finishに非0な値が設定されていた場合には、それ以上の設定ファ
" イルの読込を中止する。
if 0 && exists('$HOME') && filereadable($HOME . '/.vimrc_first.vim')
  unlet! g:vimrc_first_finish
  source $HOME/.vimrc_first.vim
  if exists('g:vimrc_first_finish') && g:vimrc_first_finish != 0
    finish
  endif
endif

"---------------------------------------------------------------------------
" 日本語対応のための設定:
"
" ファイルを読込む時にトライする文字エンコードの順序を確定する。漢字コード自
" 動判別機能を利用する場合には別途iconv.dllが必要。iconv.dllについては
" README_w32j.txtを参照。ユーティリティスクリプトを読み込むことで設定される。
if filereadable($VIMRUNTIME . '/encode_japan.vim')
  source $VIMRUNTIME/encode_japan.vim
endif
" メッセージを日本語にする (Windowsでは自動的に判断・設定されている)
if !(has('win32') || has('mac')) && has('multi_lang')
  if !exists('$LANG') || $LANG.'X' ==# 'X'
    if !exists('$LC_CTYPE') || $LC_CTYPE.'X' ==# 'X'
      language ctype ja_JP.eucJP
    endif
    if !exists('$LC_MESSAGES') || $LC_MESSAGES.'X' ==# 'X'
      language messages ja_JP.eucJP
    endif
  endif
endif
" MacOS Xメニューの日本語化 (メニュー表示前に行なう必要がある)
if has('mac')
  set langmenu=japanese
endif
" 日本語入力用のkeymapの設定例 (コメントアウト)
if has('keymap')
  " ローマ字仮名のkeymap
  "silent! set keymap=japanese
  "set iminsert=0 imsearch=0
endif
" 非GUI日本語コンソールを使っている場合の設定
if !has('gui_running') && &encoding != 'cp932' && &term == 'win32'
  set termencoding=cp932
endif

"---------------------------------------------------------------------------
" メニューファイルが存在しない場合は予め'guioptions'を調整しておく
if 1 && !filereadable($VIMRUNTIME . '/menu.vim') && has('gui_running')
  set guioptions+=M
endif

"---------------------------------------------------------------------------
" Bram氏の提供する設定例をインクルード (別ファイル:vimrc_example.vim)。これ
" 以前にg:no_vimrc_exampleに非0な値を設定しておけばインクルードはしない。
let g:no_vimrc_example = 1
if 1 && (!exists('g:no_vimrc_example') || g:no_vimrc_example == 0)
  if &guioptions !~# "M"
    " vimrc_example.vimを読み込む時はguioptionsにMフラグをつけて、syntax on
    " やfiletype plugin onが引き起こすmenu.vimの読み込みを避ける。こうしない
    " とencに対応するメニューファイルが読み込まれてしまい、これの後で読み込
    " まれる.vimrcでencが設定された場合にその設定が反映されずメニューが文字
    " 化けてしまう。
    set guioptions+=M
    source $VIMRUNTIME/vimrc_example.vim
    set guioptions-=M
  else
    source $VIMRUNTIME/vimrc_example.vim
  endif
endif
" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
inoremap <C-U> <C-G>u<C-U>
" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
		  \ | wincmd p | diffthis
endif

"---------------------------------------------------------------------------
" ファイル名に大文字小文字の区別がないシステム用の設定:
"   (例: DOS/Windows/MacOS)
"
if filereadable($VIM . '/vimrc') && filereadable($VIM . '/ViMrC')
  " tagsファイルの重複防止
  set tags=./tags,tags
endif

" "---------------------------------------------------------------------------
" " コンソールでのカラー表示のための設定(暫定的にUNIX専用)
" if has('unix') && !has('gui_running')
"   let uname = system('uname')
"   if uname =~? "linux"
"     set term=builtin_linux
"   elseif uname =~? "freebsd"
"     set term=builtin_cons25
"   elseif uname =~? "Darwin"
"     set term=beos-ansi
"   else
"     set term=builtin_xterm
"   endif
"   unlet uname
" endif

"---------------------------------------------------------------------------
" コンソール版で環境変数$DISPLAYが設定されていると起動が遅くなる件へ対応
if !has('gui_running') && has('xterm_clipboard')
  set clipboard=exclude:cons\\\|linux\\\|cygwin\\\|rxvt\\\|screen
endif

"---------------------------------------------------------------------------
" プラットホーム依存の特別な設定
"
" WinではPATHに$VIMが含まれていないときにexeを見つけ出せないので修正
if has('win32') && $PATH !~? '\(^\|;\)' . escape($VIM, '\\') . '\(;\|$\)'
  let $PATH = $VIM . ';' . $PATH
endif

" 基本設定 {{{1
" 検索の挙動に関する設定 {{{2
" 検索時に大文字小文字を無視 (noignorecase:無視しない)
set ignorecase
" 大文字小文字の両方が含まれている場合は大文字小文字を区別
set smartcase
" インクリメンタルな検索
set incsearch
" 検索結果文字列のハイライトを有効にする
set hlsearch
" 検索時にファイルの最後まで行ったら最初に戻る (nowrapscan:戻らない)
set wrapscan
" タグ検索に二分検索をオフにする（vimdoc-jaフリーズ対策）
set notagbsearch
" 検索語が真ん中にくるようにする
"  zz はカレント行を画面の中心にする。つまり n で検索語にカーソル移動したら
"  勝手に zz でカレント行が画面の真ん中なるようにスクロールされるようになる。
noremap n nzz
noremap N Nzz
noremap * *zz
noremap # #zz
noremap g* g*zz
noremap g# g#zz
noremap { {zz
noremap } }zz

" 編集に関する設定 {{{2
" タブの画面上での幅
set tabstop=2
set shiftwidth=2
set softtabstop=2
" タブをスペースに展開する (noexpandtab:展開しない)
set expandtab
" 自動的にインデントする (noautoindent:インデントしない)
set autoindent
" 高度なオートインデント
set smartindent
" バックスペースでインデントや改行を削除できるようにする
set backspace=2
" 括弧入力時に対応する括弧を表示 (noshowmatch:表示しない)
set showmatch
" コマンドライン補完するときに強化されたものを使う(参照 :help wildmenu)
set wildmenu
" テキスト挿入中の自動折り返しを日本語に対応させる
set formatoptions+=mM
" コメント行で'o'で改行したらコメントをつけない
" ftpluginで上書きされてしまうためauでなんとかする
au myvimrc BufRead,BufNew,BufNewFile * set formatoptions-=o
" 文字数による自動折り返しはしない
set textwidth=0
" 区切り文字設定（単語の一部とする文字の設定）
"   Macではデフォルトの'iskeyword'がcp932に対応しきれていないので修正
"     @ : アルファベット
"     48-57 : 数字
"     128-167,224-235,192-255 : Extended ASCII characters（日本語には関係ない）
if has('mac')
  set iskeyword=@,48-57,_,128-167,224-235
endif
" '-'も単語の一部と認識させる
set iskeyword+=-
" 日本語整形スクリプト(by. 西岡拓洋さん)用の設定
let format_allow_over_tw = 1	" ぶら下り可能幅
" 編集後保存していなくても別のファイルを開く
set hidden
" コマンドライン履歴
set history=50
" 外部のエディタで編集中のファイルが変更されたら自動で読み直す
" （ウィンドウを移動する度に変更をチェックする）
set autoread
augroup vimrc_checktime
  au!
  au WinEnter * checktime
augroup END

" 画面表示の設定 {{{2
" シンタックスハイライト
syntax on
" カラースキーマ設定
set t_Co=256
colorscheme molokai
let g:molokai_original = 1
" 行番号を非表示 (number:表示)
set nonumber
" ルーラーを表示 (noruler:非表示)
set ruler
" タイトルを表示
set title
" 終了後のウィンドウタイトル
set titleold=vim
" タブや改行を表示 (nolist:非表示)
set list
" どの文字でタブや改行を表示するかを設定
"set listchars=tab:>-,extends:<,trail:-,eol:<
set listchars=tab:>-,extends:<,trail:-
" タブの左側にカーソル表示
"set listchars=tab:\ \
" 全角スペースも表示　
highlight JpSpace cterm=underline ctermfg=darkgrey gui=underline guifg=darkgrey
au myvimrc BufRead,BufNew * match JpSpace /　/
" □や○の文字があってもカーソル位置をずらさせない
set ambiwidth=double
" 画面最後の行を出来る限り表示する
set display+=lastline
" modelineを無視する
"set nomodeline
" フォールディング方式の指定（マーカー使用）(=fdm)
set foldmethod=marker
" 長い行を折り返して表示 (nowrap:折り返さない)
set wrap
" コマンドラインの高さ (Windows用gvim使用時はgvimrcを編集すること)
set cmdheight=1
" コマンドをステータス行に表示
set showcmd
" 常にステータス行を表示 (詳細は:he laststatus)
set laststatus=2
" ステータスラインに文字コードと改行文字とファイルタイプを表示する
"set statusline=%<%f\%m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%l,%c
"set statusline=%<%t\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']['.&ft.']'}%=%l,%c%V%8P
" タブは非表示
set showtabline=0
" 前回終了したカーソル行に移動して真ん中にする（フォールディングがあれば開く）
au myvimrc BufRead * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g`\"zz" | endif
au myvimrc BufRead * if &foldenable > 0 && foldclosed("'\"") > 0 | exe "normal zA" | endif

" GUI固有の画面表示の設定 {{{2
if has('gui_running')
  " バッファがローカルバッファに表示されなくなった場合は削除する
  " （[No Name]バッファへの対策）
  "set bufhidden=wipe
  " ウィンドウサイズを最大化する
  au GUIEnter * simalt ~x
  " フォントを指定
  set guifont=Ricty_Diminished:h12:cSHIFTJIS
  " ビジュアル選択を自動的にクリップボードへ
  " 　クリップボードを共有したためいったん停止
  "set guioptions+=a
  " ヤンクでクリップボードを共有する
  if has('clipboard')
    set clipboard=unnamed
  endif
  " マウスを有効にする
  if has('mouse')
    set mouse=a
  endif
  " IME制御をオフにする
  set iminsert=0
  set imsearch=0
  set noimcmdline
endif

" ファイル操作に関する設定 {{{2
" バックアップファイルを作成しない
set nobackup
set nowritebackup
" スワップファイルの作成ディレクトリにパスを追加
set directory+=,~/tmp,$TMP
" ファイルを開くと、そのファイルと同じディレクトリに移動
" 名無しのvim使い <http://nanasi.jp/articles/vim/cd_vim.html>
au myvimrc BufEnter * if expand("%") == '' | execute ":lcd " . expand("%:p:h") | endif
" vimrcの保存時に再読み込み
augroup re_source_vimrc
  au!
  au BufWritePost *vimrc nested source $MYVIMRC
  au BufWritePost *gvimrc if has('gui_running') source $MYGVIMRC
augroup END

" FileType設定 {{{2
" Ruby
au myvimrc FileType ruby setlocal fenc=utf8 ff=unix
" Git commit log
au BufRead COMMIT_EDITMSG setlocal nofoldenable
"git-vimで対応するためコメントアウト
"au BufRead COMMIT_EDITMSG set ft=diff fenc=utf8 ff=unix
"git commit -v で対応するためコメントアウト
"au BufRead COMMIT_EDITMSG DiffGitCached
" Vim
if 'vim' == &ft
  setlocal iskeyword+=:
  setlocal iskeyword-=#
else
  au myvimrc FileType vim setlocal iskeyword+=:
  au myvimrc FileType vim setlocal iskeyword-=#
endif
" JavaSciprt
au myvimrc BufRead,BufNew,BufNewFile *.json setlocal filetype=javascript
" Apache
au myvimrc BufRead,BufNew,BufNewFile httpd*.conf setlocal filetype=apache
" テンプレート設定
"augroup SkeletonAu
  "au!
  "au BufNewFile *.html 0r $HOME/.vim/skel/skel.html
  "au BufNewFile *_spec.rb 0r $HOME/.vim/skel/skel_spec.rb
"augroup END

" マップ定義 {{{2
" map系はリンク先のコマンドを再帰的に展開する。
" noremap系はリンク先のコマンドを再帰的に展開しない。
" 基本的にはnoremap系を使用する。
"   カーソル移動 => noremap
"   範囲選択     => vnoremap & onoremap
"     ビジュアルモードだけでセレクトモードを除くならxnoremp
"   テキスト入力補助 => inoremap
"   機能呼び出し => cnoremap
" <Nop>をリンク先に指定することでキーマップを無効にする。
" KEYMAP:
" バッファ移動用キーマップ
nnoremap H <Esc>:MBEbp<CR>
nnoremap L <Esc>:MBEbn<CR>
" 表示行単位で行移動
nnoremap j gj
nnoremap k gk
xnoremap j gj
xnoremap k gk
" 行末までヤンク
nnoremap Y y$
" ウィンドウサイズ変更
nnoremap + <C-w>+
nnoremap - <C-w>-
nnoremap _ <C-w>_
" すべてのフォールディングの開け閉め
nnoremap zO zR
nnoremap zC zM
" \で空白を入れない
inoremap \ \

" ジャンプ元に戻る
nnoremap <Leader><C-]> <C-t>
" コマンドモード時、現在のバッファのファイル名を出力
cnoremap <C-f> <C-r>%
" カーソルの下の単語でヘルプを引く
au myvimrc FileType vim nnoremap <buffer> <C-h> :<C-u>help<Space><C-r><C-w><CR>
au myvimrc FileType ruby nnoremap <buffer> <C-h> :<C-u>Ref<Space>refe<Space><C-r><C-w><CR>

" Leaderキーを設定（,のデフォルトの機能は\で使えるように退避）
"  u: Unite, b: Vundle, g: Fugitive
"  p: PasteToggle, r: Quickrun, f: VimFiler, s: VimShell, /: CommentToggle
"  <C-]>: TagJumpBack
let mapleader=","
noremap \ ,
" set paste/nopasteを切り替え
set pastetoggle=<Leader>p

" 誤操作防止
" 保存して閉じる
nnoremap ZZ <Nop>
" 保存せずに閉じる
nnoremap ZQ <Nop>
" EXモードに入る
noremap Q <Nop>

" 補完機能 {{{2
" <Tab>で補完 (neocomplcacheで代用されてそうなのでコメントアウト）
" {{{ Autocompletion using TAB key (disable)
" This function determines, wether we are on the start of the line text (then tab indents) or
" if we want to try autocompletion
"function! InsertTabWrapper()
  "let col = col('.') - 1
  "if !col || getline('.')[col - 1] !~ '\k'
    "return "\<TAB>"
  "else
    "if pumvisible()
      "return "\<C-N>"
    "else
      "return "\<C-N>\<C-P>"
    "end
  "endif
"endfunction
""" Remap the tab key to select action with InsertTabWrapper
"inoremap <tab> <c-r>=InsertTabWrapper()<cr>
"}}}

" Plugin設定 {{{1
" My Commands {{{2
"
" COMMAND:
" VimDiff
command! -complete=file -nargs=1 VimDiff :vertical diffsplit <args>
" Vimrc
command! Vimrc :e $MYVIMRC
" Grep
command! -complete=file -nargs=+ Grep :call GrepFunction(<f-args>)
function! GrepFunction(keyword, target)
  "Unite grep<CR>a:target<CR>a:keyword<CR>
  "<C-u>Unite<Space>grep: <Space>-buffer-name=grep<CR>
endfunction
" Help
command! Help :OpenBrowser http://vim-jp.org/vimdoc-ja/

" neocomplecache.vim {{{2
"
" KEYMAP:
"  <Tab> : 補完
"
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
"
" Enable heavy features.
" Use camel case completion.
"let g:neocomplcache_enable_camel_case_completion = 1
" Use underbar completion.
"let g:neocomplcache_enable_underbar_completion = 1
"
" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
\  'default' : '',
\  'vimshell' : $HOME.'/.vimshell_hist',
\  'scheme' : $HOME.'/.gosh_completions'
\}
"
" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
  let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
"
" Plugin key-mappings.
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()
"
" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplcache#smart_close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
"inoremap <expr><C-e>  neocomplcache#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"
"
" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplcache_enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplcache_enable_insert_char_pre = 1
"
" AutoComplPop like behavior.
"let g:neocomplcache_enable_auto_select = 1
"
" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplcache_enable_auto_select = 1
"let g:neocomplcache_disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"
"
" Enable omni completion.
au myvimrc FileType css setlocal omnifunc=csscomplete#CompleteCSS
au myvimrc FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
au myvimrc FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
au myvimrc FileType python setlocal omnifunc=pythoncomplete#Complete
au myvimrc FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"
" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
if !exists('g:neocomplcache_force_omni_patterns')
  let g:neocomplcache_force_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.php =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.c =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.cpp =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
"
" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplcache_omni_patterns.perl =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

" emmet.vim {{{2
"
" KEYMAP:
"  <C-e> : 展開
"  <C-_> : コメントアウト／イン
"          （_と/が同じキーマップになってるのでCtrl+/でできる）
"let g:user_emmet_leader_key = '<C-e>'
let g:user_emmet_expandabbr_key = '<C-e>'
let g:user_emmet_togglecomment_key = '<C-_>'
" タグのコンプリート
"let g:use_emmet_complete_tag = 1
let g:user_emmet_settings = {
\  'lang' : 'ja',
\  'indentation' : "  ",
\  'html' : {
\    'filters' : 'html',
\    'snippets' : {
\      'jq' : "<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n<script>\n\\$(function() {\n\t|\n})()\n</script>",
\      'cd' : "<![CDATA[|]]>",
\      'meta:viewport' : "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">",
\    },
\  },
\  'php' : {
\    'extends' : 'html',
\    'filters' : 'html,c',
\  },
\  'javascript' : {
\    'snippets' : {
\      'jq' : "\\$(function() {\n\t\\${cursor}\\${child}\n});",
\      'jq:json' : "\\$.getJSON(\"${cursor}\", function(data) {\n\t\\${child}\n});",
\      'jq:each' : "\\$.each(data, function(index, item) {\n\t\\${child}\n});",
\      'fn' : "(function() {\n\t\\${cursor}\n})();",
\      'tm' : "setTimeout(function() {\n\t\\${cursor}\n}, 100);",
\    },
\    'use_pipe_for_cursor' : 0,
\  },
\  'vim' : {
\    'snippets' : {
\      'nn' : 'nnoremap <silent> ${cursor} :<C-u>',
\      'nnu' : 'nnoremap <silent> [unite]${cursor}<CR> :<C-u>Unite<Space>\n\\<Space>-no-empty<Space>-silent<Space>-buffer-name=<CR>',
\    },
\  },
\  'css' : {
\    'filters' : 'fc',
\    'snippets' : {
\      'box-shadow' : "-webkit-box-shadow: 0 0 0 # 000;\n-moz-box-shadow: 0 0 0 0 # 000;\nbox-shadow: 0 0 0 # 000;",
\    },
\  },
\  'less' : {
\    'filters' : 'fc',
\    'extends' : 'css',
\  },
\}

" quickrun.vim {{{2
"
" COMMAND:
"  :QuickRun -args foo
" KEYMAP:
"  <Leader>r : バッファの内容を実行
"
" 実行にvimprocを使う
" エラー時はquickfixに表示する
let g:quickrun_config = {}
let g:quickrun_config = {
\  "_" : {
\    'runner' : 'vimproc',
\    'outputter' : 'error',
\    'outputter/error' : 'quickfix',
\    'outputter/error/success' : 'buffer',
\    'outputter/buffer/split' : ':belowright 5',
\    'outputter/buffer/close_on_empty' : 1
\  },
\}
" <C-c> で実行を強制終了させる
" quickrun.vim が実行していない場合には <C-c> を呼び出す
nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
" ruby.rspec
let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec' }
augroup RSpec
  au!
  au BufWinEnter,BufNewFile *_spec.rb set filetype=ruby.rspec
augroup END
" htmlをブラウザで開く（tyru/open-browser.vim プラグインが必要）
let g:quickrun_config['html'] = { 'command' : 'open', 'exec' : '%c %s', 'outputter': 'browser' }
let g:quickrun_config['xhtml'] = { 'command' : 'open', 'exec' : '%c %s', 'outputter': 'browser' }

" fugitive.vim {{{2
"
" DESC:
"  VimにGitコマンドを追加。
" COMMAND:
"  :Gstatus      : git status
"    Gstatusのバッファ上で
"      - : add/reset
"      D : diff
"      C : commit
"  :Gwrite/:Gadd : git add
"  :Gdiff        : git diff
"  :Gcommit -v   : git commit -v
" KEYMAP:
nnoremap [git] <Nop>
nmap <Leader>g [git]
nnoremap <silent> [git]s :<C-u>Gstatus<CR>
nnoremap <silent> [git]a :<C-u>Gwrite<CR>
nnoremap <silent> [git]d :<C-u>Gdiff<CR>
nnoremap <silent> [git]c :<C-u>Gcommit -v<CR>
nnoremap <silent> [git]l :<C-u>Glog<CR>

" surround.vim {{{2
"
" KEYMAP:
"  i : inside
"  a : all
"  s : side
"  S' : ビジュアルモードで選択した範囲を'で囲む
"  ysiw' : カーソル下の単語を'で囲む
"  cs'" : 'を"に変換する
"  ds' : 'で囲まれた範囲を消す

" rcodetools.vim {{{2
"
" DESC: xmpfilterの呼び出し設定
" <F1>でバッファ全体にxmpfilterを実行
"{{{ xmpfilter mapping (disable)
"nmap <silent> <F1> mzggVG!xmpfilter -a<cr>'z
"imap <silent> <F1> <Esc><F1>
"" <F2>で現在行/選択行にxmpfilterを実行
"map <silent> <F2> !xmpfilter -a<cr>
"nmap <silent> <F2> V<F2>
"imap <silent> <F2> <Esc><F2>a
"" <F3>で現在行/選択行に「# =>」マークを追加
"vmap <silent> <F3> !xmpfilter -m<cr>
"nmap <silent> <F3> V<F3>
"imap <silent> <F3> <Esc><F3>a
"" <F4>で現在行/選択行の「# =>」マークを削除
"vmap <silent> <F4> ms:call RemoveRubyEval()<CR>
"nmap <silent> <F4> V<F4>
"imap <silent> <F4> <Esc><F4>a
"" RemoveRubyEval() の定義
"function! RemoveRubyEval() range
  "let begv = a:firstline
  "let endv = a:lastline
  "normal Hmt
  "set lz
  "execute ":" . begv . "," . endv . 's/\s*# \(=>\|!!\).*$//e'
  "normal 'tzt`s
  "set nolz
  "redraw
"endfunction
"" JRuby用<F11>でバッファ全体にjxmpfilterを実行
"nmap <silent> <F11> mzggVG!jxmpfilter -a<cr>'z
"imap <silent> <F11> <Esc><F11>
"}}}

" MiniBufExplorer {{{2
"
" 自動起動
let g:miniBufExplAutoStart = 1
" バッファが２つ以上で開く
let g:miniBufExplBuffersNeeded = 2
" Diffモードでは隠す
let g:miniBufExplHideWhenDiff = 1
" バッファリストのサイクル化
let g:miniBufExplCycleArround = 1
" 表示行数を制限
let g:miniBufExplMaxSize = 1
" カラーリング
let g:did_minibufexplorer_syntax_inits = 1
" for buffers that have NOT CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveNormal ctermbg=LightGray ctermfg=DarkGray guibg=LightGray guifg=DarkGray
" for buffers that have CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveChanged ctermbg=Red ctermfg=DarkRed guibg=Red guifg=DarkRed
" for buffers that have NOT CHANGED and are NOT VISIBLE.
hi MBENormal ctermbg=LightGray ctermfg=DarkGray guibg=LightGray guifg=DarkGray
" for buffers that HAVE CHANGED and are NOT VISIBLE
hi MBEChanged ctermbg=Red ctermfg=DarkRed guibg=Red guifg=DarkRed
" buffers that have NOT CHANGED and are VISIBLE
"hi MBEVisibleNormal term=bold cterm=bold ctermbg=Gray ctermfg=Black gui=bold guibg=Gray guifg=Black
" buffers that have CHANGED and are VISIBLE
"hi MBEVisibleChanged term=bold cterm=bold ctermbg=DarkRed ctermfg=Black gui=bold guibg=DarkRed guifg=Black

" lightline.vim {{{2
"
" lightline config
"\  'colorscheme': 'wombat',
"\    'right': [['mode'], ['filename']]
let g:lightline = {
\  'mode_map': {'c': 'NORMAL'},
\  'active': {
\    'left': [['mode', 'paste'], ['filename', 'fugitive']]
\  },
\  'inactive': {
\    'left': [],
\    'right': [['filename']]
\  },
\  'component_function': {
\    'modified': 'MyModified',
\    'readonly': 'MyReadonly',
\    'fugitive': 'MyFugitive',
\    'filename': 'MyFilename',
\    'fileformat': 'MyFileformat',
\    'filetype': 'MyFiletype',
\    'fileencoding': 'MyFileencoding',
\    'mode': 'MyMode'
\  }
\}

function! MyModified()
  "return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : ''
endfunction
function! MyReadonly()
  "return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '[RO]' : ''
endfunction
function! MyFilename()
  return (&ft == 'vimfiler' ? vimfiler#get_status_string() :
\         &ft == 'unite' ? unite#get_status_string() :
\         &ft == 'vimshell' ? vimshell#get_status_string() :
\         '' != expand('%:t') ? expand('%:t') : '[No Name]') .
\        ('' != MyModified() ? ' ' . MyModified() : '') .
\        ('' != MyReadonly() ? ' ' . MyReadonly() : '')
endfunction
function! MyFugitive()
  try
    if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction
function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction
function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction
function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction
function! MyMode()
  return &ft == 'help' ? 'Help' :
\        &ft == 'minibufexpl' ? 'MBE' :
\        &ft == 'quickrun' ? 'QuickRun' :
\        &ft == 'qf' ? 'QuickFix' :
\        &ft == 'unite' ? 'Unite' :
\        &ft == 'vimfiler' ? 'VimFiler' :
\        &ft == 'vimshell' ? 'VimShell' :
\        winwidth(0) > 60 ? lightline#mode() : ''
endfunction

" ref.vim {{{2
"
" COMMAND:
"  :Ref refe Array
" KEYMAP:
"  Shift-K : 単語を検索
let g:ref_use_vimproc = 1 " 0:disable / 1:enable
let g:ref_refe_version = 2

" caw.vim {{{2
"
" コメントアウトの切り替え
nmap <Leader>/ <Plug>(caw:I:toggle)
vmap <Leader>/ <Plug>(caw:I:toggle)

" VimShell {{{2
"
" 動的プロンプト
let g:vimshell_prompt_expr = 'getcwd()." > "'
let g:vimshell_prompt_pattern = '^\f\+ > '
" KEYMAP:
" VimShellを起動
nnoremap <Leader>s :<C-u>VimShellPop<CR>
" irbを非同期で起動
nnoremap <silent> <Leader>irb :<C-u>VimShellInteractive irb<CR>
" 非同期で開いたインタプリタに現在の行を評価させる
au FileType vimshell inoremap <buffer> <Leader>s :<C-u>VimShellSendString<CR>
au FileType vimshell vmap <buffer> <Leader>s :<C-u>VimShellSendString<CR>

" VimFiler {{{2
"
" KEYMAP:
"  h : up dir, l : down dir, t : tree view (1 dir), T : tree view all
"  e : edit, <Space> : mark, c : copy, m : move, d : delete, yy : yank path
"  N : new file, K : new dir, * : mark all, U : mark off all, ? : keymap
"  a : action, H : VimShell, ge : system filer, x : system app
"
" vimデフォルトのエクスプローラをvimfilerで置き換える
let g:vimfiler_as_default_explorer = 1
" セーフモードを無効にした状態で起動する
let g:vimfiler_safe_mode_by_default = 0
" デフォルトでIDE風のFilerを開く
"au myvimrc VimEnter * VimFiler -split -simple -winwidth=30 -no-quit
" ステータスラインを上書きしない（lightline向け）
let g:vimfiler_force_overwrite_statusline = 0
"let g:netrw_liststyle=3
" KEYMAP:
nnoremap <Leader>f :<C-u>VimFilerBufferDir
\<Space>-buffer-name=vimfiler<Space>-split<Space>-simple<Space>-winwidth=30<Space>-quit<CR>
" Enterでツリー開閉、ファイル編集を可能に
au FileType vimfiler nmap <buffer> <expr> <Cr> vimfiler#smart_cursor_map("\<Plug>(vimfiler_expand_tree)", "\<Plug>(vimfiler_edit_file)")

" Unite {{{2
"
" COMMAND:
"  :Unite ${source} [${option}]
"  :Unite output:{コマンド名}
" KEYMAP:
"  <Tab> : Actionを開く
"  <Space> : 候補を選択する
"  * : 候補を全選択する
"  a : 候補でActionを開く
"  ? : Uniteのキーマップを表示
"
" 基本設定 {{{3
" 入力モードで開始
"let g:unite_enable_start_insert=1
" ヤンク履歴を使用可能にする
let g:unite_source_history_yank_enable = 1
" 最近使ったファイルの履歴数
let g:unite_source_file_mru_file = 200
" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
" ステータスラインを上書きしない（lightline向け）
let g:unite_force_overwrite_statusline = 0
" ESCキーを2回押すと終了する
au myvimrc FileType unite nnoremap <silent> <buffer> <Esc><Esc> :q<CR>
"au myvimrc FileType unite inoremap <silent> <buffer> <Esc><Esc> <Esc>:q<CR>
" unite grep に ag(The Silver Searcher) を使う
" Todo: 結果にファイル名が先頭に入らないからジャンプできない
"if executable('ag')
"  let g:unite_source_grep_command = 'ag'
"  let g:unite_source_grep_default_opts = '--nogroup --nocolor --column'
"  let g:unite_source_grep_recursive_opt = ''
"endif

" デフォルトアクションの変更 {{{3
" ref/refe
call unite#custom_default_action('source/ref/refe/*' , 'above')
" Uniteブックマークがディレクトリの場合はVimFilerで開く
call unite#custom_default_action('source/bookmark/directory' , 'vimfiler')
call unite#custom_default_action('directory' , 'vimfiler')

" アクションの追加 {{{3
" source:mappingにaction:verboseを追加する
let s:action = {
\ 'description' : 'verbose',
\ 'is_selectable' : 1,
\}
function! s:action.func(candidates)
  for candidate in a:candidates
    execute "verbose map" substitute(candidate.action__mapping, '\\\(<.*>\)', '\1', "g")
  endfor
endfunction
" kind ではなくて source の mapping に対して action を設定する
call unite#custom#action('source/mapping/*', 'verbose', s:action)
" preview（pキー）で action を実行したい場合は
" call unite#custom#action('source/mapping/*', 'preview', s:action)
unlet s:action

" キーマップ設定 {{{3
" KEYMAP:
nnoremap [unite] <Nop>
nmap <Leader>u [unite]
" ファイラ
nnoremap <silent> [unite]f<CR> :<C-u>Unite<Space>file
\<Space>-no-empty<Space>-silent<Space>-buffer-name=file<CR>
" 最近使ったファイルの一覧
nnoremap <silent> [unite]fm<CR> :<C-u>Unite<Space>file_mru
\<Space>-no-empty<Space>-silent<Space>-buffer-name=file_mru<CR>
" コマンド一覧を表示
nnoremap <silent> [unite]s<CR> :<C-u>Unite<Space>source
\<Space>-no-empty<Space>-silent<Space>-buffer-name=source<CR>

" 現在のバッファ内をグレップ
nnoremap <silent> [unite]g<CR> :<C-u>Unite<Space>grep:<C-R>%
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep<CR>
nnoremap <silent> [unite]gb<CR> :<C-u>Unite<Space>grep:<C-R>%
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep<CR>
" ディレクトリをグレップ
nnoremap <silent> [unite]gd<CR> :<C-u>Unite<Space>grep
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep-dir<CR>
" カーソル上の単語で現在のバッファをグレップ
nnoremap <silent> [unite]gw<CR> :<C-u>Unite<Space>grep:<C-R>%
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep-word<CR><C-R><C-W><CR>
" すべてのバッファをグレップ（agでは複数ファイルを選択できないためＣＯ）
nnoremap <silent> [unite]ga<CR> :<C-u>Unite<Space>grep:$buffers
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep-all-bufs<CR>

" ブックマーク（追加は:UniteBookmarkAdd）
nnoremap <silent> [unite]b<CR> :<C-u>Unite<Space>bookmark
\<Space>-no-empty<Space>-silent<Space>-buffer-name=bookmark<CR>
" Todo: 'Todo:'をつけた行をファイル保存時に自動でブックマークするau
nnoremap <silent> [unite]bt<CR> :<C-u>Unite<Space>bookmark:todos
\<Space>-no-empty<Space>-silent<Space>-buffer-name=bookmark:todos<CR>
" ブックマーク手動編集
nnoremap <silent> [unite]be<CR> :<C-u>edit $HOME/.unite/bookmark/default<CR>
" メニュー
nnoremap <silent> [unite]m<CR> :<C-u>Unite<Space>menu:shortcuts
\<Space>-no-empty<Space>-silent<Space>-buffer-name=menu:shortcuts<CR>
"{{{ メニュー設定
let g:unite_source_menu_menus = {
\ "shortcuts" : {
\   "description" : "command shortcuts.",
\   "command_candidates" : [
\     ["unite-colorscheme", "Unite colorscheme -auto-preview"],
\     ["unite-output:message", "Unite output:message"],
\     ["unite-mapping(all)", "Unite output:map|map!|lmap"],
\   ],
\ },
\}
"}}}

" リファレンス参照
" refe
nnoremap <silent> [unite]rr<CR> :<C-u>Unite<Space>ref/refe
\<Space>-no-empty<Space>-silent<Space>-buffer-name=ref/refe<CR>
" カーソル下の単語でrefe
nnoremap <silent> [unite]rrw<CR> :<C-u>Unite<Space>ref/refe
\<Space>-input=<C-r><C-w>
\<Space>-no-empty<Space>-silent<Space>-buffer-name=ref/refe<CR>
" ri
nnoremap <silent> [unite]rri<CR> :<C-u>Unite<Space>ref/ri
\<Space>-no-empty<Space>-silent<Space>-buffer-name=ref/ri<CR>

" ヤンクヒストリ
nnoremap <silent> [unite]y<CR> :<C-u>Unite<Space>history/yank
\<Space>-no-empty<Space>-silent<Space>-buffer-name=history/yank<CR>
" 直前のUniteコマンドを再実行
nnoremap <silent> [unite].<CR> :<C-u>UniteResume
\<Space>-no-empty<Space>-silent<CR>
" Uniteコマンドの履歴表示
nnoremap <silent> [unite]h :<C-u>Unite<CR> resume
\<Space>-no-empty<Space>-silent<Space>-buffer-name=resume<CR>

" Unite source サンプル {{{3
let s:unite_source = {
\   'name': 'lines',
\ }
function! s:unite_source.gather_candidates(args, context)
  let path = expand('%:p')
  let lines = getbufline('%', 1, '$')
  let format = '%' . strlen(len(lines)) . 'd: %s'
  return map(lines, '{
  \   "word": printf(format, v:key + 1, v:val),
  \   "source": "lines",
  \   "kind": "jump_list",
  \   "action__path": path,
  \   "action__line": v:key + 1,
  \ }')
endfunction
call unite#define_source(s:unite_source)
unlet s:unite_source

" markdown.vim {{{2
"let g:quickrun_config['mkd'] { 'outputter' : 'browser' }

