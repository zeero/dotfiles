" Last Change: 03-Feb-2014. {{{
" vim:ts=2:fdm=marker:
" scriptencoding utf-8
" }}}
"-----------------------------------------------------------------------------
" 初期設定
"-----------------------------------------------------------------------------
" 初期設定 {{{1
" VI互換モードOFF
if has('vim_starting')
  set nocompatible
endif
" 内部エンコーディングをutf-8に指定
set encoding=utf-8
" Winコマンドプロンプトではcp932
if !has('gui_running') && &encoding != 'cp932' && &term == 'win32'
  set termencoding=cp932
endif
" ファイルエンコーディング設定
set fencs=utf-8,cp932,euc-jp,iso-2022-jp
set ffs=unix,dos,mac
" キー入力をタイムアウトさせない
set notimeout
set ttimeout
" 高速ターミナル接続を行う
set ttyfast
" パス区切り文字を共通化する
set shellslash
" 自動コマンドの初期化
augroup myvimrc
  au!
augroup END
" 環境変数
let $MYVIMDIR = '~/.vim'
if !isdirectory($MYVIMDIR) && isdirectory($HOME . '/vimfiles')
  let $MYVIMDIR = '~/vimfiles'
endif
let $LANG = 'ja_JP.UTF-8'
" コンソール版で環境変数$DISPLAYが設定されていると起動が遅くなる件へ対応 {{{
if !has('gui_running') && has('xterm_clipboard')
  set clipboard=exclude:cons\\\|linux\\\|cygwin\\\|rxvt\\\|screen
endif "}}}
" WinではPATHに$VIMが含まれていないときにexeを見つけ出せないので修正 {{{
if has('win32') && $PATH !~? '\(^\|;\)' . escape($VIM, '\\') . '\(;\|$\)'
  let $PATH = $VIM . ';' . $PATH
endif "}}}

" NeoBundle {{{1
" 説明 {{{2
" COMMAND:
"  :NeoBundleInstall : Bundleされたプラグインをインストール
"  :NeoBundleSearch : vim-scriptにあるプラグインを検索
"
" NeoBundle開始 {{{2
filetype off
set rtp& rtp+=$MYVIMDIR/bundle/neobundle.vim
call neobundle#rc(expand($MYVIMDIR . '/bundle'))

" 基本 {{{2
NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundle 'Shougo/vimproc'
\, {'build': {
\    'windows': 'make -f make_mingw32.mak',
\    'cygwin':  'make -f make_cygwin.mak',
\    'mac':     'make -f make_mac.mak',
\    'unix':    'make -f make_unix.mak',
\  }}
NeoBundleLazy 'Shougo/vimshell'
\, {'autoload': {'commands': ['VimShell', 'VimShellPop']}
\,  'depends': 'Shougo/vimproc'}
NeoBundleLazy 'Shougo/neocomplcache'
\, {'autoload': {'insert': 1}}
NeoBundleLazy 'Shougo/neosnippet'
\, {'autoload': {'insert': 1
\,               'commands': ['NeoSnippetEdit']
\,               'unite_source': ['neosnippet']
\,               'filetypes': ['neosnippet']}}
NeoBundleLazy 'Shougo/neosnippet-snippets'
\, {'autoload': {'insert': 1}}
NeoBundle 'kien/ctrlp.vim'
NeoBundleLazy 'haya14busa/vim-easymotion'
\, {'autoload': {'mappings':
\    ['<Plug>(easymotion-S)', '<Plug>(easymotion-s)',
\     '<Plug>(easymotion-j)', '<Plug>(easymotion-k)']}}

" Unite {{{2
NeoBundleLazy 'Shougo/unite.vim'
\, {'autoload': {'commands': ['Unite', 'UniteWithBufferDir']}}
NeoBundleLazy 'Shougo/vimfiler'
\, {'autoload': {'commands': ['VimFiler', 'VimFilerBufferDir']}
\,  'depends': ['Shougo/unite.vim']}
NeoBundleLazy 'Shougo/unite-outline'
\, {'autoload': {'unite_sources': ['outline']}}
NeoBundleLazy 'thinca/vim-unite-history'
\, {'autoload': {'unite_sources': ['history']}}
NeoBundleLazy 'tsukkee/unite-help'
\, {'autoload': {'unite_sources': ['help']}}
NeoBundleLazy 'tsukkee/unite-tag'
\, {'autoload': {'unite_sources': ['tag']}}
NeoBundleLazy 'basyura/unite-rails'
\, {'autoload': {'unite_sources': ['rails']}}
NeoBundleLazy 'ujihisa/unite-rake'
\, {'autoload': {'unite_sources': ['rake']}}
NeoBundleLazy 'ujihisa/unite-gem'
\, {'autoload': {'unite_sources': ['gem']}}
NeoBundleLazy 'ujihisa/unite-locate'
\, {'autoload': {'unite_sources': ['locate']}}
NeoBundleLazy 'ujihisa/unite-colorscheme'
\, {'autoload': {'unite_sources': ['colorscheme']}}
NeoBundleLazy 'osyo-manga/unite-highlight'
\, {'autoload': {'unite_sources': ['highlight']}}
NeoBundleLazy 'tacroe/unite-alias'
\, {'autoload': {'unite_sources': ['alias']}}
NeoBundleLazy 'mattn/unite-gist'
\, {'autoload': {'unite_sources': ['gist']}
\,  'depends': ['mattn/gist-vim']}
NeoBundleLazy 'pasela/unite-webcolorname'
\, {'autoload': {'unite_sources': ['webcolorname']}}

" 入力補助 {{{2
NeoBundleLazy 'tyru/caw.vim'
\, {'autoload': {'mappings': '<Plug>(caw:'}}
NeoBundleLazy 'thinca/vim-qfreplace'
\, {'autoload': {'filetypes': ['unite', 'quickfix']}}
NeoBundleLazy 'kana/vim-smartchr'
\, {'autoload': {'insert': 1}}
NeoBundleLazy 'tpope/vim-surround'
\, {'autoload': {'mappings':
\    [['n', 'cs', '<Plug>Csurround']
\,    ['x', 'gS', '<Plug>VgSurround']
\,    ['n', 'ds', '<Plug>Dsurround']
\,    ['n', 'ySS', '<Plug>YSsurround']
\,    ['n', 'yss', '<Plug>Yssurround']
\,    ['n', 'ySs', '<Plug>YSsurround']
\,    ['n', 'yS', '<Plug>YSurround']
\,    ['n', 'ys', '<Plug>Ysurround']
\,    ['i', '<C-G>S', '<Plug>ISurround']
\,    ['i', '<C-G>s', '<Plug>Isurround']
\,    ['i', '<C-S>', '<Plug>Isurround']]}}
NeoBundleLazy 'kana/vim-textobj-user'
NeoBundleLazy 'kana/vim-textobj-fold'
\, {'autoload': {'mappings': [['ox', 'iz', 'az', '<Plug>(textobj-fold-']]}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'kana/vim-textobj-function'
\, {'autoload': {'mappings': [['ox', 'if', 'af', '<Plug>(textobj-function-']]}
\,  'depends': ['kana/vim-textobj-user']}
NeoBundleLazy 'kana/vim-operator-user'
NeoBundleLazy 'rhysd/vim-operator-surround'
\, {'autoload': {'mappings': '<Plug>(operator-surround-'}
\,  'depends': ['kana/vim-operator-user']}
NeoBundleLazy 'tyru/operator-camelize.vim'
\, {'autoload': {'mappings': '<Plug>(operator-camelize-'}
\,  'depends': ['kana/vim-operator-user']}
NeoBundleLazy 'tyru/operator-html-escape.vim'
\, {'autoload': {'mappings': '<Plug>(operator-html-'}
\,  'depends': ['kana/vim-operator-user']}
NeoBundleLazy 'tyru/operator-reverse.vim'
\, {'autoload': {'mappings': '<Plug>(operator-reverse-'}
\,  'depends': ['kana/vim-operator-user']}

" コマンド {{{2
NeoBundleLazy 'thinca/vim-ref'
\, {'autoload': {'commands': ['Ref']
\,               'unite-sources': ['ref']}
\,  'depends': ['mattn/webapi-vim']}
NeoBundle 'mojako/ref-sources.vim'
NeoBundleLazy 'thinca/vim-quickrun'
\, {'autoload': {'commands': ['QuickRun']
\,               'mappings': ['<Plug>(quickrun)']}}
NeoBundle 'scrooloose/syntastic'
NeoBundle 'tpope/vim-fugitive'
\, {'augroup': 'fugitive'}
NeoBundleLazy 'mattn/gist-vim'
\, {'autoload': {'commands': ['Gist']}
\,  'depends': ['mattn/webapi-vim']}
NeoBundleLazy 'gregsexton/gitv'
\, {'autoload': {'commands': ['Gitv']}
\,  'depends': ['tpope/vim-fugitive']}
NeoBundleLazy 'thinca/vim-prettyprint'
\, {'autoload': {'commands': ['PP']}}
NeoBundleLazy 'szw/vim-tags'
\, {'autoload': {'commands': ['TagsGenerate']}}
NeoBundleLazy 'majutsushi/tagbar'
\, {'autoload': {'commands': ['TagbarToggle', 'TagbarOpen']}}

" Ruby {{{2
NeoBundleLazy 'tpope/vim-rails'
\, {'autoload': {'filetypes': ['ruby']}}
NeoBundle 'taka84u9/vim-ref-ri'
" \, {'autoload': {'filetypes': ['ruby']
" \,               'unite_sources': ['ref/ri']}
" \,  'depends': 'thinca/vim-ref'}
NeoBundle 'edsono/vim-matchit'
NeoBundleLazy 'tpope/vim-bundler'
\, {'autoload': {'filetypes': ['ruby']}}

" HTML/JavaScript {{{2
NeoBundleLazy 'mattn/emmet-vim'
\, {'autoload': {'filetypes': ['html']}}
" NeoBundleLazy 'jiangmiao/simple-javascript-indenter'
" \, {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'jelera/vim-javascript-syntax'
\, {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'jQuery'
\, {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'https://bitbucket.org/teramako/jscomplete-vim'
\, {'autoload': {'filetypes': ['javascript']}
\,  'type': 'git'}

" 表示 {{{2
NeoBundle 'itchyny/lightline.vim'
NeoBundle 'fholgado/minibufexpl.vim'
\, {'augroup': 'MiniBufExpl'}
NeoBundle 'TagHighlight'
NeoBundle 'molokai'
NeoBundle 'wombat256.vim'
" 普段使わないカラースキームは使用時に:NeoBundleSource
NeoBundleLazy 'altercation/vim-colors-solarized'
NeoBundleLazy 'w0ng/vim-hybrid'
NeoBundleLazy 'nanotech/jellybeans.vim'
NeoBundleLazy 'jpo/vim-railscasts-theme'
NeoBundleLazy 'jonathanfilip/vim-lucius'
NeoBundleLazy 'Zephyr-Color-Scheme'
NeoBundleLazy 'newspaper.vim'
NeoBundleLazy 'http://blog.toddwerth.com/entry_files/8/ir_black.vim'
\, {'name': 'ir_black.vim',
\   'script_type': 'colors'}
NeoBundleLazy 'thinca/vim-guicolorscheme'
\, {'terminal': 1
\,  'autoload': {'commands': ['GuiColorScheme']}}
NeoBundle 'godlygeek/csapprox'
\, {'gui': 1}
NeoBundleLazy 'ScrollColors'
\, {'autoload': {'commands': ['SCROLLCOLOR']}}
NeoBundleLazy 'cocopon/colorswatch.vim'
\, {'autoload': {'commands': ['ColorSwatchGenerate']}}

" 補助 {{{2
NeoBundle 'thinca/vim-singleton'
\, {'gui': 1}
NeoBundle 'thinca/vim-localrc'
NeoBundleLazy 'vim-jp/vimdoc-ja'
\, {'autoload': {'commands': ['help']}}
NeoBundleLazy 'plasticboy/vim-markdown'
\, {'autoload': {'filetypes': ['mkd']}}
NeoBundleLazy 'mattn/webapi-vim'
NeoBundleLazy 'tyru/open-browser.vim'
\, {'autoload': {'filetypes': ['html', 'mkd']}}
NeoBundleLazy 'mattn/benchvimrc-vim'
\, {'autoload': {'commands': ['BenchVimrc']}}
NeoBundle 'haya14busa/vim-migemo'
NeoBundle 'rhysd/migemo-search.vim'
NeoBundleLazy 'sudo.vim'
\, {'autoload': {'commands': ['SudoWrite', 'SudoRead']}}
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundle 'autodate.vim'

" NeoBundle終了 {{{2
filetype plugin indent on
" インストールチェック
NeoBundleCheck

" NeoBundleコマンド定義 {{{2
command! Bi NeoBundleInstall
command! Bu NeoBundleUpdate
command! -nargs=? Bs NeoBundleSearch <args>
command! Bc NeoBundleClean
command! Bl NeoBundleList
command! Bso NeoBundleSource

" singleton.vim {{{1
if has('gui_running')
  let g:singleton#opener = 'tab drop'
  call singleton#enable()
endif

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" 基本設定
"-----------------------------------------------------------------------------
" 検索に関する設定 {{{1
" 検索時に大文字小文字を無視 (noignorecase:無視しない)
set ignorecase
" 大文字小文字の両方が含まれている場合は大文字小文字を区別
set smartcase
" インクリメンタルな検索
set incsearch
" 検索結果文字列のハイライトを有効にする
set hlsearch
" 検索時にファイルの最後まで行ったら最初に戻る (nowrapscan:戻らない)
set wrapscan
" タグ検索パスの設定
"set tags=./tags,tags
au myvimrc FileType * exe "setlocal tags+=" . $HOME . "/.tags/" . &ft . ".tags"
" タグ検索に二分検索をオフにする（vimdoc-jaフリーズ対策）
set notagbsearch
" バックスラッシュやクエスチョンを状況に合わせ自動的にエスケープ
cnoremap <expr> / getcmdtype() == '/' ? '\/' : '/'
cnoremap <expr> ? getcmdtype() == '?' ? '\?' : '?'
" 検索語が真ん中にくるようにする
noremap n nzzzv
noremap N Nzzzv
noremap * *zzzv
noremap # #zzzv
noremap g* g*zzzv
noremap g# g#zzzv
noremap { {zz
noremap } }zz

" 編集に関する設定 {{{1
" タブの画面上での幅
set tabstop=2
set shiftwidth=2
set softtabstop=2
" タブをスペースに展開する (noexpandtab:展開しない)
set expandtab
" 自動的にインデントする (noautoindent:インデントしない)
set autoindent
" 高度なオートインデント
set smartindent
" '<'や'>'でインデントする際に'shiftwidth'の倍数に丸める
set shiftround
" バックスペースでインデントや改行を削除できるようにする
set backspace=2
" 括弧入力時に対応する括弧を表示 (noshowmatch:表示しない)
set showmatch
" 対応括弧のハイライト表示の秒数
set matchtime=1
" 対応括弧に'<'と'>'のペアを追加
set matchpairs& matchpairs+=<:>
" コマンドライン補完するときに強化されたものを使う
set wildmenu
set wildmode=list:longest,full
" テキスト挿入中の自動折り返しを日本語に対応させる
set formatoptions&
set formatoptions+=mM
" コメント行で'o'で改行したらコメントをつけない
" ftpluginで上書きされてしまうためauでなんとかする
au myvimrc BufRead,BufNew,BufNewFile * set formatoptions-=o
" 文字数による自動折り返しはしない
set textwidth=0
" 区切り文字設定（単語の一部とする文字の設定）
"   Macではデフォルトの'iskeyword'がcp932に対応しきれていないので修正
"     @ : アルファベット
"     48-57 : 数字
"     128-167,224-235,192-255 : Extended ASCII characters（日本語には関係ない）
if has('mac')
  set iskeyword=@,48-57,_,128-167,224-235
  " '-'も単語の一部と認識させる
  set iskeyword+=-
else
  " '-'も単語の一部と認識させる
  set iskeyword&
  set iskeyword+=-
endif
" 日本語整形スクリプト(by. 西岡拓洋さん)用の設定
let format_allow_over_tw = 1	" ぶら下り可能幅
" 編集後保存していなくても別のファイルを開く
" set hidden
" 新しく開く代わりにすでに開いてあるバッファを開く
set switchbuf=useopen
" コマンドライン履歴
set history=1000
" 外部のエディタで編集中のファイルが変更されたら自動で読み直す
" （ウィンドウを移動する度に変更をチェックする）
set autoread
au myvimrc WinEnter * checktime
" クイックフィックスは常にcwindowで表示する
autocmd myvimrc QuickFixCmdPost [^l]* nested cwindow
autocmd myvimrc QuickFixCmdPost    l* nested lwindow
" 補完時に大文字小文字を区別しない
set infercase
" カーソルを文字が存在しない部分でも動けるようにする
" set virtualedit=all
" 行頭行末で前行次行に移動する
set whichwrap=b,s,h,l,<,>,[,]

" 画面表示の設定 {{{1
" シンタックスハイライト
syntax enable
" カラースキーマ設定
set t_Co=256
if has('gui_running')
  set background=dark
  colorscheme wombat256mod
else
"   let g:molokai_original = 1
  let g:rehash256 = 1
  colorscheme molokai
"   solarized {{{
"   set background=dark
"   let g:solarized_termcolors = 256
"   let g:solarized_termtrans = 1
"   let g:solarized_contrast = "high"
"   let g:solarized_visibility = "high"
"   colorscheme solarized
"   }}}
endif
" 遅延描画
" set lazyredraw
" 行を強調表示
set cursorline
" 行番号を表示 (nonumber:表示)
set number
" ルーラーを表示 (noruler:非表示)
set ruler
" タイトルを表示
set title
" 終了後のウィンドウタイトル
set titleold=vim
" タブや改行を表示 (nolist:非表示)
set list
" どの文字でタブや改行を表示するかを設定
set listchars=tab:»-,trail:-,extends:»,precedes:«,nbsp:%
" タブの左側にカーソル表示
"set listchars=tab:\ \
" 全角スペースも表示　
highlight JpSpace cterm=underline ctermfg=darkgrey gui=underline guifg=darkgrey
au myvimrc BufRead,BufNew * match JpSpace /　/
" □や○の文字があってもカーソル位置をずらさせない
set ambiwidth=double
" 画面最後の行を出来る限り表示する
set display&
set display+=lastline
" modelineを無視する
"set nomodeline
" フォールディング方式の指定（マーカー使用）(=fdm)
set foldmethod=marker
" 長い行を折り返して表示 (nowrap:折り返さない)
set wrap
" コマンドラインの高さ (Windows用gvim使用時はgvimrcを編集すること)
set cmdheight=1
" コマンドをステータス行に表示
set showcmd
" 常にステータス行を表示 (詳細は:he laststatus)
set laststatus=2
" ステータスラインに文字コードと改行文字とファイルタイプを表示する
"set statusline=%<%f\%m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%l,%c
"set statusline=%<%t\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']['.&ft.']'}%=%l,%c%V%8P
" タブは非表示
"set showtabline=0
" vsplitは右に開く
set splitright
" 画面サイズが広い場合はバッファを右に移動させる
" TODO: Unite開くと低くなる
"au myvimrc BufRead,BufNew,BufNewFile * if winwidth(0) > 140 | wincmd L | wincmd _ | endif

" GUI固有の画面表示の設定 {{{1
if has('gui_running')
  set guioptions&
  " メニューファイルが存在しない場合、menu.vimを読み込まない
  if !filereadable($VIMRUNTIME . '/menu.vim')
    set guioptions+=M
  endif
  " ビジュアル選択を自動的にクリップボードへ
  "set guioptions+=a
  " スクロールバーを非表示にする
  set guioptions-=r
  set guioptions-=R
  set guioptions-=l
  set guioptions-=L
  " フォントを指定
  set guifont=Ricty_Diminished:h12:cSHIFTJIS
  " ウィンドウサイズを最大化する
  au myvimrc GUIEnter * simalt ~x
  " ヤンクでクリップボードを共有する
  "if has('clipboard')
  "  set clipboard=unnamed
  "endif
  " マウスを有効にする
  if has('mouse')
    set mouse=a
  endif
  " IME制御をオフにする
  set iminsert=0
  set imsearch=0
  set noimcmdline
  " Alt+CとAlt+Pでコピペする
  vnoremap <M-c> "+y
  imap <expr> <M-v> '<C-o>"+gP'
  cnoremap <M-v> <C-r><C-o>*
  " バッファがローカルバッファに表示されなくなった場合は削除する
  " （[No Name]バッファへの対策）
  set bufhidden=wipe
  " タブのラベル
  set guitablabel=%n:%t
endif

" ファイル操作に関する設定 {{{1
" バックアップファイル、swapファイルを作成しない
set nobackup
set nowritebackup
set noswapfile
" スワップファイルの作成ディレクトリにパスを追加
" set directory&
" set directory+=,~/tmp,$TMP
" 永続undo
if has('persistent_undo')
  set undodir=$HOME/.vimundo
  set undofile
endif
" vimrcの保存時に再読み込み
if !has('gui_running')
  au myvimrc BufWritePost *vimrc nested source $MYVIMRC
else
  au myvimrc BufWritePost *vimrc nested source $MYVIMRC |
     \ if has('gui_running') && filereadable($MYGVIMRC) | source $MYGVIMRC
endif
" ファイルを開くと、そのファイルと同じディレクトリに移動
" 名無しのvim使い <http://nanasi.jp/articles/vim/cd_vim.html>
au myvimrc BufRead .* if expand("%:p:h") != '' | exe ":lcd " . expand("%:p:h") | endif
"set autochdir （設定するとVimShellが動かなくなる）
" 前回終了したカーソル行に移動して真ん中にする（フォールドがあれば開く）
" TODO: 真ん中にならない。。。フォールドは開くのに。。。
au myvimrc BufRead * call s:my_readpost_move()
function! s:my_readpost_move()
  if line("'\"") > 0 && line("'\"") <= line("$")
    normal g`"
  endif
  normal zvzz
endfunction

" ファイルタイプ別の設定 {{{1
" Ruby
au myvimrc FileType ruby setlocal fenc=utf8 ff=unix
" Git commit log
au myvimrc FileType gitcommit
\ setlocal nofoldenable |
\ wincmd L |
\ let @/ = "^@@ .*"
" Vim
" バックスラッシュのインデントを無くす
let g:vim_indent_cont = 0
" vimrc、helpでは:もiskに入れる
if expand("%") =~ "vimrc"
  setlocal iskeyword+=:
endif
au myvimrc FileType help setlocal iskeyword+=:
" JavaSciprt
au myvimrc BufRead,BufNew,BufNewFile *.json setlocal ft=javascript
au myvimrc BufRead,BufNew,BufNewFile jquery.*.js setlocal ft=javascript syntax=jquery
" Apache
au myvimrc BufRead,BufNew,BufNewFile httpd*.conf setlocal ft=apache
" ctags
au myvimrc BufRead,BufNew,BufNewFile *.tags setlocal ft=tags

" コマンド定義 {{{1
"
" COMMAND:
" H(elp)
" TODO: トグリたい
command! -nargs=? -complete=help H if winwidth(0) > 140 | vertical help <args> | vertical resize 79 | else | help <args> | endif
" Vimdoc
command! VimDoc OpenBrowser http://vim-jp.org/vimdoc-ja/
" K(otoba)
command! -nargs=1 K Ref kotobankej <args>

" Vimrc、Sorc
command! Vimrc tabe $MYVIMRC
command! Sorc source $MYVIMRC
" Esnip
command! -nargs=? -complete=customlist,neosnippet#commands#_edit_complete Esnip NeoSnippetEdit -vertical -split <args>
" Bdo
command! Bdo call s:my_command_bd_other()
function! s:my_command_bd_other() "{{{
  let i = 1
  let cur = bufnr("%")
  while i <= bufnr("$")
    if buflisted(i) && i != cur
      exe "bdelete" i
    endif
    let i = i + 1
  endwhile
endfunction "}}}
" Lcd
command! Lcd exe "lcd " . expand("%:p:h")
" Ls
command! -nargs=* -complete=file Ls echo vimproc#system("ls <args>")
" Info
nnoremap <C-g> :<C-u>Info<CR>
command! Info call s:my_info()
function! s:my_info() "{{{
  echohl Identifier
  echo expand("%:t")
  echohl None
  echo expand("%:p")
  let old_status = v:statusmsg
  exe "silent normal g\<C-g>"
  let msg = split(v:statusmsg, "; ")
  for line in msg
    echo line
  endfor
  let v:statusmsg = old_status
endfunction "}}}

" SyntaxInfo
command! SyntaxInfo call s:get_syn_info()
function! s:get_syn_id(transparent) "{{{
  let synid = synID(line("."), col("."), 1)
  if a:transparent
    return synIDtrans(synid)
  else
    return synid
  endif
endfunction
function! s:get_syn_attr(synid)
  let name = synIDattr(a:synid, "name")
  let ctermfg = synIDattr(a:synid, "fg", "cterm")
  let ctermbg = synIDattr(a:synid, "bg", "cterm")
  let guifg = synIDattr(a:synid, "fg", "gui")
  let guibg = synIDattr(a:synid, "bg", "gui")
  return {
        \ "name": name,
        \ "ctermfg": ctermfg,
        \ "ctermbg": ctermbg,
        \ "guifg": guifg,
        \ "guibg": guibg}
endfunction
function! s:get_syn_info()
  let baseSyn = s:get_syn_attr(s:get_syn_id(0))
  echo "name: " . baseSyn.name .
        \ " ctermfg: " . baseSyn.ctermfg .
        \ " ctermbg: " . baseSyn.ctermbg .
        \ " guifg: " . baseSyn.guifg .
        \ " guibg: " . baseSyn.guibg
  let linkedSyn = s:get_syn_attr(s:get_syn_id(1))
  echo "link to"
  echo "name: " . linkedSyn.name .
        \ " ctermfg: " . linkedSyn.ctermfg .
        \ " ctermbg: " . linkedSyn.ctermbg .
        \ " guifg: " . linkedSyn.guifg .
        \ " guibg: " . linkedSyn.guibg
endfunction "}}}
" Colortest
command! Colortest belowright vsplit $VIMRUNTIME/syntax/colortest.vim | source $VIMRUNTIME/syntax/colortest.vim
" Hitest
command! Hitest belowright vsplit $VIMRUNTIME/syntax/hitest.vim | source $VIMRUNTIME/syntax/hitest.vim

" VimDiff
command! -complete=file -nargs=1 VimDiff vertical diffsplit <args>
" DiffOrig（編集前とdiff）
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis

" キーマップ定義 {{{1
" 説明 {{{2
" map系はリンク先のコマンドを再帰的に展開する。
" noremap系はリンク先のコマンドを再帰的に展開しない。
" 基本的にはnoremap系を使用する。
"   カーソル移動 => nnoremap
"   範囲選択     => vnoremap & onoremap
"     ビジュアルモードだけでセレクトモードを除くならxnoremp
"   テキスト入力補助 => inoremap
"   機能呼び出し => cnoremap
" <Nop>をリンク先に指定することでキーマップを無効にする。
" KEYMAP:
" 移動 {{{2
" 表示行単位で行移動
nnoremap j gj
nnoremap k gk
xnoremap j gj
xnoremap k gk
" スペースでページ移動
nnoremap <Space> <PageDown>
nnoremap <S-Space> <PageUp>
" 0/^のトグル
nnoremap <expr>0  col('.') == 1 ? '^' : '0'
nnoremap <expr>^  col('.') == 1 ? '^' : '0'
" diffハンクへのジャンプ
au myvimrc BufRead * nnoremap <buffer> [[ [czz
au myvimrc BufRead * nnoremap <buffer> ]] ]czz
nnoremap do do]czz
nnoremap dp dp]czz
" TODO: normal ]cが効かない…
au myvimrc BufRead * if 1 == &diff | noh | exe 'normal ]c' | endif

" ウィンドウ／タブ {{{2
" バッファ移動用キーマップ
nnoremap H <Esc>:MBEbp<CR>
nnoremap L <Esc>:MBEbn<CR>
" タブページ操作
nnoremap <Tab> <C-PageDown>
nnoremap <S-Tab> <C-PageUp>
nnoremap ,<Tab> :<C-u>tabnew<CR>
" gfはタブで開く
nnoremap gf :tabe <cfile><CR>

" ノーマルモード操作 {{{2
" 行末までヤンク
nnoremap Y y$
" すべてのフォールディングの開け閉め
nnoremap zO zRz<CR>
nnoremap zC zMzz
nnoremap zo zvz<CR>
nnoremap zc zczz
" Help、QuickFix、fugitiveでは<Esc><Esc>でバッファを閉じる
au myvimrc FileType help,qf,gitcommit nnoremap <buffer> <Esc><Esc> <C-w>c
" ESCを二回でハイライトを消す
nnoremap <silent> <Esc><Esc> :noh<CR>
" ウィンドウサイズ変更
nnoremap <S-Up> <C-w>+
nnoremap <S-Down> <C-w>-
nnoremap <S-Left> <C-w><
nnoremap <S-Right> <C-w>>

" オペレータ {{{2
" surround
map s <Plug>(operator-surround-append)
map S <Plug>(operator-surround-delete)
map <C-s> <Plug>(operator-surround-replace)
" snake_case<=>CamelCase
map _ <Plug>(operator-camelize-toggle)
" HTMLエスケープ
vmap ; <Plug>(operator-html-escape)
" 反転
vmap r <Plug>(operator-reverse-text)

" インサートモード {{{2
" 移動
inoremap <C-a> <Home>
inoremap <C-e> <End>
inoremap <C-w> <S-Left>
inoremap <C-b> <S-Right>
" CTRL-Uのundo対策（from exaple.vim）
inoremap <C-U> <C-G>u<C-U>

" コマンドモード {{{2
" 現在のバッファのファイル名を出力
cnoremap <C-f> <C-r>%
" コマンド行頭に移動
cnoremap <C-a> <Home>
" 単語移動
cnoremap <C-w> <S-Left>
cnoremap <C-b> <S-Right>
" ヒストリ
cnoremap <C-n> <Down>
cnoremap <C-p> <Up>

" リーダーキー {{{2
" 説明 {{{3
" ,をリーダーキーにする（衝突を避けるためにmapleaderは設定しない）
"  []: TagJump, h: H(elp), r: Quickrun, f: VimFiler, s: VimShell
"  p: PasteToggle, /: CommentToggle, m: MBEToggle, ;: TagbarToggle, ,: PreviewToggle
"  v: VisualMode
" タグジャンプ {{{3
nnoremap <C-]> g<C-]>
vnoremap <C-]> g<C-]>
nnoremap ,] g<C-]>
vnoremap ,] g<C-]>
nnoremap <C-j> :tab tj <C-R>=expand('<cword>')<CR><CR>
vnoremap <C-j> y:tab tj <C-r>"<CR>
nnoremap ,[ <C-t>
nnoremap <C-k> <C-t>
nnoremap <C-h> <C-o>
nnoremap <C-l> <C-i>

" リファレンス {{{3
nnoremap K :<C-u>Ref kotobankej <C-r><C-w><CR>
vnoremap K y:<C-u>Ref kotobankej <C-r>"<CR>
au myvimrc FileType vim nnoremap <buffer> ,h :<C-u>H<Space><C-r><C-w><CR>
au myvimrc FileType vim vnoremap <buffer> ,h y:<C-u>H<Space><C-r>"<CR>
au myvimrc FileType ruby nnoremap <buffer> ,h :<C-u>Ref<Space>refe<Space><C-r><C-w><CR>
au myvimrc FileType ruby vnoremap <buffer> ,h y:<C-u>Ref<Space>refe<Space><C-r>"<CR>
au myvimrc FileType javascript nnoremap <buffer> ,h :<C-u>Ref<Space>javascript<Space><C-r><C-w><CR>
au myvimrc FileType javascript vnoremap <buffer> ,h y:<C-u>Ref<Space>javascript<Space><C-r>"<CR>
au myvimrc FileType sh nnoremap <buffer> ,h :<C-u>Ref<Space>man<Space><C-r><C-w><CR>
au myvimrc FileType sh vnoremap <buffer> ,h y:<C-u>Ref<Space>man<Space><C-r>"<CR>

" QuickRun {{{3
nmap ,r <Plug>(quickrun)
vnoremap ,R y:QuickRun -src '<C-r>"'<CR>
vnoremap ,r y:QuickInspector<CR>
command! QuickInspector :call s:my_quick_inspector()
function! s:my_quick_inspector() "{{{
  if !exists('*s:my_quick_inspector_'.&ft)
    echoerr 'not implemented whis this filetype.'
    return
  endif
  hi QuickInspector term=underline cterm=underline ctermfg=67
  \ gui=underline guifg=67
  let expr = substitute(getreg('"'), '\(\s\|\n\)\+$', '', '')
  echohl QuickInspector
  echo 'expr: '.expr
  echohl None
  exe 'echo s:my_quick_inspector_'.&ft.'(expr)'
  echo ''
endfunction "}}}
function! s:my_quick_inspector_vim(expr) "{{{
  return eval(a:expr)
endfunction "}}}
function! s:my_quick_inspector_ruby(expr) "{{{
  return vimproc#system('ruby -e '.shellescape('p '.a:expr))
endfunction "}}}

" トグル {{{3
" PASTEモードの切り替え
set pastetoggle=,p
" コメントアウトの切り替え（caw.vim）
nmap ,/ <Plug>(caw:I:toggle)
vmap ,/ <Plug>(caw:I:toggle)
" VimFiler
nnoremap ,f :<C-u>VimFilerBufferDir
\<Space>-buffer-name=vimfiler<Space>-split<Space>-simple<Space>-winwidth=30<Space>-quit<Space>-toggle<CR>
" VimShell
nnoremap ,s :<C-u>set noautochdir<CR>:<C-u>VimShellPop<Space>-toggle<CR>
" MBEToggle
nnoremap ,m :<C-u>MBEToggle<CR>
" TagbarToggle
nnoremap ,; :<C-u>TagbarToggle<CR>
" PreviewToggle
nnoremap ,, :<C-u>PreviewToggle<CR>
vnoremap ,, y:call PreviewWord('<C-r>"')<CR>
command! PreviewToggle :call s:my_preview_toggle()
function! s:my_preview_toggle() "{{{
  silent! wincmd P
  if &previewwindow
    "au! Cursorhold
    pclose
  else
    "au! CursorHold * nested call PreviewWord()
    call PreviewWord()
  endif
endfunction
function! PreviewWord(...)
  " 設定
  let direction = "belowright"
  let height = 7
  let action = "ptjump"
  "hi PreviewWord term=bold ctermfg=black ctermbg=lightgreen guifg=black guibg=lightgreen
  au myvimrc ColorScheme * hi link PreviewWord Search

  if &previewwindow			" プレビューウィンドウ内では実行しない
    return
  endif
  let w = a:0 == 0 ? expand("<cword>") : a:1		" カーソル下の単語を得る
  "if w =~ '\a'			" その単語が文字を含んでいるなら
  if w !~ '\s'			" その単語が文字を含んでいるなら

    " 別のタグを表示させる前にすでに存在するハイライトを消去する
    silent! wincmd P			" プレビューウィンドウにジャンプ
    if &previewwindow			" すでにそこにいるなら
      match none			" 存在するハイライトを消去する
      wincmd p			" もとのウィンドウに戻る
    endif

    " カーソル下の単語にマッチするタグを表示してみる
    try
       exe direction action w
    catch
      echohl ErrorMsg
      echo substitute(v:exception, '^Vim\%((\a\+)\)\=:', '', "")
      echohl None
      return
    endtry

    silent! wincmd P			" プレビューウィンドウにジャンプ
    if &previewwindow		" すでにそこにいるなら
      if has("folding")
        silent! .foldopen		" 閉じた折り畳みを開く
      endif
      exe "resize" height
      exe "normal zz"
      call search("$", "b")		" 前の行の最後へ
      let w = substitute(w, '\\', '\\\\', "")
      call search('\<\V' . w . '\>')	" カーソルをマッチしたところへ
      " ここで単語にハイライトをつける
      exe 'match PreviewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
      wincmd p			" もとのウィンドウへ戻る
    endif
  endif
endfunction "}}}

" その他 {{{3
" カーソル位置から末尾までビジュアル選択
nnoremap ,v v$

" 無効化 {{{2
" 保存して閉じる
nnoremap ZZ <Nop>
" 保存せずに閉じる
nnoremap ZQ <Nop>
" EXモードに入る
nnoremap Q <Nop>

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" Plugin設定
"-----------------------------------------------------------------------------
" Unite {{{1
" 説明 {{{2
" COMMAND:
"  :Unite ${source} [${option}]
"  :Unite output:{コマンド名}
" KEYMAP:
"  <Tab> : Actionを開く
"  <Space> : 候補を選択する
"  * : 候補を全選択する
"  a : 候補でActionを開く
"  ? : Uniteのキーマップを表示
"
" 基本設定 {{{2
" 入力モードで開始
"let g:unite_enable_start_insert=1
" ヤンク履歴を使用可能にする
let g:unite_source_history_yank_enable = 1
" 最近使ったファイルの履歴数
let g:unite_source_file_mru_file = 200
" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
" ステータスラインを上書きしない（lightline向け）
let g:unite_force_overwrite_statusline = 0
" プロンプト文字
let g:unite_prompt = '❯ '
" カーソルラインのハイライト
let g:unite_cursor_line_highlight = 'MatchParen'
au myvimrc FileType unite call s:my_unite_keymaps()
function! s:my_unite_keymaps() "{{{
  " <C-j>/<C-k>で移動
  nmap <silent> <buffer> <C-j> <Plug>(unite_loop_cursor_down)
  imap <silent> <buffer> <C-j> <Plug>(unite_select_next_line)
  nmap <silent> <buffer> <C-k> <Plug>(unite_loop_cursor_up)
  imap <silent> <buffer> <C-k> <Plug>(unite_select_previous_line)
  " ESCキーを2回押すと終了する
  nmap <silent> <buffer> <Esc><Esc> <Plug>(unite_all_exit)
  " 入力文字が無い時に<BS>で前の画面に戻る
  imap <expr> <silent> <buffer> <BS> unite#helper#get_input() == '' ? "\<Plug>(unite_exit)" : "\<BS>"
  " キャッシュ更新
  nmap <silent> <buffer> <F5> <Plug>(unite_redraw)
endfunction "}}}
"au myvimrc FileType unite inoremap <silent> <buffer> <Esc><Esc> <Esc>:q<CR>
" unite grep に ag(The Silver Searcher) を使う
if executable('ag')
 let g:unite_source_grep_command = 'ag'
 let g:unite_source_grep_default_opts =
 \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
 \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
 let g:unite_source_grep_recursive_opt = ''
endif

" デフォルトアクションの変更 {{{2
" openable
call unite#custom_default_action('file', 'tabopen')
" directory
call unite#custom_default_action('directory', 'vimfiler')
" ref
call unite#custom_default_action(
\ 'source/ref/refe/*,source/ref/ri/*,source/ref/javascript/*,source/ref/jquery/*,source/ref/man/*',
\ 'vsplit')
" help
call unite#custom_default_action('source/help/*', 'vsplit')

" アクションの追加 {{{2
" source:mappingにaction:verboseを追加する
let s:action = {
\ 'description': 'verbose',
\ 'is_selectable': 1,
\}
function! s:action.func(candidates)
  for candidate in a:candidates
    execute "verbose map" substitute(candidate.action__mapping, '\\\(<.*>\)', '\1', "g")
  endfor
endfunction
" kind ではなくて source の mapping に対して action を設定する
call unite#custom#action('source/mapping/*', 'verbose', s:action)
" preview（pキー）で action を実行したい場合は
" call unite#custom#action('source/mapping/*', 'preview', s:action)
unlet s:action

" メニュー設定 {{{2
let g:unite_source_menu_menus = {
\ 'shortcuts': {
\   'description': 'command shortcuts.',
\   'command_candidates': [
\     ['help-neobundle-autoload', 'H neobundle-options-autoload'],
\     ['help-registers', 'H registers'],
\     ['help-map-overview', 'H map-overview'],
\     ['unite-colorscheme', 'Unite colorscheme -auto-preview'],
\     ['unite-output:message', 'Unite output:message'],
\     ['unite-mapping(all)', 'Unite output:map|map!|lmap'],
\   ],
\ },
\}

" Uniteコマンド定義 {{{2
" 汎用
command! -nargs=+ -complete=customlist,unite#complete#source U Unite <args>
\ -no-empty -silent -buffer-name=<args>

" 現在のバッファ内をグレップ
command! Ug Unite grep:%
\ -no-empty -silent -buffer-name=grep
" カーソル下の単語で現在のバッファをグレップ
command! Ugw exe 'Unite grep:%::' .
\ escape(expand("<cword>"), '- \\') .
\ ' -no-empty -silent -buffer-name=grep-word'
" ディレクトリをグレップ
command! Ugd exe 'Unite grep' .
\ ' -silent -buffer-name=grep-dir' .
\ ' -tab -no-split -no-quit'
\ | setlocal splitbelow | exe 'normal <Plug>(unite_toggle_auto_preview)'
" すべてのバッファをグレップ
command! Ugb exe 'Unite grep:$buffers' .
\ ' -silent -buffer-name=grep-all-bufs' .
\ ' -tab -no-split -no-quit
\ | setlocal splitbelow | exe 'normal <Plug>(unite_toggle_auto_preview)'

" ブックマーク（追加はUniteBookmarkAdd）
command! Ub Unite bookmark
\ -no-empty -silent -buffer-name=bookmark
" ブックマーク追加
command! Uba UniteBookmarkAdd
" ブックマーク手動編集
command! Ube edit $HOME/.unite/bookmark/default
" TODO: 'TODO:'をつけた行をファイル保存時に自動でブックマークするau
command! Ubt Unite bookmark:todos
\ -no-empty -silent -buffer-name=bookmarktodos
" メニュー
command! Um Unite menu:shortcuts
\ -no-empty -silent -buffer-name=menushortcuts

" リファレンス参照
" refe
command! Urr Unite ref/refe
\ -no-empty -silent -buffer-name=ref/refe
" カーソル下の単語でrefe
command! Urrw exe 'Unite ref/refe ' .
\ '-no-empty -silent -buffer-name=ref/refe -input=' .
\ escape(expand("<cword>"), '- \\')
" ri
command! Urri Unite ref/ri
\ -no-empty -silent -buffer-name=ref/ri

" 直前のUniteコマンドの結果に戻る
command! Ur UniteResume
\ -no-empty -silent
" ヤンクヒストリ
command! Uy Unite history/yank
\ -no-empty -silent -buffer-name=history/yank
" スニペット候補の表示
command! Usnip Unite neosnippet
\ -no-empty -silent -buffer-name=neosnippet
" マッピング表示
command! Umap :Unite output:map|map!|lmap
\ -no-empty -silent -buffer-name=output:map

" Unite source サンプル {{{2
let s:unite_source = {
\   'name': 'lines',
\ }
function! s:unite_source.gather_candidates(args, context)
  let path = expand('%:p')
  let lines = getbufline('%', 1, '$')
  let format = '%' . strlen(len(lines)) . 'd: %s'
  return map(lines, '{
  \   "word": printf(format, v:key + 1, v:val),
  \   "source": "lines",
  \   "kind": "jump_list",
  \   "action__path": path,
  \   "action__line": v:key + 1,
  \ }')
endfunction
call unite#define_source(s:unite_source)
unlet s:unite_source

" VimFiler {{{1
"
" KEYMAP:
"  h : up dir, l : down dir, t : tree view (1 dir), T : tree view all
"  e : edit, <Space> : mark, c : copy, m : move, d : delete, yy : yank path
"  N : new file, K : new dir, * : mark all, U : mark off all, ? : keymap
"  a : action, H : VimShell, ge : system filer, x : system app
"
" vimデフォルトのエクスプローラをvimfilerで置き換える
let g:vimfiler_as_default_explorer = 1
" セーフモードを無効にした状態で起動する
let g:vimfiler_safe_mode_by_default = 0
" ディレクトリ移動
let g:vimfiler_enable_auto_cd = 1
" タブで開く
let g:vimfiler_edit_action = 'tabopen'
" デフォルトでIDE風のFilerを開く
" au myvimrc VimEnter * VimFiler -split -simple -winwidth=30 -no-quit
" ステータスラインを上書きしない（lightline向け）
"let g:vimfiler_force_overwrite_statusline = 0
"let g:netrw_liststyle=3
" Enterでツリー開閉、ファイル編集を可能に
au myvimrc FileType vimfiler nmap <buffer> <expr> <CR> vimfiler#smart_cursor_map("\<Plug>(vimfiler_expand_tree)", "\<Plug>(vimfiler_edit_file)")
" ESCキーを2回押すと終了する
au myvimrc FileType vimfiler nnoremap <silent> <buffer> <Esc><Esc> :q<CR>
" キーマップヘルプを表示
au myvimrc FileType vimfiler nnoremap <buffer> ,, :MyVimFilerHelp<CR>
command! MyVimFilerHelp :call s:my_vimfiler_help()
function! s:my_vimfiler_help() "{{{
  silent! wincmd P
  if &previewwindow
    pclose
    return
  endif

  hi link MyVimFilerHelp Comment
  hi link MyVimFilerHelpTitle PreProc
  hi link MyVimFilerHelpKey Identifier
  belowright pedit $MYVIMDIR/doc/vimfiler_help.txt
  silent! wincmd P
  if &previewwindow
    match none
    setlocal nonumber
    resize 20
    normal gg
    nnoremap <buffer> ,, :MyVimFilerHelp<CR>
    call matchadd('MyVimFilerHelp', '.', 0)
    call matchadd('MyVimFilerHelpTitle', '--.*')
    call matchadd('MyVimFilerHelpKey', '\(.\+\):')
    wincmd p
  endif
endfunction "}}}

" VimShell {{{1
"
" 動的プロンプト
let g:vimshell_prompt_expr = 'getcwd()." > "'
let g:vimshell_prompt_pattern = '^\f\+ > '
" irbを非同期で起動
command! Irb :VimShellInteractive irb
" 非同期で開いたインタプリタに現在の行を評価させる
au myvimrc FileType vimshell inoremap <buffer> ,s :<C-u>VimShellSendString<CR>
au myvimrc FileType vimshell vmap <buffer> ,s :<C-u>VimShellSendString<CR>

" NeoComplCache {{{1
"
" KEYMAP:
"  <Tab> : 補完
"
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
"
" Enable heavy features.
" Use camel case completion.
"let g:neocomplcache_enable_camel_case_completion = 1
" Use underbar completion.
"let g:neocomplcache_enable_underbar_completion = 1
"
" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
\  'default': '',
\  'vimshell': $HOME.'/.vimshell_hist',
\  'scheme': $HOME.'/.gosh_completions',
\  'html': $MYVIMDIR.'/dict/bootstrap.dict',
\}
"
" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
  let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
"
" Plugin key-mappings.
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()
"
" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplcache#smart_close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
endfunction
" <Tab>: completion.
inoremap <expr> <Tab>  pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab>  pumvisible() ? "\<C-p>" : "\<Tab>"
" <C-h>, <BS>: close popup and delete backword char.
" inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
"inoremap <expr><C-e>  neocomplcache#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"
"
" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplcache_enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplcache_enable_insert_char_pre = 1
"
" AutoComplPop like behavior.
"let g:neocomplcache_enable_auto_select = 1
"
" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplcache_enable_auto_select = 1
"let g:neocomplcache_disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"
"
" Enable omni completion.
au myvimrc FileType css setlocal omnifunc=csscomplete#CompleteCSS
au myvimrc FileType html,mkd setlocal omnifunc=htmlcomplete#CompleteTags
au myvimrc FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
au myvimrc FileType python setlocal omnifunc=pythoncomplete#Complete
au myvimrc FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"
" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
if !exists('g:neocomplcache_force_omni_patterns')
  let g:neocomplcache_force_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.php =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.c =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.cpp =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
"
" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplcache_omni_patterns.perl =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

" NeoSnippet {{{1
" KEYMAP:
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
xmap <C-k> <Plug>(neosnippet_expand_target)
" スニペットの保存場所を変更
let g:neosnippet#snippets_directory = $MYVIMDIR . '/neosnippets'
" スニペットファイルの保存時に再読み込み
au myvimrc BufWritePost *.snip NeoSnippetSource %:p

" CtrlP {{{1
"
" KEYMAP:
"  C-f/C-b: モード切替（file<=>mru<=>buffer）
"  C-r: 正規表現モードのオン／オフ
" CtrlPTag
nnoremap <C-@> :<C-u>CtrlPTag<CR>
" CtrlPMRUFiles
nnoremap <C-o> :<C-u>CtrlPMRUFiles<CR>
" タブで開く
let g:ctrlp_prompt_mappings = {
\ 'AcceptSelection("t")': ['<CR>'],
\ 'AcceptSelection("e")': ['<C-@>'],
\ 'ToggleByFname()':      ['<C-t>', '<C-d>'],
\}
" CtrlP動作モード（'w'：ワークディレクトリ）
let g:ctrlp_working_path_mode = 'w'
" 新規ファイルをタブで開く
let g:ctrlp_open_new_file = 't'
" ウィンドウの設定
let g:ctrlp_match_window = 'max:20'
" キャッシュを使う
let g:ctrlp_use_caching = 1
let g:ctrlp_cache_dir = $HOME . '/.cache/ctrlp'
" キャッシュを終了後も残す（<F5>でキャッシュ更新）
let g:ctrlp_clear_cache_on_exit = 0
" 拡張機能を有効にする
let g:ctrlp_extensions = ['tag', 'dir', 'changes', 'bookmarkdir']
" コマンドエイリアス
command! -nargs=? -complete=dir Bookmark CtrlPBookmarkDirAdd <args>
" migemoを使って日本語正規表現検索
if executable('cmigemo')
  let g:ctrlp_use_migemo = 1
endif

" Ref {{{1
"
" COMMAND:
"  :Ref refe Array
let g:ref_use_vimproc = 1 " 0:disable / 1:enable
let g:ref_open = 'vsplit'
let g:ref_detect_filetype = {
\ 'ruby': 'refe',
\ 'ruby.rspec': 'refe',
\}
au myvimrc FileType ref call s:my_ref_mappings()
function! s:my_ref_mappings() "{{{
  nnoremap <buffer> ,] <Plug>(ref-keyword)
  nnoremap <buffer> ,[ <Plug>(ref-back)
  nnoremap <buffer> <C-h> <Plug>(ref-back)
  nnoremap <buffer> <C-l> <Plug>(ref-forward)
endfunction "}}}
" ref/refe
let g:ref_refe_version = 2
" ref/webdict
let g:ref_source_webdict_sites = {
\ 'default': 'weblio',
\ 'weblio': 'http://ejje.weblio.jp/content/%s',
\}
" ローカルファイルを参照するため、.local.vimrcに以下を宣言
" ref/javascript
" let g:ref_javascript_doc_path = './jsref/htdocs'
" ref/jquery
" let g:ref_jquery_doc_path = './jqapi'

" fugitive {{{1
" 説明 {{{
" DESC:
"  VimにGitコマンドを追加。
" COMMAND:
"  :Gstatus      : git status
"    Gstatusのバッファ上で
"      - : add/reset
"      D : diff
"      C : commit
"      cvc : commit -v
"  :Gwrite/:Gadd : git add
"  :Gdiff        : git diff
"  :Gcommit -v   : git commit -v
" }}}
command! Gs noh | Gstatus
command! Ga Gwrite
command! Gw Gwrite
command! Gd noh | Gdiff
command! Gc noh | Gcommit -v
command! Gca noh | Gcommit -va
command! Gl Glog
command! Gb Gblame
command! Gpush call s:my_git_vimproc('push')
command! Gpull call s:my_git_vimproc('pull')
" Gpush/Gpullのためのvimproc
function! s:my_git_vimproc(gitcommand) "{{{
  let command = 'git ' . a:gitcommand
  let sub = vimproc#popen2(command)
  let res = ''
  while !sub.stdout.eof
    let res .= sub.stdout.read()
    let res .= sub.stderr.read()
  endwhile
  let [cond, status] = sub.waitpid()
  if 0 != status
    echohl ErrorMsg
  endif
  for line in split(res, '\r\n\|\r\|\n')
    echomsg "[".command."] ".line
  endfor
  echohl None
endfunction "}}}

" QuickRun {{{1
"
" デフォルトの設定を見る場合、
" let g:quickrun#default_configを使う。
"
" COMMAND:
"  :QuickRun -args foo
" KEYMAP:
"  ,r : バッファの内容を実行
"
" <C-c> で実行を強制終了させる
" quickrun.vim が実行していない場合には <C-c> を呼び出す
nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
" 共通設定
"  実行にvimprocを使う
"  エラー時はquickfixに表示する
let g:quickrun_config = {}
let g:quickrun_config = {
\  "_": {
\    'runner': 'vimproc',
\    'runner/vimproc/updatetime': 100,
\    'outputter': 'error',
\    'outputter/error': 'quickfix',
\    'outputter/error/success': 'buffer',
\    'outputter/buffer/split': ':belowright 7',
\    'outputter/buffer/close_on_empty': 1
\  },
\}
" ruby.rspec
let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec' }
au myvimrc BufWinEnter,BufNewFile *_spec.rb set filetype=ruby.rspec
" htmlをブラウザで開く（tyru/open-browser.vim プラグインが必要）
let g:quickrun_config['html'] = {'command': 'open', 'exec': '%c %s', 'outputter': 'browser' }
let g:quickrun_config['xhtml'] = {'command': 'open', 'exec': '%c %s', 'outputter': 'browser' }
let g:quickrun_config['mkd'] = {'command': 'kramdown', 'outputter': 'browser'}
" javascript
let g:quickrun_config['javascript'] = {'command': 'node'}
let g:quickrun_config['jshint'] = {
\ 'command': 'jshint',
\ 'exec': '%c %s:p',
\ 'outputter': 'quickfix',
\ 'quickfix/errorformat': '%f: line %l\\,\ col %c\\, %m',
\ 'vimproc/sleep': 0,
\ 'hook/unite_quickfix/enable': 0,
\ 'hook/close_unite_quickfix/enable': 0,
\ 'hook/close_buffer/enable_exit': 1,
\ 'hook/u_nya_/enable': 0,
\}
au myvimrc BufWritePost *.js QuickRun jshint

" MiniBufExplorer {{{1
"
" 自動起動
let g:miniBufExplAutoStart = 0
" バッファが２つ以上で開く
" let g:miniBufExplBuffersNeeded = 2
" Diffモードでは隠す
let g:miniBufExplHideWhenDiff = 1
" バッファリストのサイクル化
let g:miniBufExplCycleArround = 1
" 表示行数を制限
let g:miniBufExplMaxSize = 1
" カラーリング
let g:did_minibufexplorer_syntax_inits = 1
" for buffers that have NOT CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveNormal ctermfg=black ctermbg=lightgray guifg=black guibg=lightgray
" for buffers that have CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveChanged ctermfg=black ctermbg=lightred guifg=black guibg=lightred
" buffers that have NOT CHANGED and are VISIBLE
hi MBEVisibleNormal cterm=bold ctermfg=white gui=bold guifg=white guibg=black
" buffers that have CHANGED and are VISIBLE
hi MBEVisibleChanged cterm=bold ctermfg=lightred gui=bold guifg=lightred guibg=black
" for buffers that have NOT CHANGED and are NOT VISIBLE.
hi MBENormal ctermfg=darkgray guifg=darkgray guibg=black
" for buffers that HAVE CHANGED and are NOT VISIBLE
hi MBEChanged ctermfg=red guifg=red guibg=black

" lightline {{{1
" let g:lightline.colorscheme = 'wombat'
"\  'colorscheme': 'wombat',
"\    'right': [['mode'], ['filename']]
let g:lightline = {
\  'mode_map': {'c': 'COMMAND'},
\  'active': {
\    'left': [['mode', 'paste'], ['filename', 'fugitive']],
\    'right': [['lineinfo'], ['percent'], ['pwd', 'fileformat', 'fileencoding', 'filetype']]
\  },
\  'inactive': {
\    'left': [],
\    'right': [['filename']]
\  },
\  'component_function': {
\    'modified': 'MyModified',
\    'readonly': 'MyReadonly',
\    'pwd': 'MyPwd',
\    'fugitive': 'MyFugitive',
\    'filename': 'MyFilename',
\    'fileformat': 'MyFileformat',
\    'filetype': 'MyFiletype',
\    'fileencoding': 'MyFileencoding',
\    'mode': 'MyMode'
\  }
\}

function! MyModified()
  "return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : ''
endfunction
function! MyReadonly()
  "return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '[RO]' : ''
endfunction
function! MyFilename()
  return (&ft == 'vimfiler' ? vimfiler#get_status_string() :
\         &ft == 'unite' ? unite#get_status_string() :
\         &ft == 'vimshell' ? vimshell#get_status_string() :
\         '' != expand('%:t') ? expand('%:t') : '[No Name]') .
\        ('' != MyModified() ? ' ' . MyModified() : '') .
\        ('' != MyReadonly() ? ' ' . MyReadonly() : '')
endfunction
function! MyPwd()
  return winwidth(0) > 100 ? getcwd() : ''
endfunction
function! MyFugitive()
  try
    if winwidth(0) > 80 && &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction
function! MyFileformat()
  return winwidth(0) > 80 ? &fileformat : ''
endfunction
function! MyFiletype()
  return winwidth(0) > 80 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction
function! MyFileencoding()
  return winwidth(0) > 80 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction
function! MyMode()
  return &ft == 'help' ? 'Help' :
\        &ft == 'minibufexpl' ? 'MBE' :
\        &ft == 'quickrun' ? 'QuickRun' :
\        &ft == 'qf' ? 'QuickFix' :
\        &ft == 'unite' ? 'Unite' :
\        &ft == 'vimshell' ? 'VimShell' :
\        winwidth(0) > 60 ? lightline#mode() : ''
endfunction

" Tagbar {{{1
let g:tagbar_auto_focus = 1
let g:tagbar_type_javascript = {'ctagsbin': '/opt/local/bin/jsctags'}

" surround {{{1
"
" KEYMAP:
"  i : inside
"  a : all
"  s : side
"  S' : ビジュアルモードで選択した範囲を'で囲む
"  ysiw' : カーソル下の単語を'で囲む
"  cs'" : 'を"に変換する
"  ds' : 'で囲まれた範囲を消す

" migemo-search {{{1
if executable('cmigemo')
  cnoremap <expr> <silent> <CR> getcmdtype() =~ '[/?]' ? migemosearch#replace_search_word() . "\<CR>zvzz" : "\<CR>"
endif

" Emmet {{{1
"
" KEYMAP:
"  <C-e> : 展開
"  <C-_> : コメントアウト／イン
"          （_と/が同じキーマップになってるのでCtrl+/でできる）
"let g:user_emmet_leader_key = '<C-e>'
let g:user_emmet_expandabbr_key = '<C-e>'
let g:user_emmet_togglecomment_key = '<C-_>'
" タグのコンプリート
let g:use_emmet_complete_tag = 1

" カスタマイズ設定
let g:user_emmet_settings = {
\  'lang': 'ja',
\  'indentation': "  ",
\  'html': {
\    'filters': 'html',
\    'snippets': {
\      'meta:viewport': "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">",
\      'css:bs': "<link href=\"css/bootstrap.min.css\" rel=\"stylesheet\">",
\      'cd': "<![CDATA[|]]>",
\      'js:jq': "<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n<script>\n\\$(function() {\n\t|\n})()\n</script>",
\      'js:bs': "<script src=\"https://code.jquery.com/jquery.js\"></script>\n<script src=\"js/bootstrap.min.js\"></script>",
\    },
\  },
\  'javascript': {
\    'snippets': {
\      'jq': "\\$(function() {\n\t\\${cursor}\\${child}\n});",
\      'jq:json': "\\$.getJSON(\"${cursor}\", function(data) {\n\t\\${child}\n});",
\      'jq:each': "\\$.each(data, function(index, item) {\n\t\\${child}\n});",
\      'fn': "(function() {\n\t\\${cursor}\n})();",
\      'tm': "setTimeout(function() {\n\t\\${cursor}\n}, 100);",
\    },
\    'use_pipe_for_cursor': 0,
\  },
\  'css': {
\    'filters': 'fc',
\    'snippets': {
\      'box-shadow': "-webkit-box-shadow: 0 0 0 # 000;\n-moz-box-shadow: 0 0 0 0 # 000;\nbox-shadow: 0 0 0 # 000;",
\    },
\  },
\  'vim': {
\    'snippets': {
\      'nn': 'nnoremap <silent> ${cursor} :<C-u>',
\      'nnu': 'nnoremap <silent> [unite]${cursor}<CR> :<C-u>Unite<Space>\n\\<Space>-no-empty<Space>-silent<Space>-buffer-name=<CR>',
\    },
\  },
\  'java': {
\    'snippets': {
\     'main': "public static void main(String[] args) {\n\t|\n}",
\     'println': "System.out.println(\"|\");",
\     'class': "public class | {\n}\n",
\    },
\  },
\  'php': {
\    'extends': 'html',
\    'filters': 'html,c',
\  },
\  'less': {
\    'filters': 'fc',
\    'extends': 'css',
\  },
\  'lorem_lipsum_ja': {
\    '^\%(lorem\|lipsum\)\(\d*\)$': function('emmet#lorem#ja#expand'),
\  },
\}

" rcodetools {{{1
"
" DESC: xmpfilterの呼び出し設定
" <F1>でバッファ全体にxmpfilterを実行
"{{{ xmpfilter mapping (disable)
"nmap <silent> <F1> mzggVG!xmpfilter -a<cr>'z
"imap <silent> <F1> <Esc><F1>
"" <F2>で現在行/選択行にxmpfilterを実行
"map <silent> <F2> !xmpfilter -a<cr>
"nmap <silent> <F2> V<F2>
"imap <silent> <F2> <Esc><F2>a
"" <F3>で現在行/選択行に「# =>」マークを追加
"vmap <silent> <F3> !xmpfilter -m<cr>
"nmap <silent> <F3> V<F3>
"imap <silent> <F3> <Esc><F3>a
"" <F4>で現在行/選択行の「# =>」マークを削除
"vmap <silent> <F4> ms:call RemoveRubyEval()<CR>
"nmap <silent> <F4> V<F4>
"imap <silent> <F4> <Esc><F4>a
"" RemoveRubyEval() の定義
"function! RemoveRubyEval() range
  "let begv = a:firstline
  "let endv = a:lastline
  "normal Hmt
  "set lz
  "execute ":" . begv . "," . endv . 's/\s*# \(=>\|!!\).*$//e'
  "normal 'tzt`s
  "set nolz
  "redraw
"endfunction
"" JRuby用<F11>でバッファ全体にjxmpfilterを実行
"nmap <silent> <F11> mzggVG!jxmpfilter -a<cr>'z
"imap <silent> <F11> <Esc><F11>
"}}}

" IndentGuides {{{1
" vim立ち上げたときに、自動的にIndentGuidesをオンにする
" let g:indent_guides_enable_on_vim_startup = 1
" ガイドをスタートするインデントの量
let g:indent_guides_start_level = 2
" 自動カラーを無効にする
let g:indent_guides_auto_colors = 0
" 奇数インデントのカラー
au myvimrc VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=#262626 ctermbg=gray
" 偶数インデントのカラー
au myvimrc VimEnter,Colorscheme * :hi IndentGuidesEven guibg=#3c3c3c ctermbg=darkgray
" ハイライト色の変化の幅
let g:indent_guides_color_change_percent = 30
" ガイドの幅
let g:indent_guides_guide_size = 1

" Syntastic {{{1
let g:syntastic_mode_map = {
\ 'mode': 'active',
\ 'passive_filetypes': ['html']
\}

" EasyMotion {{{1
" 大文字小文字を無視しない
let g:EasyMotion_smartcase = 1
" migemo検索
let g:EasyMotion_use_migemo = 1
" 使用する文字
let g:EasyMotion_keys = 'fdsajklghrewquiopvcxzmtybn/.;'
" JKモーションでカラム位置キープ
let g:EasyMotion_startofline = 0
" フォールディングを飛ばさない
let g:EasyMotion_skipfoldedline = 0
" KEYMAP:
nmap f <Plug>(easymotion-S)
vmap f <Plug>(easymotion-S)
omap f <Plug>(easymotion-S)
nmap F <Plug>(easymotion-s)
vmap F <Plug>(easymotion-s)
omap F <Plug>(easymotion-s)
au myvimrc FileType unite,vimfiler,gitcommit nmap <buffer> f <Plug>(easymotion-j)
au myvimrc FileType unite,vimfiler,gitcommit nmap <buffer> F <Plug>(easymotion-k)

"}}}1-------------------------------------------------------------------------

