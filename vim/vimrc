"-----------------------------------------------------------------------------
" 初期設定
"-----------------------------------------------------------------------------
" 初期設定 {{{1
" Last Change: 26-Dec-2013.
" VI互換モードOFF
set nocompatible
" 内部エンコーディングをutf-8に指定
set encoding=utf-8
" キー入力をタイムアウトさせない
set notimeout
set ttimeout
" 高速ターミナル接続を行う
set ttyfast
" 自動コマンドの初期化
augroup myvimrc
  au!
augroup END

" vundle {{{1
" 説明 {{{2
" COMMAND:
"  :BundleInstall : Bundleされたプラグインをインストール
"  :BundleSearch : vim-scriptにあるプラグインを検索
"
" vundle開始 {{{2
filetype off
if has("win32") || has("win64")
  set rtp&
  set rtp+=~/vimfiles/bundle/vundle
  call vundle#rc('~/vimfiles/bundle')
else
  set rtp&
  set rtp+=~/.vim/bundle/vundle
  call vundle#rc()
endif

" 基本 {{{2
Bundle 'gmarik/vundle'
Bundle 'Shougo/neocomplcache'
Bundle 'Shougo/neosnippet'
Bundle 'Shougo/neosnippet-snippets'
Bundle 'Shougo/vimproc'
Bundle 'Shougo/vimshell'

" Unite {{{2
Bundle 'Shougo/unite.vim'
Bundle 'Shougo/vimfiler'
Bundle 'Shougo/unite-outline'
Bundle 'ujihisa/unite-colorscheme'
Bundle 'ujihisa/unite-rake'
Bundle 'ujihisa/unite-gem'

" コマンド {{{2
Bundle 'thinca/vim-ref'
Bundle 'thinca/vim-quickrun'
Bundle 'thinca/vim-singleton'
Bundle 'thinca/vim-qfreplace'
Bundle 'tpope/vim-surround.git'
Bundle 'tpope/vim-fugitive'
Bundle 'gregsexton/gitv'
Bundle 'mattn/emmet-vim'

" Ruby {{{2
Bundle 'tpope/vim-rails.git'
Bundle 'taka84u9/vim-ref-ri'

" 表示 {{{2
Bundle 'itchyny/lightline.vim'
Bundle 'fholgado/minibufexpl.vim'
Bundle 'wombat256.vim'
Bundle 'molokai'
Bundle 'Zephyr-Color-Scheme'
Bundle 'ScrollColors'
Bundle 'CSApprox'

" 補助 {{{2
Bundle 'vim-jp/vimdoc-ja'
Bundle 'plasticboy/vim-markdown'
Bundle 'tyru/open-browser.vim'
Bundle 'kana/vim-smartchr'
Bundle 'tyru/caw.vim'
Bundle 'mattn/benchvimrc-vim'

" ローカルレポジトリ {{{2
if isdirectory($HOME . '/dev/github/unite-tiddlywiki/')
  Bundle 'file://' . $HOME . '/dev/github/unite-tiddlywiki/'
endif

" vundle終了 {{{2
filetype plugin indent on

" キーマップ定義 {{{2
nnoremap [bundle] <Nop>
nmap <Leader>b [bundle]
nnoremap <silent> [bundle]i<CR> :<C-u>BundleInstall<CR>
nnoremap <silent> [bundle]u<CR> :<C-u>BundleUpdate<CR>
nnoremap <silent> [bundle]s<CR> :<C-u>BundleSearch<CR>

" コマンド定義 {{{2
command! Bi :BundleInstall
command! Bu :BundleUpdate
command! -nargs=? Bs :BundleSearch <args>

" singleton.vim {{{1
if has('gui_running')
  call singleton#enable()
endif

" Kaoriya設定 {{{1
" サイトローカルな設定 {{{2
"
" サイトローカルな設定($VIM/vimrc_local.vim)があれば読み込む。読み込んだ後に
" 変数g:vimrc_local_finishに非0な値が設定されていた場合には、それ以上の設定
" ファイルの読込を中止する。
let g:vimrc_local_finish = 1
if 1 && filereadable($VIM . '/vimrc_local.vim')
  unlet! g:vimrc_local_finish
  source $VIM/vimrc_local.vim
  if exists('g:vimrc_local_finish') && g:vimrc_local_finish != 0
    finish
  endif
endif

" ユーザ優先設定 {{{2
"
" ユーザ優先設定($HOME/.vimrc_first.vim)があれば読み込む。読み込んだ後に変数
" g:vimrc_first_finishに非0な値が設定されていた場合には、それ以上の設定ファ
" イルの読込を中止する。
if 0 && exists('$HOME') && filereadable($HOME . '/.vimrc_first.vim')
  unlet! g:vimrc_first_finish
  source $HOME/.vimrc_first.vim
  if exists('g:vimrc_first_finish') && g:vimrc_first_finish != 0
    finish
  endif
endif

" 日本語対応のための設定 {{{2
"
" ファイルを読込む時にトライする文字エンコードの順序を確定する。漢字コード自
" 動判別機能を利用する場合には別途iconv.dllが必要。iconv.dllについては
" README_w32j.txtを参照。ユーティリティスクリプトを読み込むことで設定される。
if filereadable($VIMRUNTIME . '/encode_japan.vim')
  source $VIMRUNTIME/encode_japan.vim
endif
" メッセージを日本語にする (Windowsでは自動的に判断・設定されている)
if !(has('win32') || has('mac')) && has('multi_lang')
  if !exists('$LANG') || $LANG.'X' ==# 'X'
    if !exists('$LC_CTYPE') || $LC_CTYPE.'X' ==# 'X'
      language ctype ja_JP.eucJP
    endif
    if !exists('$LC_MESSAGES') || $LC_MESSAGES.'X' ==# 'X'
      language messages ja_JP.eucJP
    endif
  endif
endif
" MacOS Xメニューの日本語化 (メニュー表示前に行なう必要がある)
if has('mac')
  set langmenu=japanese
endif
" 日本語入力用のkeymapの設定例 (コメントアウト)
if has('keymap')
  " ローマ字仮名のkeymap
  "silent! set keymap=japanese
  "set iminsert=0 imsearch=0
endif
" 非GUI日本語コンソールを使っている場合の設定
if !has('gui_running') && &encoding != 'cp932' && &term == 'win32'
  set termencoding=cp932
endif

" vimrc_example.vim {{{2
"
" Bram氏の提供する設定例をインクルード (別ファイル:vimrc_example.vim)。これ
" 以前にg:no_vimrc_exampleに非0な値を設定しておけばインクルードはしない。
" let g:no_vimrc_example = 1
" if 1 && (!exists('g:no_vimrc_example') || g:no_vimrc_example == 0)
"   if &guioptions !~# "M"
"     " vimrc_example.vimを読み込む時はguioptionsにMフラグをつけて、syntax on
"     " やfiletype plugin onが引き起こすmenu.vimの読み込みを避ける。こうしない
"     " とencに対応するメニューファイルが読み込まれてしまい、これの後で読み込
"     " まれる.vimrcでencが設定された場合にその設定が反映されずメニューが文字
"     " 化けてしまう。
"     set guioptions+=M
"     source $VIMRUNTIME/vimrc_example.vim
"     set guioptions-=M
"   else
"     source $VIMRUNTIME/vimrc_example.vim
"   endif
" endif
" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
inoremap <C-U> <C-G>u<C-U>
" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
		  \ | wincmd p | diffthis
endif

" ファイル名に大文字小文字の区別がないシステム用の設定 {{{2
"   (例: DOS/Windows/MacOS)
"
if filereadable($VIM . '/vimrc') && filereadable($VIM . '/ViMrC')
  " tagsファイルの重複防止
  set tags=./tags,tags
endif

" コンソールでのカラー表示のための設定(暫定的にUNIX専用) {{{2
" if has('unix') && !has('gui_running')
"   let uname = system('uname')
"   if uname =~? "linux"
"     set term=builtin_linux
"   elseif uname =~? "freebsd"
"     set term=builtin_cons25
"   elseif uname =~? "Darwin"
"     set term=beos-ansi
"   else
"     set term=builtin_xterm
"   endif
"   unlet uname
" endif

" コンソール版で環境変数$DISPLAYが設定されていると起動が遅くなる件へ対応 {{{2
if !has('gui_running') && has('xterm_clipboard')
  set clipboard=exclude:cons\\\|linux\\\|cygwin\\\|rxvt\\\|screen
endif

" プラットホーム依存の特別な設定 {{{2
"
" WinではPATHに$VIMが含まれていないときにexeを見つけ出せないので修正
if has('win32') && $PATH !~? '\(^\|;\)' . escape($VIM, '\\') . '\(;\|$\)'
  let $PATH = $VIM . ';' . $PATH
endif

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" 基本設定
"-----------------------------------------------------------------------------
" 検索に関する設定 {{{1
" 検索時に大文字小文字を無視 (noignorecase:無視しない)
set ignorecase
" 大文字小文字の両方が含まれている場合は大文字小文字を区別
set smartcase
" インクリメンタルな検索
set incsearch
" 検索結果文字列のハイライトを有効にする
set hlsearch
" 検索時にファイルの最後まで行ったら最初に戻る (nowrapscan:戻らない)
set wrapscan
" タグ検索に二分検索をオフにする（vimdoc-jaフリーズ対策）
set notagbsearch
" 検索語が真ん中にくるようにする
"  zz はカレント行を画面の中心にする。つまり n で検索語にカーソル移動したら
"  勝手に zz でカレント行が画面の真ん中なるようにスクロールされるようになる。
noremap n nzz
noremap N Nzz
noremap * *zz
noremap # #zz
noremap g* g*zz
noremap g# g#zz
noremap { {zz
noremap } }zz

" 編集に関する設定 {{{1
" タブの画面上での幅
set tabstop=2
set shiftwidth=2
set softtabstop=2
" タブをスペースに展開する (noexpandtab:展開しない)
set expandtab
" 自動的にインデントする (noautoindent:インデントしない)
set autoindent
" 高度なオートインデント
set smartindent
" バックスペースでインデントや改行を削除できるようにする
set backspace=2
" 括弧入力時に対応する括弧を表示 (noshowmatch:表示しない)
set showmatch
" コマンドライン補完するときに強化されたものを使う(参照 :help wildmenu)
set wildmenu
" テキスト挿入中の自動折り返しを日本語に対応させる
set formatoptions&
set formatoptions+=mM
" コメント行で'o'で改行したらコメントをつけない
" ftpluginで上書きされてしまうためauでなんとかする
au myvimrc BufRead,BufNew,BufNewFile * set formatoptions-=o
" 文字数による自動折り返しはしない
set textwidth=0
" 区切り文字設定（単語の一部とする文字の設定）
"   Macではデフォルトの'iskeyword'がcp932に対応しきれていないので修正
"     @ : アルファベット
"     48-57 : 数字
"     128-167,224-235,192-255 : Extended ASCII characters（日本語には関係ない）
if has('mac')
  set iskeyword=@,48-57,_,128-167,224-235
  " '-'も単語の一部と認識させる
  set iskeyword+=-
else
  " '-'も単語の一部と認識させる
  set iskeyword&
  set iskeyword+=-
endif
" 日本語整形スクリプト(by. 西岡拓洋さん)用の設定
let format_allow_over_tw = 1	" ぶら下り可能幅
" 編集後保存していなくても別のファイルを開く
set hidden
" コマンドライン履歴
set history=50
" 外部のエディタで編集中のファイルが変更されたら自動で読み直す
" （ウィンドウを移動する度に変更をチェックする）
set autoread
au myvimrc WinEnter * checktime
autocmd myvimrc QuickFixCmdPost [^l]* nested cwindow
autocmd myvimrc QuickFixCmdPost    l* nested lwindow

" 画面表示の設定 {{{1
" シンタックスハイライト
syntax on
" カラースキーマ設定
set t_Co=256
if has('gui_running')
  colorscheme wombat256mod
else
  "let g:molokai_original = 1
  let g:rehash256 = 1
  colorscheme molokai
endif
" 遅延描画
set lazyredraw
" 行番号を非表示 (number:表示)
set nonumber
" ルーラーを表示 (noruler:非表示)
set ruler
" タイトルを表示
set title
" 終了後のウィンドウタイトル
set titleold=vim
" タブや改行を表示 (nolist:非表示)
set list
" どの文字でタブや改行を表示するかを設定
"set listchars=tab:>-,extends:<,trail:-,eol:<
set listchars=tab:>-,extends:<,trail:-
" タブの左側にカーソル表示
"set listchars=tab:\ \
" 全角スペースも表示　
highlight JpSpace cterm=underline ctermfg=darkgrey gui=underline guifg=darkgrey
au myvimrc BufRead,BufNew * match JpSpace /　/
" □や○の文字があってもカーソル位置をずらさせない
set ambiwidth=double
" 画面最後の行を出来る限り表示する
set display&
set display+=lastline
" modelineを無視する
"set nomodeline
" フォールディング方式の指定（マーカー使用）(=fdm)
set foldmethod=marker
" 長い行を折り返して表示 (nowrap:折り返さない)
set wrap
" コマンドラインの高さ (Windows用gvim使用時はgvimrcを編集すること)
set cmdheight=1
" コマンドをステータス行に表示
set showcmd
" 常にステータス行を表示 (詳細は:he laststatus)
set laststatus=2
" ステータスラインに文字コードと改行文字とファイルタイプを表示する
"set statusline=%<%f\%m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%l,%c
"set statusline=%<%t\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']['.&ft.']'}%=%l,%c%V%8P
" タブは非表示
set showtabline=0
" 前回終了したカーソル行に移動して真ん中にする（フォールディングがあれば開く）
au myvimrc BufRead * call s:my_readpost_autocmd()
function! s:my_readpost_autocmd()
  if line("'\"") > 0 && line("'\"") <= line("$")
    exe "normal! g`\"zz"
  endif
  if &foldenable > 0 && foldclosed("'\"") > 0
    exe "normal! zA"
  endif
  exe "normal! zz"
endfunction
" vsplitは右に開く
set splitright
" 画面サイズが広い場合はバッファを右に移動させる
" Todo: Unite開くと低くなる
"au myvimrc BufRead,BufNew,BufNewFile * if winwidth(0) > 140 | wincmd L | wincmd _ | endif

" GUI固有の画面表示の設定 {{{1
if has('gui_running')
  set guioptions&
  " メニューファイルが存在しない場合、menu.vimを読み込まない
  if !filereadable($VIMRUNTIME . '/menu.vim')
    set guioptions+=M
  endif
  " ビジュアル選択を自動的にクリップボードへ
  "set guioptions+=a
  " スクロールバーを非表示にする
  set guioptions-=r
  set guioptions-=R
  set guioptions-=l
  set guioptions-=L
  " フォントを指定
  set guifont=Ricty_Diminished:h12:cSHIFTJIS
  " 背景色暗色（colorschemeの後に設定すること）
  set background=dark
  " ウィンドウサイズを最大化する
  au GUIEnter * simalt ~x
  " ヤンクでクリップボードを共有する
  if has('clipboard')
    set clipboard=unnamed
  endif
  " マウスを有効にする
  if has('mouse')
    set mouse=a
  endif
  " IME制御をオフにする
  set iminsert=0
  set imsearch=0
  set noimcmdline
  " バッファがローカルバッファに表示されなくなった場合は削除する
  " （[No Name]バッファへの対策）
  set bufhidden=wipe
  " Todo: Alt+CとAlt+Pでコピペする
  "noremap <M-c> :simalt ec
  "noremap <M-p> :simalt ep
endif

" ファイル操作に関する設定 {{{1
" バックアップファイルを作成しない
set nobackup
set nowritebackup
" スワップファイルの作成ディレクトリにパスを追加
set directory&
set directory+=,~/tmp,$TMP
" ファイルを開くと、そのファイルと同じディレクトリに移動
" 名無しのvim使い <http://nanasi.jp/articles/vim/cd_vim.html>
au myvimrc BufEnter .* if expand("%:p:h") != '' | execute ":lcd \"" . expand("%:p:h") . "\"" | endif
"set autochdir （設定するとVimShellが動かなくなる）
" vimrcの保存時に再読み込み
if !has('gui_running') && !(has('win32') || has('win64'))
    au myvimrc BufWritePost *vimrc nested source $MYVIMRC
else
    au myvimrc BufWritePost *vimrc source $MYVIMRC |
      \ if has('gui_running') && filereadable($MYGVIMRC) | source $MYGVIMRC
    au myvimrc BufWritePost *gvimrc if has('gui_running') | source $MYGVIMRC
endif

" ファイルタイプ別の設定 {{{1
" Ruby
au myvimrc FileType ruby setlocal fenc=utf8 ff=unix
" Git commit log
au BufRead COMMIT_EDITMSG setlocal nofoldenable
"git-vimで対応するためコメントアウト
"au BufRead COMMIT_EDITMSG set ft=diff fenc=utf8 ff=unix
"git commit -v で対応するためコメントアウト
"au BufRead COMMIT_EDITMSG DiffGitCached
" Vim
if 'vim' == &ft
  setlocal iskeyword+=:
  setlocal iskeyword-=#
else
  au myvimrc FileType vim setlocal iskeyword+=:
  au myvimrc FileType vim setlocal iskeyword-=#
endif
" JavaSciprt
au myvimrc BufRead,BufNew,BufNewFile *.json setlocal filetype=javascript
" Apache
au myvimrc BufRead,BufNew,BufNewFile httpd*.conf setlocal filetype=apache
" Todo: vimdiff
"au myvimrc BufRead,BufNew,BufNewFile * if 1 == &diff | nnoremap <buffer> dk [c | nnoremap <buffer> dj ]c | endif
" テンプレート設定
"augroup SkeletonAu
  "au!
  "au BufNewFile *.html 0r $HOME/.vim/skel/skel.html
  "au BufNewFile *_spec.rb 0r $HOME/.vim/skel/skel_spec.rb
"augroup END

" コマンド定義 {{{1
"
" COMMAND:
" VimDiff
command! -complete=file -nargs=1 VimDiff :vertical diffsplit <args>
" Erc、Sorc
command! Erc :e $MYVIMRC
command! Sorc :source $MYVIMRC
" Grep
command! -complete=file -nargs=+ Grep :call GrepFunction(<f-args>)
function! GrepFunction(keyword, target)
  "Unite grep<CR>a:target<CR>a:keyword<CR>
  "<C-u>Unite<Space>grep: <Space>-buffer-name=grep<CR>
endfunction
" H(elp)
command! -nargs=* -complete=help H if winwidth(0) > 140 | :vertical help <args> | :vertical resize 79 | else | :help <args> | endif
" Vimdoc
command! Vimdoc :OpenBrowser http://vim-jp.org/vimdoc-ja/
" SyntaxInfo
command! SyntaxInfo :call s:get_syn_info()
function! s:get_syn_id(transparent) "{{{
  let synid = synID(line("."), col("."), 1)
  if a:transparent
    return synIDtrans(synid)
  else
    return synid
  endif
endfunction
function! s:get_syn_attr(synid)
  let name = synIDattr(a:synid, "name")
  let ctermfg = synIDattr(a:synid, "fg", "cterm")
  let ctermbg = synIDattr(a:synid, "bg", "cterm")
  let guifg = synIDattr(a:synid, "fg", "gui")
  let guibg = synIDattr(a:synid, "bg", "gui")
  return {
        \ "name": name,
        \ "ctermfg": ctermfg,
        \ "ctermbg": ctermbg,
        \ "guifg": guifg,
        \ "guibg": guibg}
endfunction
function! s:get_syn_info()
  let baseSyn = s:get_syn_attr(s:get_syn_id(0))
  echo "name: " . baseSyn.name .
        \ " ctermfg: " . baseSyn.ctermfg .
        \ " ctermbg: " . baseSyn.ctermbg .
        \ " guifg: " . baseSyn.guifg .
        \ " guibg: " . baseSyn.guibg
  let linkedSyn = s:get_syn_attr(s:get_syn_id(1))
  echo "link to"
  echo "name: " . linkedSyn.name .
        \ " ctermfg: " . linkedSyn.ctermfg .
        \ " ctermbg: " . linkedSyn.ctermbg .
        \ " guifg: " . linkedSyn.guifg .
        \ " guibg: " . linkedSyn.guibg
endfunction "}}}
" Colortest
command! Colortest :belowright vsplit $VIMRUNTIME/syntax/colortest.vim | source $VIMRUNTIME/syntax/colortest.vim

" キーマップ定義 {{{1
" map系はリンク先のコマンドを再帰的に展開する。
" noremap系はリンク先のコマンドを再帰的に展開しない。
" 基本的にはnoremap系を使用する。
"   カーソル移動 => noremap
"   範囲選択     => vnoremap & onoremap
"     ビジュアルモードだけでセレクトモードを除くならxnoremp
"   テキスト入力補助 => inoremap
"   機能呼び出し => cnoremap
" <Nop>をリンク先に指定することでキーマップを無効にする。
" KEYMAP:
" バッファ移動用キーマップ
nnoremap H <Esc>:MBEbp<CR>
nnoremap L <Esc>:MBEbn<CR>
" 表示行単位で行移動
nnoremap j gj
nnoremap k gk
xnoremap j gj
xnoremap k gk
" 行末までヤンク
nnoremap Y y$
" ウィンドウサイズ変更
nnoremap + <C-w>+
nnoremap - <C-w>-
nnoremap _ <C-w>_
" すべてのフォールディングの開け閉め
nnoremap zO zR
nnoremap zC zM
" \で空白を入れない
inoremap \ \

" ジャンプ元に戻る
nnoremap <Leader><C-]> <C-t>
" コマンドモード時、現在のバッファのファイル名を出力
cnoremap <C-f> <C-r>%
" コマンドモード時、コマンド行頭に移動
cnoremap <C-a> <C-b>
" カーソルの下の単語でヘルプを引く
au myvimrc FileType vim nnoremap <buffer> <C-h> :<C-u>H<Space><C-r><C-w><CR>
au myvimrc FileType vim vnoremap <buffer> <C-h> y:<C-u>H<Space><C-r>"<CR>
au myvimrc FileType ruby nnoremap <buffer> <C-h> :<C-u>Ref<Space>refe<Space><C-r><C-w><CR>

" Leaderキーを設定（,のデフォルトの機能は\で使えるように退避）
"  u: Unite, b: Vundle, g: Fugitive
"  p: PasteToggle, r: Quickrun, f: VimFiler, s: VimShell, /: CommentToggle
"  <C-]>: TagJumpBack
let mapleader=","
noremap \ ,
" set paste/nopasteを切り替え
set pastetoggle=<Leader>p

" 誤操作防止
" 保存して閉じる
nnoremap ZZ <Nop>
" 保存せずに閉じる
nnoremap ZQ <Nop>
" EXモードに入る
noremap Q <Nop>

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" Plugin設定
"-----------------------------------------------------------------------------
" neocomplecache.vim {{{1
"
" KEYMAP:
"  <Tab> : 補完
"
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
"
" Enable heavy features.
" Use camel case completion.
"let g:neocomplcache_enable_camel_case_completion = 1
" Use underbar completion.
"let g:neocomplcache_enable_underbar_completion = 1
"
" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
\  'default' : '',
\  'vimshell' : $HOME.'/.vimshell_hist',
\  'scheme' : $HOME.'/.gosh_completions'
\}
"
" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
  let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
"
" Plugin key-mappings.
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()
"
" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplcache#smart_close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
"inoremap <expr><C-e>  neocomplcache#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"
"
" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplcache_enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplcache_enable_insert_char_pre = 1
"
" AutoComplPop like behavior.
"let g:neocomplcache_enable_auto_select = 1
"
" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplcache_enable_auto_select = 1
"let g:neocomplcache_disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"
"
" Enable omni completion.
au myvimrc FileType css setlocal omnifunc=csscomplete#CompleteCSS
au myvimrc FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
au myvimrc FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
au myvimrc FileType python setlocal omnifunc=pythoncomplete#Complete
au myvimrc FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"
" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
if !exists('g:neocomplcache_force_omni_patterns')
  let g:neocomplcache_force_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.php =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.c =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.cpp =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
"
" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplcache_omni_patterns.perl =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

" neosnippet.vim {{{1
" KEYMAP:
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
xmap <C-k> <Plug>(neosnippet_expand_target)
" スニペットの保存場所を変更
let g:neosnippet#snippets_directory = '~/.vim/neosnippets'
" スニペットファイルの保存時に再読み込み
au myvimrc BufWritePost *.snip NeoSnippetSource %:p
" COMMAND:
command! -nargs=* Esnip :NeoSnippetEdit <args>

" emmet.vim {{{1
"
" KEYMAP:
"  <C-e> : 展開
"  <C-_> : コメントアウト／イン
"          （_と/が同じキーマップになってるのでCtrl+/でできる）
"let g:user_emmet_leader_key = '<C-e>'
let g:user_emmet_expandabbr_key = '<C-e>'
let g:user_emmet_togglecomment_key = '<C-_>'
" タグのコンプリート
let g:use_emmet_complete_tag = 1

" カスタマイズ設定
let g:user_emmet_settings = {
\  'lang' : 'ja',
\  'indentation' : "  ",
\  'html' : {
\    'filters' : 'html',
\    'snippets' : {
\      'meta:viewport' : "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">",
\      'css:bs' : "<link href=\"css/bootstrap.min.css\" rel=\"stylesheet\">",
\      'cd' : "<![CDATA[|]]>",
\      'js:jq' : "<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n<script>\n\\$(function() {\n\t|\n})()\n</script>",
\      'js:bs' : "<script src=\"https://code.jquery.com/jquery.js\"></script>\n<script src=\"js/bootstrap.min.js\"></script>",
\    },
\  },
\  'javascript' : {
\    'snippets' : {
\      'jq' : "\\$(function() {\n\t\\${cursor}\\${child}\n});",
\      'jq:json' : "\\$.getJSON(\"${cursor}\", function(data) {\n\t\\${child}\n});",
\      'jq:each' : "\\$.each(data, function(index, item) {\n\t\\${child}\n});",
\      'fn' : "(function() {\n\t\\${cursor}\n})();",
\      'tm' : "setTimeout(function() {\n\t\\${cursor}\n}, 100);",
\    },
\    'use_pipe_for_cursor' : 0,
\  },
\  'css' : {
\    'filters' : 'fc',
\    'snippets' : {
\      'box-shadow' : "-webkit-box-shadow: 0 0 0 # 000;\n-moz-box-shadow: 0 0 0 0 # 000;\nbox-shadow: 0 0 0 # 000;",
\    },
\  },
\  'vim' : {
\    'snippets' : {
\      'nn' : 'nnoremap <silent> ${cursor} :<C-u>',
\      'nnu' : 'nnoremap <silent> [unite]${cursor}<CR> :<C-u>Unite<Space>\n\\<Space>-no-empty<Space>-silent<Space>-buffer-name=<CR>',
\    },
\  },
\  'java' : {
\    'snippets' : {
\     'main': "public static void main(String[] args) {\n\t|\n}",
\     'println': "System.out.println(\"|\");",
\     'class': "public class | {\n}\n",
\    },
\  },
\  'php' : {
\    'extends' : 'html',
\    'filters' : 'html,c',
\  },
\  'less' : {
\    'filters' : 'fc',
\    'extends' : 'css',
\  },
\  'lorem_lipsum_ja' : {
\    '^\%(lorem\|lipsum\)\(\d*\)$' : function('emmet#lorem#ja#expand'),
\  },
\}

" quickrun.vim {{{1
"
" COMMAND:
"  :QuickRun -args foo
" KEYMAP:
"  <Leader>r : バッファの内容を実行
"
" 実行にvimprocを使う
" エラー時はquickfixに表示する
let g:quickrun_config = {}
let g:quickrun_config = {
\  "_" : {
\    'runner' : 'vimproc',
\    'outputter' : 'error',
\    'outputter/error' : 'quickfix',
\    'outputter/error/success' : 'buffer',
\    'outputter/buffer/split' : ':belowright 5',
\    'outputter/buffer/close_on_empty' : 1
\  },
\}
" <C-c> で実行を強制終了させる
" quickrun.vim が実行していない場合には <C-c> を呼び出す
nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
" ruby.rspec
let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec' }
augroup RSpec
  au!
  au BufWinEnter,BufNewFile *_spec.rb set filetype=ruby.rspec
augroup END
" htmlをブラウザで開く（tyru/open-browser.vim プラグインが必要）
let g:quickrun_config['html'] = { 'command' : 'open', 'exec' : '%c %s', 'outputter': 'browser' }
let g:quickrun_config['xhtml'] = { 'command' : 'open', 'exec' : '%c %s', 'outputter': 'browser' }

" fugitive.vim {{{1
"
" DESC:
"  VimにGitコマンドを追加。
" COMMAND:
"  :Gstatus      : git status
"    Gstatusのバッファ上で
"      - : add/reset
"      D : diff
"      C : commit
"      cvc : commit -v
"  :Gwrite/:Gadd : git add
"  :Gdiff        : git diff
"  :Gcommit -v   : git commit -v
" KEYMAP:
nnoremap [git] <Nop>
nmap <Leader>g [git]
nnoremap <silent> [git]s :<C-u>Gstatus<CR>
nnoremap <silent> [git]a :<C-u>Gwrite<CR>
nnoremap <silent> [git]d :<C-u>Gdiff<CR>
nnoremap <silent> [git]c :<C-u>Gcommit -v<CR>
nnoremap <silent> [git]l :<C-u>Glog<CR>
" COMMAND:
command! Gs :Gstatus
command! Ga :Gwrite
command! Gw :Gwrite
command! Gd :Gdiff
command! Gc :Gcommit -v
command! Gca :Gcommit -va
command! Gl :Glog
command! Gb :Gblame
command! Gpush :Git push
command! Gpull :Git pull

" surround.vim {{{1
"
" KEYMAP:
"  i : inside
"  a : all
"  s : side
"  S' : ビジュアルモードで選択した範囲を'で囲む
"  ysiw' : カーソル下の単語を'で囲む
"  cs'" : 'を"に変換する
"  ds' : 'で囲まれた範囲を消す

" rcodetools.vim {{{1
"
" DESC: xmpfilterの呼び出し設定
" <F1>でバッファ全体にxmpfilterを実行
"{{{ xmpfilter mapping (disable)
"nmap <silent> <F1> mzggVG!xmpfilter -a<cr>'z
"imap <silent> <F1> <Esc><F1>
"" <F2>で現在行/選択行にxmpfilterを実行
"map <silent> <F2> !xmpfilter -a<cr>
"nmap <silent> <F2> V<F2>
"imap <silent> <F2> <Esc><F2>a
"" <F3>で現在行/選択行に「# =>」マークを追加
"vmap <silent> <F3> !xmpfilter -m<cr>
"nmap <silent> <F3> V<F3>
"imap <silent> <F3> <Esc><F3>a
"" <F4>で現在行/選択行の「# =>」マークを削除
"vmap <silent> <F4> ms:call RemoveRubyEval()<CR>
"nmap <silent> <F4> V<F4>
"imap <silent> <F4> <Esc><F4>a
"" RemoveRubyEval() の定義
"function! RemoveRubyEval() range
  "let begv = a:firstline
  "let endv = a:lastline
  "normal Hmt
  "set lz
  "execute ":" . begv . "," . endv . 's/\s*# \(=>\|!!\).*$//e'
  "normal 'tzt`s
  "set nolz
  "redraw
"endfunction
"" JRuby用<F11>でバッファ全体にjxmpfilterを実行
"nmap <silent> <F11> mzggVG!jxmpfilter -a<cr>'z
"imap <silent> <F11> <Esc><F11>
"}}}

" MiniBufExplorer {{{1
"
" 自動起動
let g:miniBufExplAutoStart = 1
" バッファが２つ以上で開く
let g:miniBufExplBuffersNeeded = 2
" Diffモードでは隠す
let g:miniBufExplHideWhenDiff = 1
" バッファリストのサイクル化
let g:miniBufExplCycleArround = 1
" 表示行数を制限
let g:miniBufExplMaxSize = 1
" カラーリング
let g:did_minibufexplorer_syntax_inits = 1
" for buffers that have NOT CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveNormal ctermfg=black ctermbg=lightgray guifg=black guibg=lightgray
" for buffers that have CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveChanged ctermfg=black ctermbg=lightred guifg=black guibg=lightred
" buffers that have NOT CHANGED and are VISIBLE
hi MBEVisibleNormal cterm=bold ctermfg=white gui=bold guifg=white guibg=black
" buffers that have CHANGED and are VISIBLE
hi MBEVisibleChanged cterm=bold ctermfg=lightred gui=bold guifg=lightred guibg=black
" for buffers that have NOT CHANGED and are NOT VISIBLE.
hi MBENormal ctermfg=darkgray guifg=darkgray guibg=black
" for buffers that HAVE CHANGED and are NOT VISIBLE
hi MBEChanged ctermfg=red guifg=red guibg=black

" lightline.vim {{{1
"
" lightline config
"\  'colorscheme': 'wombat',
"\    'right': [['mode'], ['filename']]
let g:lightline = {
\  'mode_map': {'c': 'NORMAL'},
\  'active': {
\    'left': [['mode', 'paste'], ['filename', 'fugitive']]
\  },
\  'inactive': {
\    'left': [],
\    'right': [['filename']]
\  },
\  'component_function': {
\    'modified': 'MyModified',
\    'readonly': 'MyReadonly',
\    'fugitive': 'MyFugitive',
\    'filename': 'MyFilename',
\    'fileformat': 'MyFileformat',
\    'filetype': 'MyFiletype',
\    'fileencoding': 'MyFileencoding',
\    'mode': 'MyMode'
\  }
\}

function! MyModified()
  "return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : ''
endfunction
function! MyReadonly()
  "return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '[RO]' : ''
endfunction
function! MyFilename()
  return (&ft == 'vimfiler' ? vimfiler#get_status_string() :
\         &ft == 'unite' ? unite#get_status_string() :
\         &ft == 'vimshell' ? vimshell#get_status_string() :
\         '' != expand('%:t') ? expand('%:t') : '[No Name]') .
\        ('' != MyModified() ? ' ' . MyModified() : '') .
\        ('' != MyReadonly() ? ' ' . MyReadonly() : '')
endfunction
function! MyFugitive()
  try
    if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction
function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction
function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction
function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction
function! MyMode()
  return &ft == 'help' ? 'Help' :
\        &ft == 'minibufexpl' ? 'MBE' :
\        &ft == 'quickrun' ? 'QuickRun' :
\        &ft == 'qf' ? 'QuickFix' :
\        &ft == 'unite' ? 'Unite' :
\        &ft == 'vimfiler' ? 'VimFiler' :
\        &ft == 'vimshell' ? 'VimShell' :
\        winwidth(0) > 60 ? lightline#mode() : ''
endfunction

" ref.vim {{{1
"
" COMMAND:
"  :Ref refe Array
" KEYMAP:
"  Shift-K : 単語を検索
let g:ref_use_vimproc = 1 " 0:disable / 1:enable
let g:ref_refe_version = 2

" caw.vim {{{1
"
" コメントアウトの切り替え
nmap <Leader>/ <Plug>(caw:I:toggle)
vmap <Leader>/ <Plug>(caw:I:toggle)

" VimShell {{{1
"
" 動的プロンプト
let g:vimshell_prompt_expr = 'getcwd()." > "'
let g:vimshell_prompt_pattern = '^\f\+ > '
" KEYMAP:
" VimShellを起動
nnoremap <Leader>s :<C-u>VimShellPop<CR>
" irbを非同期で起動
nnoremap <silent> <Leader>irb :<C-u>VimShellInteractive irb<CR>
" 非同期で開いたインタプリタに現在の行を評価させる
au FileType vimshell inoremap <buffer> <Leader>s :<C-u>VimShellSendString<CR>
au FileType vimshell vmap <buffer> <Leader>s :<C-u>VimShellSendString<CR>

" VimFiler {{{1
"
" KEYMAP:
"  h : up dir, l : down dir, t : tree view (1 dir), T : tree view all
"  e : edit, <Space> : mark, c : copy, m : move, d : delete, yy : yank path
"  N : new file, K : new dir, * : mark all, U : mark off all, ? : keymap
"  a : action, H : VimShell, ge : system filer, x : system app
"
" vimデフォルトのエクスプローラをvimfilerで置き換える
let g:vimfiler_as_default_explorer = 1
" セーフモードを無効にした状態で起動する
let g:vimfiler_safe_mode_by_default = 0
" デフォルトでIDE風のFilerを開く
"au myvimrc VimEnter * VimFiler -split -simple -winwidth=30 -no-quit
" ステータスラインを上書きしない（lightline向け）
let g:vimfiler_force_overwrite_statusline = 0
"let g:netrw_liststyle=3
" KEYMAP:
nnoremap <Leader>f :<C-u>VimFilerBufferDir
\<Space>-buffer-name=vimfiler<Space>-split<Space>-simple<Space>-winwidth=30<Space>-quit<CR>
" Enterでツリー開閉、ファイル編集を可能に
au FileType vimfiler nmap <buffer> <expr> <Cr> vimfiler#smart_cursor_map("\<Plug>(vimfiler_expand_tree)", "\<Plug>(vimfiler_edit_file)")

" Unite {{{1
" 説明 {{{2
" COMMAND:
"  :Unite ${source} [${option}]
"  :Unite output:{コマンド名}
" KEYMAP:
"  <Tab> : Actionを開く
"  <Space> : 候補を選択する
"  * : 候補を全選択する
"  a : 候補でActionを開く
"  ? : Uniteのキーマップを表示
"
" 基本設定 {{{2
" 入力モードで開始
"let g:unite_enable_start_insert=1
" ヤンク履歴を使用可能にする
let g:unite_source_history_yank_enable = 1
" 最近使ったファイルの履歴数
let g:unite_source_file_mru_file = 200
" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
" ステータスラインを上書きしない（lightline向け）
let g:unite_force_overwrite_statusline = 0
" ESCキーを2回押すと終了する
au myvimrc FileType unite nnoremap <silent> <buffer> <Esc><Esc> :q<CR>
"au myvimrc FileType unite inoremap <silent> <buffer> <Esc><Esc> <Esc>:q<CR>
" unite grep に ag(The Silver Searcher) を使う
if executable('ag')
 let g:unite_source_grep_command = 'ag'
 let g:unite_source_grep_default_opts =
 \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
 \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
 let g:unite_source_grep_recursive_opt = ''
endif

" デフォルトアクションの変更 {{{2
" ref/refe
call unite#custom_default_action('source/ref/refe/*' , 'above')
" Uniteブックマークがディレクトリの場合はVimFilerで開く
call unite#custom_default_action('source/bookmark/directory' , 'vimfiler')
call unite#custom_default_action('directory' , 'vimfiler')

" アクションの追加 {{{2
" source:mappingにaction:verboseを追加する
let s:action = {
\ 'description' : 'verbose',
\ 'is_selectable' : 1,
\}
function! s:action.func(candidates)
  for candidate in a:candidates
    execute "verbose map" substitute(candidate.action__mapping, '\\\(<.*>\)', '\1', "g")
  endfor
endfunction
" kind ではなくて source の mapping に対して action を設定する
call unite#custom#action('source/mapping/*', 'verbose', s:action)
" preview（pキー）で action を実行したい場合は
" call unite#custom#action('source/mapping/*', 'preview', s:action)
unlet s:action

" メニュー設定 {{{2
let g:unite_source_menu_menus = {
\ "shortcuts" : {
\   "description" : "command shortcuts.",
\   "command_candidates" : [
\     ["unite-colorscheme", "Unite colorscheme -auto-preview"],
\     ["unite-output:message", "Unite output:message"],
\     ["unite-mapping(all)", "Unite output:map|map!|lmap"],
\   ],
\ },
\}

" Uniteキーマップ定義 {{{2
" KEYMAP:
nnoremap [unite] <Nop>
nmap <Leader>u [unite]
" ファイラ
nnoremap <silent> [unite]f<CR> :<C-u>Unite<Space>file
\<Space>-no-empty<Space>-silent<Space>-buffer-name=file<CR>
" 最近使ったファイルの一覧
nnoremap <silent> [unite]fm<CR> :<C-u>Unite<Space>file_mru
\<Space>-no-empty<Space>-silent<Space>-buffer-name=file_mru<CR>
" コマンド一覧を表示
nnoremap <silent> [unite]s<CR> :<C-u>Unite<Space>source
\<Space>-no-empty<Space>-silent<Space>-buffer-name=source<CR>

" 現在のバッファ内をグレップ
nnoremap <silent> [unite]g<CR> :<C-u>Unite<Space>grep:<C-R>%
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep<CR>
nnoremap <silent> [unite]gb<CR> :<C-u>Unite<Space>grep:<C-R>%
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep<CR>
" ディレクトリをグレップ
nnoremap <silent> [unite]gd<CR> :<C-u>Unite<Space>grep
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep-dir<CR>
" カーソル上の単語で現在のバッファをグレップ
nnoremap <silent> [unite]gw<CR> :<C-u>Unite<Space>grep:<C-R>%
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep-word<CR><C-R><C-W><CR>
" すべてのバッファをグレップ
nnoremap <silent> [unite]ga<CR> :<C-u>Unite<Space>grep:$buffers
\<Space>-no-empty<Space>-silent<Space>-buffer-name=grep-all-bufs<CR>

" ブックマーク（追加は:UniteBookmarkAdd）
nnoremap <silent> [unite]b<CR> :<C-u>Unite<Space>bookmark
\<Space>-no-empty<Space>-silent<Space>-buffer-name=bookmark<CR>
" Todo: 'Todo:'をつけた行をファイル保存時に自動でブックマークするau
nnoremap <silent> [unite]bt<CR> :<C-u>Unite<Space>bookmark:todos
\<Space>-no-empty<Space>-silent<Space>-buffer-name=bookmark:todos<CR>
" ブックマーク手動編集
nnoremap <silent> [unite]be<CR> :<C-u>edit $HOME/.unite/bookmark/default<CR>
" メニュー
nnoremap <silent> [unite]m<CR> :<C-u>Unite<Space>menu:shortcuts
\<Space>-no-empty<Space>-silent<Space>-buffer-name=menu:shortcuts<CR>

" リファレンス参照
" refe
nnoremap <silent> [unite]rr<CR> :<C-u>Unite<Space>ref/refe
\<Space>-no-empty<Space>-silent<Space>-buffer-name=ref/refe<CR>
" カーソル下の単語でrefe
nnoremap <silent> [unite]rrw<CR> :<C-u>Unite<Space>ref/refe
\<Space>-input=<C-r><C-w>
\<Space>-no-empty<Space>-silent<Space>-buffer-name=ref/refe<CR>
" ri
nnoremap <silent> [unite]rri<CR> :<C-u>Unite<Space>ref/ri
\<Space>-no-empty<Space>-silent<Space>-buffer-name=ref/ri<CR>

" ヤンクヒストリ
nnoremap <silent> [unite]y<CR> :<C-u>Unite<Space>history/yank
\<Space>-no-empty<Space>-silent<Space>-buffer-name=history/yank<CR>
" 直前のUniteコマンドの結果に戻る
nnoremap <silent> [unite]r<CR> :<C-u>UniteResume
\<Space>-no-empty<Space>-silent<CR>
" Uniteコマンドの履歴表示
nnoremap <silent> [unite]rl :<C-u>Unite<Space>resume
\<Space>-no-empty<Space>-silent<Space>-buffer-name=resume<CR>

" Uniteコマンド定義 {{{2
" ファイラ
command! Uf :Unite file
\ -no-empty -silent -buffer-name=file
" 最近使ったファイルの一覧
command! Ufm :Unite file_mru
\ -no-empty -silent -buffer-name=file_mru
" コマンド一覧を表示
command! Us :Unite source
\ -no-empty -silent -buffer-name=source

" 現在のバッファ内をグレップ
command! Ug :Unite grep:%
\ -no-empty -silent -buffer-name=grep
command! Ugb :Unite grep:%
\ -no-empty -silent -buffer-name=grep
" ディレクトリをグレップ
command! Ugd :Unite grep
\ -no-empty -silent -buffer-name=grep-dir
" カーソル上の単語で現在のバッファをグレップ
command! Ugw :Unite grep:%
\ -no-empty -silent -buffer-name=grep-word -input=<C-r><C-w>
" すべてのバッファをグレップ
command! Uga :Unite grep:$buffers
\ -no-empty -silent -buffer-name=grep-all-bufs

" ブックマーク（追加はUniteBookmarkAdd）
command! Ub :Unite bookmark
\ -no-empty -silent -buffer-name=bookmark
" Todo 'Todo:'をつけた行をファイル保存時に自動でブックマークするau
command! Ubt :Unite bookmark:todos
\ -no-empty -silent -buffer-name=bookmarktodos
" ブックマーク手動編集
command! Ube :edit $HOME/.unite/bookmark/default
" メニュー
command! Um :Unite menu:shortcuts
\ -no-empty -silent -buffer-name=menushortcuts

" リファレンス参照
" refe
command! Urr :Unite ref/refe
\ -no-empty -silent -buffer-name=ref/refe
" カーソル下の単語でrefe
command! Urrw :Unite ref/refe
\ -no-empty -silent -buffer-name=ref/refe -input=<C-r><C-w>
" ri
command! Urri :Unite ref/ri
\ -no-empty -silent -buffer-name=ref/ri

" ヤンクヒストリ
command! Uy :Unite history/yank
\ -no-empty -silent -buffer-name=history/yank
" 直前のUniteコマンドの結果に戻る
command! Ur :UniteResume
\ -no-empty -silent
" Uniteコマンドの履歴表示
command! Url :Unite resume
\ -no-empty -silent -buffer-name=resume

" Unite source サンプル {{{2
let s:unite_source = {
\   'name': 'lines',
\ }
function! s:unite_source.gather_candidates(args, context)
  let path = expand('%:p')
  let lines = getbufline('%', 1, '$')
  let format = '%' . strlen(len(lines)) . 'd: %s'
  return map(lines, '{
  \   "word": printf(format, v:key + 1, v:val),
  \   "source": "lines",
  \   "kind": "jump_list",
  \   "action__path": path,
  \   "action__line": v:key + 1,
  \ }')
endfunction
call unite#define_source(s:unite_source)
unlet s:unite_source

" markdown.vim {{{1
"let g:quickrun_config['mkd'] { 'outputter' : 'browser' }

"}}}1-------------------------------------------------------------------------

