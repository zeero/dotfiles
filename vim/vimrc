"-----------------------------------------------------------------------------
" 初期設定
"-----------------------------------------------------------------------------
" 初期設定 {{{1
" Last Change: 22-Jan-2014.
" VI互換モードOFF
set nocompatible
" 内部エンコーディングをutf-8に指定
set encoding=utf-8
" キー入力をタイムアウトさせない
set notimeout
set ttimeout
" 高速ターミナル接続を行う
set ttyfast
" 自動コマンドの初期化
augroup myvimrc
  au!
augroup END
" vimディレクトリ変数
let $MYVIMDIR = '~/.vim'
if !isdirectory($MYVIMDIR) && isdirectory($HOME . '/vimfiles')
  let $MYVIMDIR = '~/vimfiles'
endif

" NeoBundle {{{1
" 説明 {{{2
" COMMAND:
"  :NeoBundleInstall : Bundleされたプラグインをインストール
"  :NeoBundleSearch : vim-scriptにあるプラグインを検索
"
" NeoBundle開始 {{{2
filetype off
set rtp+=$MYVIMDIR/bundle/neobundle.vim
call neobundle#rc(expand($MYVIMDIR . '/bundle'))

" 基本 {{{2
NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundle 'Shougo/vimproc'
\, {'build': {
\    'windows': 'make -f make_mingw32.mak',
\    'cygwin': 'make -f make_cygwin.mak',
\    'mac': 'make -f make_mac.mak',
\    'unix': 'make -f make_unix.mak',
\  }}
NeoBundleLazy 'Shougo/vimshell'
\, {'autoload': {'commands': ['VimShell', 'VimShellPop']}
\,  'depends': 'Shougo/vimproc'}
NeoBundleLazy 'Shougo/neocomplcache'
\, {'autoload': {'insert': 1}}
NeoBundleLazy 'Shougo/neosnippet'
\, {'autoload': {'insert': 1
\,               'commands': ['NeoSnippetEdit']
\,               'unite_source': ['neosnippet']
\,               'filetypes': ['neosnippet']}}
NeoBundleLazy 'Shougo/neosnippet-snippets'
\, {'autoload': {'insert': 1}}
NeoBundle 'kien/ctrlp.vim'

" Unite {{{2
NeoBundleLazy 'Shougo/unite.vim'
\, {'autoload': {'commands': ['Unite', 'UniteWithBufferDir']}}
NeoBundleLazy 'Shougo/vimfiler'
\, {'autoload': {'commands': ['VimFiler', 'VimFilerBufferDir']}
\,  'depends': ['Shougo/unite.vim']}
NeoBundleLazy 'Shougo/unite-outline'
\, {'autoload': {'unite_sources': ['outline']}}
NeoBundleLazy 'tsukkee/unite-help'
\, {'autoload': {'unite_sources': ['help']}}
NeoBundleLazy 'tsukkee/unite-tag'
\, {'autoload': {'unite_sources': ['tag']}}
NeoBundleLazy 'basyura/unite-rails'
\, {'autoload': {'unite_sources': ['rails']}}
NeoBundleLazy 'ujihisa/unite-rake'
\, {'autoload': {'unite_sources': ['rake']}}
NeoBundleLazy 'ujihisa/unite-gem'
\, {'autoload': {'unite_sources': ['gem']}}
NeoBundleLazy 'ujihisa/unite-locate'
\, {'autoload': {'unite_sources': ['locate']}}
NeoBundleLazy 'ujihisa/unite-colorscheme'
\, {'autoload': {'unite_sources': ['colorscheme']}}
NeoBundleLazy 'tacroe/unite-alias'
\, {'autoload': {'unite_sources': ['alias']}}
NeoBundleLazy 'mattn/unite-gist'
\, {'autoload': {'unite_sources': ['gist']}
\,  'depends': ['mattn/webapi-vim', 'mattn/gist-vim']}

" 入力補助 {{{2
NeoBundle 'thinca/vim-qfreplace'
NeoBundle 'tpope/vim-surround.git'
NeoBundle 'tyru/caw.vim'
NeoBundleLazy 'kana/vim-smartchr'
\, {'autoload': {'insert': 1}}
NeoBundleLazy 'mattn/emmet-vim'
\, {'autoload': {'filetypes': ['html']}}

" コマンド {{{2
NeoBundle 'tpope/vim-fugitive'
\, {'augroup': 'fugitive'}
NeoBundle 'mattn/webapi-vim'
NeoBundle 'mattn/gist-vim'
NeoBundleLazy 'gregsexton/gitv'
\, {'autoload': {'commands': ['Gitv']}
\,  'depends': ['tpope/vim-fugitive']}
NeoBundle 'thinca/vim-ref'
NeoBundle 'thinca/vim-quickrun'
NeoBundle 'scrooloose/syntastic'
NeoBundleLazy 'thinca/vim-prettyprint'
\, {'autoload': {'commands': ['PP']}}
NeoBundle 'szw/vim-tags'
NeoBundleLazy 'majutsushi/tagbar'
\, {'autoload': {'commands': ['TagbarToggle']}}
NeoBundleLazy 'wesleyche/SrcExpl'
\, {'autoload': {'commands': ['SrcExplToggle']}}

" Ruby {{{2
NeoBundleLazy 'tpope/vim-rails.git'
\, {'autoload': {'filetypes': ['ruby']}}
NeoBundleLazy 'taka84u9/vim-ref-ri'
\, {'autoload': {'filetypes': ['ruby']
\,               'unite_sources': ['refe/ri']}
\,  'depends': 'thinca/vim-ref'}
NeoBundle 'edsono/vim-matchit'
NeoBundleLazy 'ruby-matchit'
\, {'autoload': {'filetypes': ['ruby']}
\,  'depends': ['edsono/vim-matchit']}

" JavaScript {{{2
NeoBundleLazy 'jiangmiao/simple-javascript-indenter'
\, {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'jelera/vim-javascript-syntax'
\, {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'jQuery'
\, {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'https://bitbucket.org/teramako/jscomplete-vim.git'
\, {'autoload': {'filetypes': ['javascript']}
\,  'type': 'git'}
NeoBundle 'mojako/ref-sources.vim'
\, {'autoload': {'filetypes': ['javascript']
\,               'unite_sources': ['ref/javascript', 'ref/jquery']}}

" 表示 {{{2
NeoBundle 'itchyny/lightline.vim'
NeoBundle 'fholgado/minibufexpl.vim'
\, {'augroup': 'MiniBufExpl'}
NeoBundle 'wombat256.vim'
NeoBundle 'molokai'
NeoBundle 'Zephyr-Color-Scheme'
NeoBundle 'CSApprox'
NeoBundleLazy 'ScrollColors'
\, {'autoload': {'commands': ['SCROLLCOLOR']}}

" 補助 {{{2
NeoBundle 'thinca/vim-singleton'
NeoBundle 'thinca/vim-localrc'
NeoBundleLazy 'vim-jp/vimdoc-ja'
\, {'autoload': {'commands': ['help']}}
NeoBundleLazy 'plasticboy/vim-markdown'
\, {'autoload': {'filetypes': ['mkd']}}
NeoBundleLazy 'tyru/open-browser.vim'
\, {'autoload': {'filetypes': ['html', 'mkd']}}
NeoBundleLazy 'mattn/benchvimrc-vim'
\, {'autoload': {'commands': ['BenchVimrc']}}
NeoBundle 'haya14busa/vim-migemo'
NeoBundle 'rhysd/migemo-search.vim'

" ローカルレポジトリ {{{2
if isdirectory($HOME . '/dev/github/unite-tiddlywiki/')
  NeoBundleLocal '~/dev/github/unite-tiddlywiki/'
endif

" NeoBundle終了 {{{2
filetype plugin indent on
" インストールチェック
NeoBundleCheck

" NeoBundleコマンド定義 {{{2
command! Bi :NeoBundleInstall
command! Bu :NeoBundleUpdate
command! -nargs=? Bs :NeoBundleSearch <args>
command! Bc :NeoBundleClean
command! Bl :NeoBundleList

" singleton.vim {{{1
if has('gui_running')
  let g:singleton#opener = 'tab drop'
  call singleton#enable()
endif

" Kaoriya設定 {{{1
" サイトローカルな設定 {{{2
"
" サイトローカルな設定($VIM/vimrc_local.vim)があれば読み込む。読み込んだ後に
" 変数g:vimrc_local_finishに非0な値が設定されていた場合には、それ以上の設定
" ファイルの読込を中止する。
let g:vimrc_local_finish = 1
if 1 && filereadable($VIM . '/vimrc_local.vim')
  unlet! g:vimrc_local_finish
  source $VIM/vimrc_local.vim
  if exists('g:vimrc_local_finish') && g:vimrc_local_finish != 0
    finish
  endif
endif

" ユーザ優先設定 {{{2
"
" ユーザ優先設定($HOME/.vimrc_first.vim)があれば読み込む。読み込んだ後に変数
" g:vimrc_first_finishに非0な値が設定されていた場合には、それ以上の設定ファ
" イルの読込を中止する。
if 0 && exists('$HOME') && filereadable($HOME . '/.vimrc_first.vim')
  unlet! g:vimrc_first_finish
  source $HOME/.vimrc_first.vim
  if exists('g:vimrc_first_finish') && g:vimrc_first_finish != 0
    finish
  endif
endif

" 日本語対応のための設定 {{{2
"
" ファイルを読込む時にトライする文字エンコードの順序を確定する。漢字コード自
" 動判別機能を利用する場合には別途iconv.dllが必要。iconv.dllについては
" README_w32j.txtを参照。ユーティリティスクリプトを読み込むことで設定される。
if filereadable($VIMRUNTIME . '/encode_japan.vim')
  source $VIMRUNTIME/encode_japan.vim
endif
" メッセージを日本語にする (Windowsでは自動的に判断・設定されている)
if !(has('win32') || has('mac')) && has('multi_lang')
  if !exists('$LANG') || $LANG.'X' ==# 'X'
    if !exists('$LC_CTYPE') || $LC_CTYPE.'X' ==# 'X'
      language ctype ja_JP.eucJP
    endif
    if !exists('$LC_MESSAGES') || $LC_MESSAGES.'X' ==# 'X'
      language messages ja_JP.eucJP
    endif
  endif
endif
" MacOS Xメニューの日本語化 (メニュー表示前に行なう必要がある)
if has('mac')
  set langmenu=japanese
endif
" 日本語入力用のkeymapの設定例 (コメントアウト)
if has('keymap')
  " ローマ字仮名のkeymap
  "silent! set keymap=japanese
  "set iminsert=0 imsearch=0
endif
" 非GUI日本語コンソールを使っている場合の設定
if !has('gui_running') && &encoding != 'cp932' && &term == 'win32'
  set termencoding=cp932
endif

" vimrc_example.vim {{{2
"
" Bram氏の提供する設定例をインクルード (別ファイル:vimrc_example.vim)。これ
" 以前にg:no_vimrc_exampleに非0な値を設定しておけばインクルードはしない。
" let g:no_vimrc_example = 1
" if 1 && (!exists('g:no_vimrc_example') || g:no_vimrc_example == 0)
"   if &guioptions !~# "M"
"     " vimrc_example.vimを読み込む時はguioptionsにMフラグをつけて、syntax on
"     " やfiletype plugin onが引き起こすmenu.vimの読み込みを避ける。こうしない
"     " とencに対応するメニューファイルが読み込まれてしまい、これの後で読み込
"     " まれる.vimrcでencが設定された場合にその設定が反映されずメニューが文字
"     " 化けてしまう。
"     set guioptions+=M
"     source $VIMRUNTIME/vimrc_example.vim
"     set guioptions-=M
"   else
"     source $VIMRUNTIME/vimrc_example.vim
"   endif
" endif
" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
inoremap <C-U> <C-G>u<C-U>
" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
		  \ | wincmd p | diffthis
endif

" ファイル名に大文字小文字の区別がないシステム用の設定 {{{2
"   (例: DOS/Windows/MacOS)
"
if filereadable($VIM . '/vimrc') && filereadable($VIM . '/ViMrC')
  " tagsファイルの重複防止
  set tags=./tags,tags
endif

" コンソールでのカラー表示のための設定(暫定的にUNIX専用) {{{2
" if has('unix') && !has('gui_running')
"   let uname = system('uname')
"   if uname =~? "linux"
"     set term=builtin_linux
"   elseif uname =~? "freebsd"
"     set term=builtin_cons25
"   elseif uname =~? "Darwin"
"     set term=beos-ansi
"   else
"     set term=builtin_xterm
"   endif
"   unlet uname
" endif

" コンソール版で環境変数$DISPLAYが設定されていると起動が遅くなる件へ対応 {{{2
if !has('gui_running') && has('xterm_clipboard')
  set clipboard=exclude:cons\\\|linux\\\|cygwin\\\|rxvt\\\|screen
endif

" プラットホーム依存の特別な設定 {{{2
"
" WinではPATHに$VIMが含まれていないときにexeを見つけ出せないので修正
if has('win32') && $PATH !~? '\(^\|;\)' . escape($VIM, '\\') . '\(;\|$\)'
  let $PATH = $VIM . ';' . $PATH
endif

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" 基本設定
"-----------------------------------------------------------------------------
" 検索に関する設定 {{{1
" 検索時に大文字小文字を無視 (noignorecase:無視しない)
set ignorecase
" 大文字小文字の両方が含まれている場合は大文字小文字を区別
set smartcase
" インクリメンタルな検索
set incsearch
" 検索結果文字列のハイライトを有効にする
set hlsearch
" 検索時にファイルの最後まで行ったら最初に戻る (nowrapscan:戻らない)
set wrapscan
" タグ検索パスの設定
au myvimrc FileType * exe "setlocal tags+=" . $HOME . "/.tags/" . &ft . ".tags"
" タグ検索に二分検索をオフにする（vimdoc-jaフリーズ対策）
set notagbsearch
" バックスラッシュやクエスチョンを状況に合わせ自動的にエスケープ
cnoremap <expr> / getcmdtype() == '/' ? '\/' : '/'
cnoremap <expr> ? getcmdtype() == '?' ? '\?' : '?'
" 検索語が真ん中にくるようにする
"  zz はカレント行を画面の中心にする。つまり n で検索語にカーソル移動したら
"  勝手に zz でカレント行が画面の真ん中なるようにスクロールされるようになる。
noremap n nzz
noremap N Nzz
noremap * *zz
noremap # #zz
noremap g* g*zz
noremap g# g#zz
noremap { {zz
noremap } }zz

" 編集に関する設定 {{{1
" タブの画面上での幅
set tabstop=2
set shiftwidth=2
set softtabstop=2
" タブをスペースに展開する (noexpandtab:展開しない)
set expandtab
" 自動的にインデントする (noautoindent:インデントしない)
set autoindent
" 高度なオートインデント
set smartindent
" '<'や'>'でインデントする際に'shiftwidth'の倍数に丸める
set shiftround
" バックスペースでインデントや改行を削除できるようにする
set backspace=2
" 括弧入力時に対応する括弧を表示 (noshowmatch:表示しない)
set showmatch
" 対応括弧のハイライト表示の秒数
set matchtime=3
" 対応括弧に'<'と'>'のペアを追加
set matchpairs& matchpairs+=<:>
" コマンドライン補完するときに強化されたものを使う
set wildmenu
set wildmode=list:longest,full
" テキスト挿入中の自動折り返しを日本語に対応させる
set formatoptions&
set formatoptions+=mM
" コメント行で'o'で改行したらコメントをつけない
" ftpluginで上書きされてしまうためauでなんとかする
au myvimrc BufRead,BufNew,BufNewFile * set formatoptions-=o
" 文字数による自動折り返しはしない
set textwidth=0
" 区切り文字設定（単語の一部とする文字の設定）
"   Macではデフォルトの'iskeyword'がcp932に対応しきれていないので修正
"     @ : アルファベット
"     48-57 : 数字
"     128-167,224-235,192-255 : Extended ASCII characters（日本語には関係ない）
if has('mac')
  set iskeyword=@,48-57,_,128-167,224-235
  " '-'も単語の一部と認識させる
  set iskeyword+=-
else
  " '-'も単語の一部と認識させる
  set iskeyword&
  set iskeyword+=-
endif
" 日本語整形スクリプト(by. 西岡拓洋さん)用の設定
let format_allow_over_tw = 1	" ぶら下り可能幅
" 編集後保存していなくても別のファイルを開く
" set hidden
" 新しく開く代わりにすでに開いてあるバッファを開く
set switchbuf=useopen
" コマンドライン履歴
set history=50
" 外部のエディタで編集中のファイルが変更されたら自動で読み直す
" （ウィンドウを移動する度に変更をチェックする）
set autoread
au myvimrc WinEnter * checktime
" クイックフィックスは常にcwindowで表示する
autocmd myvimrc QuickFixCmdPost [^l]* nested cwindow
autocmd myvimrc QuickFixCmdPost    l* nested lwindow
" 補完時に大文字小文字を区別しない
set infercase
" カーソルを文字が存在しない部分でも動けるようにする
" set virtualedit=all

" 画面表示の設定 {{{1
" シンタックスハイライト
syntax on
" カラースキーマ設定
set t_Co=256
if has('gui_running')
  colorscheme wombat256mod
else
  "let g:molokai_original = 1
  let g:rehash256 = 1
  colorscheme molokai
endif
" 遅延描画
" set lazyredraw
" 行番号を表示 (nonumber:表示)
set number
" ルーラーを表示 (noruler:非表示)
set ruler
" タイトルを表示
set title
" 終了後のウィンドウタイトル
set titleold=vim
" タブや改行を表示 (nolist:非表示)
set list
" どの文字でタブや改行を表示するかを設定
set listchars=tab:»-,trail:-,extends:»,precedes:«,nbsp:%
" タブの左側にカーソル表示
"set listchars=tab:\ \
" 全角スペースも表示　
highlight JpSpace cterm=underline ctermfg=darkgrey gui=underline guifg=darkgrey
au myvimrc BufRead,BufNew * match JpSpace /　/
" □や○の文字があってもカーソル位置をずらさせない
set ambiwidth=double
" 画面最後の行を出来る限り表示する
set display&
set display+=lastline
" modelineを無視する
"set nomodeline
" フォールディング方式の指定（マーカー使用）(=fdm)
set foldmethod=marker
" 長い行を折り返して表示 (nowrap:折り返さない)
set wrap
" コマンドラインの高さ (Windows用gvim使用時はgvimrcを編集すること)
set cmdheight=1
" コマンドをステータス行に表示
set showcmd
" 常にステータス行を表示 (詳細は:he laststatus)
set laststatus=2
" ステータスラインに文字コードと改行文字とファイルタイプを表示する
"set statusline=%<%f\%m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%l,%c
"set statusline=%<%t\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']['.&ft.']'}%=%l,%c%V%8P
" タブは非表示
"set showtabline=0
" 前回終了したカーソル行に移動して真ん中にする（フォールディングがあれば開く）
au myvimrc BufRead * call s:my_readpost_autocmd()
function! s:my_readpost_autocmd()
  if line("'\"") > 0 && line("'\"") <= line("$")
    exe "normal! g`\"zz"
  endif
  while &foldenable > 0 && foldclosed("'\"") > 0
    exe "normal! zo"
  endwhile
  exe "normal! zz"
endfunction
" vsplitは右に開く
set splitright
" 画面サイズが広い場合はバッファを右に移動させる
" Todo: Unite開くと低くなる
"au myvimrc BufRead,BufNew,BufNewFile * if winwidth(0) > 140 | wincmd L | wincmd _ | endif

" GUI固有の画面表示の設定 {{{1
if has('gui_running')
  set guioptions&
  " メニューファイルが存在しない場合、menu.vimを読み込まない
  if !filereadable($VIMRUNTIME . '/menu.vim')
    set guioptions+=M
  endif
  " ビジュアル選択を自動的にクリップボードへ
  "set guioptions+=a
  " スクロールバーを非表示にする
  set guioptions-=r
  set guioptions-=R
  set guioptions-=l
  set guioptions-=L
  " フォントを指定
  set guifont=Ricty_Diminished:h12:cSHIFTJIS
  " 背景色暗色（colorschemeの後に設定すること）
  set background=dark
  " ウィンドウサイズを最大化する
  au myvimrc GUIEnter * simalt ~x
  " ヤンクでクリップボードを共有する
  "if has('clipboard')
  "  set clipboard=unnamed
  "endif
  " マウスを有効にする
  if has('mouse')
    set mouse=a
  endif
  " IME制御をオフにする
  set iminsert=0
  set imsearch=0
  set noimcmdline
  " Alt+CとAlt+Pでコピペする
  vnoremap <M-c> "+y
  imap <expr> <M-v> '<C-o>"+gP'
  cnoremap <M-v> <C-r><C-o>*
  " バッファがローカルバッファに表示されなくなった場合は削除する
  " （[No Name]バッファへの対策）
  set bufhidden=wipe
  " タブのラベル
  set guitablabel=%n:%t
endif

" ファイル操作に関する設定 {{{1
" バックアップファイル、swapファイルを作成しない
set nobackup
set nowritebackup
set noswapfile
" スワップファイルの作成ディレクトリにパスを追加
" set directory&
" set directory+=,~/tmp,$TMP
" ファイルを開くと、そのファイルと同じディレクトリに移動
" 名無しのvim使い <http://nanasi.jp/articles/vim/cd_vim.html>
au myvimrc BufRead .* if expand("%:p:h") != '' | exe ":lcd " . expand("%:p:h") | endif
"set autochdir （設定するとVimShellが動かなくなる）
" vimrcの保存時に再読み込み
if !has('gui_running') && !(has('win32') || has('win64'))
    au myvimrc BufWritePost *vimrc nested source $MYVIMRC
else
    au myvimrc BufWritePost *vimrc nested source $MYVIMRC |
      \ if has('gui_running') && filereadable($MYGVIMRC) | source $MYGVIMRC
    au myvimrc BufWritePost *gvimrc if has('gui_running') | source $MYGVIMRC
endif

" ファイルタイプ別の設定 {{{1
" Ruby
au myvimrc FileType ruby setlocal fenc=utf8 ff=unix
" Git commit log
" Todo: @@でマーカーつけて、ジャンプ
au myvimrc FileType gitcommit
\ setlocal nofoldenable |
\ wincmd L |
\ let @/ = "^@@ .*"
" Vim
" バックスラッシュのインデントを無くす
let g:vim_indent_cont = 0
" vimrcでは:もiskに入れる
if expand("%") =~ "vimrc"
  setlocal iskeyword+=:
endif
" JavaSciprt
au myvimrc BufRead,BufNew,BufNewFile *.json setlocal ft=javascript
au myvimrc BufRead,BufNew,BufNewFile jquery.*.js setlocal ft=javascript syntax=jquery
" Apache
au myvimrc BufRead,BufNew,BufNewFile httpd*.conf setlocal ft=apache
" ctags
au myvimrc BufRead,BufNew,BufNewFile *.tags setlocal ft=tags

" コマンド定義 {{{1
"
" COMMAND:
" VimDiff
command! -complete=file -nargs=1 VimDiff :vertical diffsplit <args>
" Erc、Sorc
command! Erc :e $MYVIMRC
command! Sorc :source $MYVIMRC
" H(elp)
command! -nargs=? -complete=help H if winwidth(0) > 140 | :vertical help <args> | :vertical resize 79 | else | :help <args> | endif
" Vimdoc
command! VimDoc :OpenBrowser http://vim-jp.org/vimdoc-ja/
" SyntaxInfo
command! SyntaxInfo :call s:get_syn_info()
function! s:get_syn_id(transparent) "{{{
  let synid = synID(line("."), col("."), 1)
  if a:transparent
    return synIDtrans(synid)
  else
    return synid
  endif
endfunction
function! s:get_syn_attr(synid)
  let name = synIDattr(a:synid, "name")
  let ctermfg = synIDattr(a:synid, "fg", "cterm")
  let ctermbg = synIDattr(a:synid, "bg", "cterm")
  let guifg = synIDattr(a:synid, "fg", "gui")
  let guibg = synIDattr(a:synid, "bg", "gui")
  return {
        \ "name": name,
        \ "ctermfg": ctermfg,
        \ "ctermbg": ctermbg,
        \ "guifg": guifg,
        \ "guibg": guibg}
endfunction
function! s:get_syn_info()
  let baseSyn = s:get_syn_attr(s:get_syn_id(0))
  echo "name: " . baseSyn.name .
        \ " ctermfg: " . baseSyn.ctermfg .
        \ " ctermbg: " . baseSyn.ctermbg .
        \ " guifg: " . baseSyn.guifg .
        \ " guibg: " . baseSyn.guibg
  let linkedSyn = s:get_syn_attr(s:get_syn_id(1))
  echo "link to"
  echo "name: " . linkedSyn.name .
        \ " ctermfg: " . linkedSyn.ctermfg .
        \ " ctermbg: " . linkedSyn.ctermbg .
        \ " guifg: " . linkedSyn.guifg .
        \ " guibg: " . linkedSyn.guibg
endfunction "}}}
" Colortest
command! Colortest :belowright vsplit $VIMRUNTIME/syntax/colortest.vim | source $VIMRUNTIME/syntax/colortest.vim
" Hitest
command! Hitest :belowright vsplit $VIMRUNTIME/syntax/hitest.vim | source $VIMRUNTIME/syntax/hitest.vim
" Bdo
command! Bdo call s:my_bd_other()
function! s:my_bd_other() "{{{
  let i = 1
  let cur = bufnr("%")
  while i <= bufnr("$")
    if bufloaded(i) && i != cur
      exe "bdelete" i
    endif
    let i = i + 1
  endwhile
endfunction "}}}
" Esnip
command! -nargs=? -complete=customlist,neosnippet#commands#_edit_complete Esnip :NeoSnippetEdit <args>
" Lcd
command! Lcd :exe "lcd " . expand("%:p:h")

" キーマップ定義 {{{1
" 説明 {{{2
" map系はリンク先のコマンドを再帰的に展開する。
" noremap系はリンク先のコマンドを再帰的に展開しない。
" 基本的にはnoremap系を使用する。
"   カーソル移動 => noremap
"   範囲選択     => vnoremap & onoremap
"     ビジュアルモードだけでセレクトモードを除くならxnoremp
"   テキスト入力補助 => inoremap
"   機能呼び出し => cnoremap
" <Nop>をリンク先に指定することでキーマップを無効にする。
" KEYMAP:
" 基本 {{{2
" バッファ移動用キーマップ
nnoremap H <Esc>:MBEbp<CR>
nnoremap L <Esc>:MBEbn<CR>
" 表示行単位で行移動
nnoremap j gj
nnoremap k gk
xnoremap j gj
xnoremap k gk
" 行末までヤンク
nnoremap Y y$
" すべてのフォールディングの開け閉め
nnoremap zO zR
nnoremap zC zM
" diffハンクへのジャンプ
au myvimrc BufRead * nnoremap <buffer> [[ [czz
au myvimrc BUfRead * nnoremap <buffer> ]] ]czz
" Help、QuickFix、Fugitiveでは<Esc><Esc>でバッファを閉じる
au myvimrc FileType help,qf,gitcommit nnoremap <buffer> <Esc><Esc> <C-w>c
" タブページ操作
nnoremap <Tab> <C-PageDown>
nnoremap <S-Tab> <C-PageUp>
nnoremap ,<Tab> :<C-u>tabnew<CR>
" ESCを二回でハイライトを消す
nnoremap <silent> <Esc><Esc> :noh<CR>

" CTRLキー、Shiftキー {{{2
" ウィンドウ間を移動
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
" ウィンドウサイズ変更
nnoremap <S-Up> <C-w>+
nnoremap <S-Down> <C-w>-
nnoremap <S-Left> <C-w><
nnoremap <S-Right> <C-w>>
nnoremap _ <C-w>_
" コマンドモード時、現在のバッファのファイル名を出力
cnoremap <C-f> <C-r>%
" コマンドモード時、コマンド行頭に移動
cnoremap <C-a> <C-b>

" リーダーキー {{{2
" ,をリーダーキーにする（衝突を避けるためにmapleaderは設定しない）
"  h: H(elp), [,]: TagJump, p: PasteToggle, /: CommentToggle, r: Quickrun
"  f: VimFiler, s: VimShell, m:MBEToggle, l: TagbarToggle, ,: SrcExplToggle
" カーソルの下の単語でヘルプを引く
au myvimrc FileType vim nnoremap <buffer> ,h :<C-u>H<Space><C-r><C-w><CR>
au myvimrc FileType vim vnoremap <buffer> ,h y:<C-u>H<Space><C-r>"<CR>
au myvimrc FileType ruby nnoremap <buffer> ,h :<C-u>Ref<Space>refe<Space><C-r><C-w><CR>
" タグジャンプ
nnoremap <C-]> g<C-]>
nnoremap ,] g<C-]>
nnoremap ,[ <C-t>
nnoremap <Down> g<C-]>
nnoremap <Up> <C-t>
nnoremap <Left> <C-o>
nnoremap <Right> <C-i>
vnoremap <C-]> g<C-]>
vnoremap ,] g<C-]>
vnoremap <Down> g<C-]>
" PASTEモードの切り替え
set pastetoggle=,p
" コメントアウトの切り替え（caw.vim）
nmap ,/ <Plug>(caw:I:toggle)
vmap ,/ <Plug>(caw:I:toggle)
" QuickRun
nmap ,r <Plug>(quickrun)
" VimFiler
nnoremap ,f :<C-u>VimFilerBufferDir
\<Space>-buffer-name=vimfiler<Space>-split<Space>-simple<Space>-winwidth=30<Space>-quit<CR>
" VimShell
nnoremap ,s :<C-u>set noautochdir<CR>:<C-u>VimShellPop<CR>
" MBEToggle
nnoremap ,m :<C-u>MBEToggle<CR>
" TagbarToggle
nnoremap ,l :<C-u>TagbarToggle<CR>
" SrcExplToggle
nnoremap ,, :<C-u>SrcExplToggle<CR>

" 無効化 {{{2
" 保存して閉じる
nnoremap ZZ <Nop>
" 保存せずに閉じる
nnoremap ZQ <Nop>
" EXモードに入る
nnoremap Q <Nop>
" コマンドライン履歴に入る
nnoremap q: <Nop>

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" Plugin設定
"-----------------------------------------------------------------------------
" Unite {{{1
" 説明 {{{2
" COMMAND:
"  :Unite ${source} [${option}]
"  :Unite output:{コマンド名}
" KEYMAP:
"  <Tab> : Actionを開く
"  <Space> : 候補を選択する
"  * : 候補を全選択する
"  a : 候補でActionを開く
"  ? : Uniteのキーマップを表示
"
" 基本設定 {{{2
" 入力モードで開始
"let g:unite_enable_start_insert=1
" ヤンク履歴を使用可能にする
let g:unite_source_history_yank_enable = 1
" 最近使ったファイルの履歴数
let g:unite_source_file_mru_file = 200
" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
" ステータスラインを上書きしない（lightline向け）
let g:unite_force_overwrite_statusline = 0
" ESCキーを2回押すと終了する
au myvimrc FileType unite nnoremap <silent> <buffer> <Esc><Esc> :q<CR>
"au myvimrc FileType unite inoremap <silent> <buffer> <Esc><Esc> <Esc>:q<CR>
" unite grep に ag(The Silver Searcher) を使う
if executable('ag')
 let g:unite_source_grep_command = 'ag'
 let g:unite_source_grep_default_opts =
 \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
 \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
 let g:unite_source_grep_recursive_opt = ''
endif

" デフォルトアクションの変更 {{{2
" file
call unite#custom_default_action('file', 'tabopen')
" directory
call unite#custom_default_action('directory', 'vimfiler')
" ref
call unite#custom_default_action(
\ 'source/ref/refe/*,source/ref/javascript/*,source/ref/jquery/*', 'vsplit')

" アクションの追加 {{{2
" source:mappingにaction:verboseを追加する
let s:action = {
\ 'description': 'verbose',
\ 'is_selectable': 1,
\}
function! s:action.func(candidates)
  for candidate in a:candidates
    execute "verbose map" substitute(candidate.action__mapping, '\\\(<.*>\)', '\1', "g")
  endfor
endfunction
" kind ではなくて source の mapping に対して action を設定する
call unite#custom#action('source/mapping/*', 'verbose', s:action)
" preview（pキー）で action を実行したい場合は
" call unite#custom#action('source/mapping/*', 'preview', s:action)
unlet s:action

" メニュー設定 {{{2
let g:unite_source_menu_menus = {
\ "shortcuts": {
\   "description": "command shortcuts.",
\   "command_candidates": [
\     ["unite-colorscheme", "Unite colorscheme -auto-preview"],
\     ["unite-output:message", "Unite output:message"],
\     ["unite-mapping(all)", "Unite output:map|map!|lmap"],
\   ],
\ },
\}

" Uniteコマンド定義 {{{2
" 汎用
command! -nargs=+ -complete=customlist,unite#complete#source U :Unite <args>
\ -no-empty -silent -buffer-name=<args>
" ファイラ
command! Uf :Unite file
\ -no-empty -silent -buffer-name=file
" 最近使ったファイルの一覧
command! Ufm :Unite file_mru
\ -no-empty -silent -buffer-name=file_mru

" 現在のバッファ内をグレップ
command! Ug :Unite grep:%
\ -no-empty -silent -buffer-name=grep
" ディレクトリをグレップ
command! Ugd :Unite grep
\ -no-empty -silent -buffer-name=grep-dir
" カーソル下の単語で現在のバッファをグレップ
command! Ugw exe 'Unite grep:%::' .
\ escape(expand("<cword>"), '- \\') .
\ ' -no-empty -silent -buffer-name=grep-word'
" すべてのバッファをグレップ
command! Uga :Unite grep:$buffers
\ -no-empty -silent -buffer-name=grep-all-bufs

" ブックマーク（追加はUniteBookmarkAdd）
command! Ub :Unite bookmark
\ -no-empty -silent -buffer-name=bookmark
" Todo 'Todo:'をつけた行をファイル保存時に自動でブックマークするau
command! Ubt :Unite bookmark:todos
\ -no-empty -silent -buffer-name=bookmarktodos
" ブックマーク追加
command! Uba :UniteBookmarkAdd
" ブックマーク手動編集
command! Ube :edit $HOME/.unite/bookmark/default
" メニュー
command! Um :Unite menu:shortcuts
\ -no-empty -silent -buffer-name=menushortcuts

" リファレンス参照
" refe
command! Urr :Unite ref/refe
\ -no-empty -silent -buffer-name=ref/refe
" カーソル下の単語でrefe
command! Urrw exe 'Unite ref/refe ' .
\ '-no-empty -silent -buffer-name=ref/refe -input=' .
\ escape(expand("<cword>"), '- \\')
" ri
command! Urri :Unite ref/ri
\ -no-empty -silent -buffer-name=ref/ri

" スニペット候補の表示
command! Usnip :Unite neosnippets
\ -no-empty -silent -buffer-name=neosnippets
" ヤンクヒストリ
command! Uy :Unite history/yank
\ -no-empty -silent -buffer-name=history/yank
" 直前のUniteコマンドの結果に戻る
command! Ur :UniteResume
\ -no-empty -silent

" Unite source サンプル {{{2
let s:unite_source = {
\   'name': 'lines',
\ }
function! s:unite_source.gather_candidates(args, context)
  let path = expand('%:p')
  let lines = getbufline('%', 1, '$')
  let format = '%' . strlen(len(lines)) . 'd: %s'
  return map(lines, '{
  \   "word": printf(format, v:key + 1, v:val),
  \   "source": "lines",
  \   "kind": "jump_list",
  \   "action__path": path,
  \   "action__line": v:key + 1,
  \ }')
endfunction
call unite#define_source(s:unite_source)
unlet s:unite_source

" VimFiler {{{1
"
" KEYMAP:
"  h : up dir, l : down dir, t : tree view (1 dir), T : tree view all
"  e : edit, <Space> : mark, c : copy, m : move, d : delete, yy : yank path
"  N : new file, K : new dir, * : mark all, U : mark off all, ? : keymap
"  a : action, H : VimShell, ge : system filer, x : system app
"
" vimデフォルトのエクスプローラをvimfilerで置き換える
let g:vimfiler_as_default_explorer = 1
" セーフモードを無効にした状態で起動する
let g:vimfiler_safe_mode_by_default = 0
" タブで開く
let g:vimfiler_edit_action = 'tabopen'
" デフォルトでIDE風のFilerを開く
" au myvimrc VimEnter * VimFiler -split -simple -winwidth=30 -no-quit
" ステータスラインを上書きしない（lightline向け）
let g:vimfiler_force_overwrite_statusline = 0
"let g:netrw_liststyle=3
" Enterでツリー開閉、ファイル編集を可能に
au myvimrc FileType vimfiler nmap <buffer> <expr> <CR> vimfiler#smart_cursor_map("\<Plug>(vimfiler_expand_tree)", "\<Plug>(vimfiler_edit_file)")
" ESCキーを2回押すと終了する
au myvimrc FileType vimfiler nnoremap <silent> <buffer> <Esc><Esc> :q<CR>

" VimShell {{{1
"
" 動的プロンプト
let g:vimshell_prompt_expr = 'getcwd()." > "'
let g:vimshell_prompt_pattern = '^\f\+ > '
" irbを非同期で起動
command! Irb :VimShellInteractive irb
" 非同期で開いたインタプリタに現在の行を評価させる
au myvimrc FileType vimshell inoremap <buffer> ,s :<C-u>VimShellSendString<CR>
au myvimrc FileType vimshell vmap <buffer> ,s :<C-u>VimShellSendString<CR>

" neocomplecache.vim {{{1
"
" KEYMAP:
"  <Tab> : 補完
"
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
"
" Enable heavy features.
" Use camel case completion.
"let g:neocomplcache_enable_camel_case_completion = 1
" Use underbar completion.
"let g:neocomplcache_enable_underbar_completion = 1
"
" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
\  'default': '',
\  'vimshell': $HOME.'/.vimshell_hist',
\  'scheme': $HOME.'/.gosh_completions'
\}
"
" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
  let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
"
" Plugin key-mappings.
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()
"
" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplcache#smart_close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
"inoremap <expr><C-e>  neocomplcache#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"
"
" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplcache_enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplcache_enable_insert_char_pre = 1
"
" AutoComplPop like behavior.
"let g:neocomplcache_enable_auto_select = 1
"
" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplcache_enable_auto_select = 1
"let g:neocomplcache_disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"
"
" Enable omni completion.
au myvimrc FileType css setlocal omnifunc=csscomplete#CompleteCSS
au myvimrc FileType html,mkd setlocal omnifunc=htmlcomplete#CompleteTags
au myvimrc FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
au myvimrc FileType python setlocal omnifunc=pythoncomplete#Complete
au myvimrc FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"
" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
if !exists('g:neocomplcache_force_omni_patterns')
  let g:neocomplcache_force_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.php =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.c =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.cpp =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
"
" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplcache_omni_patterns.perl =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

" neosnippet.vim {{{1
" KEYMAP:
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
xmap <C-k> <Plug>(neosnippet_expand_target)
" スニペットの保存場所を変更
if has("win32") || has("win64")
  let g:neosnippet#snippets_directory = $HOME . '/vimfiles/neosnippets'
else
  let g:neosnippet#snippets_directory = $HOME . '/.vim/neosnippets'
endif
" スニペットファイルの保存時に再読み込み
au myvimrc BufWritePost *.snip NeoSnippetSource %:p

" fugitive.vim {{{1
" 説明 {{{2
" DESC:
"  VimにGitコマンドを追加。
" COMMAND:
"  :Gstatus      : git status
"    Gstatusのバッファ上で
"      - : add/reset
"      D : diff
"      C : commit
"      cvc : commit -v
"  :Gwrite/:Gadd : git add
"  :Gdiff        : git diff
"  :Gcommit -v   : git commit -v
" COMMAND: {{{2
command! Gs :Gstatus
command! Ga :Gwrite
command! Gw :Gwrite
command! Gd :Gdiff
command! Gc :Gcommit -v
command! Gca :Gcommit -va
command! Gl :Glog
command! Gb :Gblame
command! Gpush :call s:my_git_vimproc('push')
command! Gpull :call s:my_git_vimproc('pull')
" Gpush/Gpullのためのvimproc
function! s:my_git_vimproc(gitcommand) "{{{
  let command = 'git ' . a:gitcommand
  let sub = vimproc#popen2(command)
  let res = ''
  while !sub.stdout.eof
    let res .= sub.stdout.read()
    let res .= sub.stderr.read()
  endwhile
  let [cond, status] = sub.waitpid()
  let res = join(map(split(res, '\r\n\|\r\|\n'), '"[".command."] ".v:val'), "\n")
  if 0 == status
    echo res
  else
    echohl ErrorMsg | echo res | echohl None
  endif
endfunction "}}}

" quickrun.vim {{{1
"
" COMMAND:
"  :QuickRun -args foo
" KEYMAP:
"  ,r : バッファの内容を実行
"
" 実行にvimprocを使う
" エラー時はquickfixに表示する
let g:quickrun_config = {}
let g:quickrun_config = {
\  "_": {
\    'runner': 'vimproc',
\    'runner/vimproc/updatetime': 100,
\    'outputter': 'error',
\    'outputter/error': 'quickfix',
\    'outputter/error/success': 'buffer',
\    'outputter/buffer/split': ':belowright 5',
\    'outputter/buffer/close_on_empty': 1
\  },
\}
" <C-c> で実行を強制終了させる
" quickrun.vim が実行していない場合には <C-c> を呼び出す
nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
" ruby.rspec
let g:quickrun_config['ruby.rspec'] = { 'command': 'rspec' }
au myvimrc BufWinEnter,BufNewFile *_spec.rb set filetype=ruby.rspec
" htmlをブラウザで開く（tyru/open-browser.vim プラグインが必要）
let g:quickrun_config['html'] = { 'command': 'open', 'exec': '%c %s', 'outputter': 'browser' }
let g:quickrun_config['xhtml'] = { 'command': 'open', 'exec': '%c %s', 'outputter': 'browser' }
let g:quickrun_config['mkd'] = { 'command': 'kramdown', 'outputter': 'browser'}

" surround.vim {{{1
"
" KEYMAP:
"  i : inside
"  a : all
"  s : side
"  S' : ビジュアルモードで選択した範囲を'で囲む
"  ysiw' : カーソル下の単語を'で囲む
"  cs'" : 'を"に変換する
"  ds' : 'で囲まれた範囲を消す

" emmet.vim {{{1
"
" KEYMAP:
"  <C-e> : 展開
"  <C-_> : コメントアウト／イン
"          （_と/が同じキーマップになってるのでCtrl+/でできる）
"let g:user_emmet_leader_key = '<C-e>'
let g:user_emmet_expandabbr_key = '<C-e>'
let g:user_emmet_togglecomment_key = '<C-_>'
" タグのコンプリート
let g:use_emmet_complete_tag = 1

" カスタマイズ設定
let g:user_emmet_settings = {
\  'lang': 'ja',
\  'indentation': "  ",
\  'html': {
\    'filters': 'html',
\    'snippets': {
\      'meta:viewport': "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">",
\      'css:bs': "<link href=\"css/bootstrap.min.css\" rel=\"stylesheet\">",
\      'cd': "<![CDATA[|]]>",
\      'js:jq': "<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n<script>\n\\$(function() {\n\t|\n})()\n</script>",
\      'js:bs': "<script src=\"https://code.jquery.com/jquery.js\"></script>\n<script src=\"js/bootstrap.min.js\"></script>",
\    },
\  },
\  'javascript': {
\    'snippets': {
\      'jq': "\\$(function() {\n\t\\${cursor}\\${child}\n});",
\      'jq:json': "\\$.getJSON(\"${cursor}\", function(data) {\n\t\\${child}\n});",
\      'jq:each': "\\$.each(data, function(index, item) {\n\t\\${child}\n});",
\      'fn': "(function() {\n\t\\${cursor}\n})();",
\      'tm': "setTimeout(function() {\n\t\\${cursor}\n}, 100);",
\    },
\    'use_pipe_for_cursor': 0,
\  },
\  'css': {
\    'filters': 'fc',
\    'snippets': {
\      'box-shadow': "-webkit-box-shadow: 0 0 0 # 000;\n-moz-box-shadow: 0 0 0 0 # 000;\nbox-shadow: 0 0 0 # 000;",
\    },
\  },
\  'vim': {
\    'snippets': {
\      'nn': 'nnoremap <silent> ${cursor} :<C-u>',
\      'nnu': 'nnoremap <silent> [unite]${cursor}<CR> :<C-u>Unite<Space>\n\\<Space>-no-empty<Space>-silent<Space>-buffer-name=<CR>',
\    },
\  },
\  'java': {
\    'snippets': {
\     'main': "public static void main(String[] args) {\n\t|\n}",
\     'println': "System.out.println(\"|\");",
\     'class': "public class | {\n}\n",
\    },
\  },
\  'php': {
\    'extends': 'html',
\    'filters': 'html,c',
\  },
\  'less': {
\    'filters': 'fc',
\    'extends': 'css',
\  },
\  'lorem_lipsum_ja': {
\    '^\%(lorem\|lipsum\)\(\d*\)$': function('emmet#lorem#ja#expand'),
\  },
\}

" rcodetools.vim {{{1
"
" DESC: xmpfilterの呼び出し設定
" <F1>でバッファ全体にxmpfilterを実行
"{{{ xmpfilter mapping (disable)
"nmap <silent> <F1> mzggVG!xmpfilter -a<cr>'z
"imap <silent> <F1> <Esc><F1>
"" <F2>で現在行/選択行にxmpfilterを実行
"map <silent> <F2> !xmpfilter -a<cr>
"nmap <silent> <F2> V<F2>
"imap <silent> <F2> <Esc><F2>a
"" <F3>で現在行/選択行に「# =>」マークを追加
"vmap <silent> <F3> !xmpfilter -m<cr>
"nmap <silent> <F3> V<F3>
"imap <silent> <F3> <Esc><F3>a
"" <F4>で現在行/選択行の「# =>」マークを削除
"vmap <silent> <F4> ms:call RemoveRubyEval()<CR>
"nmap <silent> <F4> V<F4>
"imap <silent> <F4> <Esc><F4>a
"" RemoveRubyEval() の定義
"function! RemoveRubyEval() range
  "let begv = a:firstline
  "let endv = a:lastline
  "normal Hmt
  "set lz
  "execute ":" . begv . "," . endv . 's/\s*# \(=>\|!!\).*$//e'
  "normal 'tzt`s
  "set nolz
  "redraw
"endfunction
"" JRuby用<F11>でバッファ全体にjxmpfilterを実行
"nmap <silent> <F11> mzggVG!jxmpfilter -a<cr>'z
"imap <silent> <F11> <Esc><F11>
"}}}

" MiniBufExplorer {{{1
"
" 自動起動
let g:miniBufExplAutoStart = 0
" バッファが２つ以上で開く
" let g:miniBufExplBuffersNeeded = 2
" Diffモードでは隠す
let g:miniBufExplHideWhenDiff = 1
" バッファリストのサイクル化
let g:miniBufExplCycleArround = 1
" 表示行数を制限
let g:miniBufExplMaxSize = 1
" カラーリング
let g:did_minibufexplorer_syntax_inits = 1
" for buffers that have NOT CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveNormal ctermfg=black ctermbg=lightgray guifg=black guibg=lightgray
" for buffers that have CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveChanged ctermfg=black ctermbg=lightred guifg=black guibg=lightred
" buffers that have NOT CHANGED and are VISIBLE
hi MBEVisibleNormal cterm=bold ctermfg=white gui=bold guifg=white guibg=black
" buffers that have CHANGED and are VISIBLE
hi MBEVisibleChanged cterm=bold ctermfg=lightred gui=bold guifg=lightred guibg=black
" for buffers that have NOT CHANGED and are NOT VISIBLE.
hi MBENormal ctermfg=darkgray guifg=darkgray guibg=black
" for buffers that HAVE CHANGED and are NOT VISIBLE
hi MBEChanged ctermfg=red guifg=red guibg=black

" lightline.vim {{{1
"
" lightline config
"\  'colorscheme': 'wombat',
"\    'right': [['mode'], ['filename']]
let g:lightline = {
\  'mode_map': {'c': 'NORMAL'},
\  'active': {
\    'left': [['mode', 'paste'], ['filename', 'fugitive']],
\    'right': [['lineinfo'], ['percent'], ['pwd', 'fileformat', 'fileencoding', 'filetype']]
\  },
\  'inactive': {
\    'left': [],
\    'right': [['filename']]
\  },
\  'component_function': {
\    'modified': 'MyModified',
\    'readonly': 'MyReadonly',
\    'pwd': 'MyPwd',
\    'fugitive': 'MyFugitive',
\    'filename': 'MyFilename',
\    'fileformat': 'MyFileformat',
\    'filetype': 'MyFiletype',
\    'fileencoding': 'MyFileencoding',
\    'mode': 'MyMode'
\  }
\}

function! MyModified()
  "return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : ''
endfunction
function! MyReadonly()
  "return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '[RO]' : ''
endfunction
function! MyFilename()
  return (&ft == 'vimfiler' ? vimfiler#get_status_string() :
\         &ft == 'unite' ? unite#get_status_string() :
\         &ft == 'vimshell' ? vimshell#get_status_string() :
\         '' != expand('%:t') ? expand('%:t') : '[No Name]') .
\        ('' != MyModified() ? ' ' . MyModified() : '') .
\        ('' != MyReadonly() ? ' ' . MyReadonly() : '')
endfunction
function! MyPwd()
  return winwidth(0) > 100 ? getcwd() : ''
endfunction
function! MyFugitive()
  try
    if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction
function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction
function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction
function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction
function! MyMode()
  return &ft == 'help' ? 'Help' :
\        &ft == 'minibufexpl' ? 'MBE' :
\        &ft == 'quickrun' ? 'QuickRun' :
\        &ft == 'qf' ? 'QuickFix' :
\        &ft == 'unite' ? 'Unite' :
\        &ft == 'vimfiler' ? 'VimFiler' :
\        &ft == 'vimshell' ? 'VimShell' :
\        winwidth(0) > 60 ? lightline#mode() : ''
endfunction

" matchit {{{1
" if ... end など対になるキーワードに%で移動

" Tagbar {{{1
let g:tagbar_type_javascript = {'ctagsbin': '/opt/local/bin/jsctags'}

" SrcExpl {{{1
" プレビューウィンドウの更新間隔（msec）
let g:SrcExpl_refreshTime = 1000
" 競合を避けるバッファ
let g:SrcExpl_pluginList = ['*unite*', 'VimShell', 'VimFiler']
" タグの自動生成（他でやってるのでいったんオフ）
let g:SrcExpl_isUpdateTags = 0

" Simple-Javascript-Indenter {{{1
" switchのインデントがいくらかマシに
let g:SimpleJsIndenter_CaseIndentLevel = -1

" CtrlP {{{1
"
" KEYMAP:
"  C-f: MRUモードのオン／オフ
"  C-r: 正規表現モードのオン／オフ
" タブで開く
let g:ctrlp_open_new_file = 't'
" migemoを使って日本語正規表現検索
if executable('cmigemo')
  let g:ctrlp_use_migemo = 1
endif

" migemo-search.vim {{{1
if executable('cmigemo')
  cnoremap <expr> <CR> migemosearch#replace_search_word()."\<CR>"
endif

" Ref {{{1
"
" COMMAND:
"  :Ref refe Array
let g:ref_use_vimproc = 1 " 0:disable / 1:enable
let g:ref_open = 'vsplit'
" ref/refe
let g:ref_refe_version = 2
" ローカルファイルを参照するため、.local.vircに以下を宣言
" ref/javascript
" let g:ref_javascript_doc_path = $HOME . '/doc/jsref/htdocs'
" ref/jquery
" let g:ref_jquery_doc_path = $HOME . '/dev/doc/jqapi'

"}}}1-------------------------------------------------------------------------

