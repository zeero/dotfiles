"-----------------------------------------------------------------------------
" 初期設定
"-----------------------------------------------------------------------------
" 初期設定 {{{1
" VI互換モードOFF
if has('vim_starting')
  set nocompatible
  " Winコマンドプロンプトではcp932
  if has('win32')
    let &termencoding = &encoding
  endif
endif
" 内部エンコーディングをutf-8に指定
set encoding=utf-8
scriptencoding utf-8
" ファイルエンコーディング設定
set fencs=utf-8,cp932,euc-jp,iso-2022-jp
set ffs=unix,dos,mac
" キー入力をタイムアウトさせない
set notimeout
set ttimeout
" 高速ターミナル接続を行う
set ttyfast
" パス区切り文字を共通化する
set shellslash
" CursorHoldのインターバル
set updatetime=100
" 自動コマンドの初期化
augroup myvimrc
  au!
augroup END
" 環境変数
let $MYVIMDIR = '~/.vim'
if !isdirectory($MYVIMDIR) && isdirectory($HOME . '/vimfiles')
  let $MYVIMDIR = '~/vimfiles'
endif
let $LANG = 'ja_JP.UTF-8'
" コンソール版で環境変数$DISPLAYが設定されていると起動が遅くなる件へ対応 {{{
if !has('gui_running') && has('xterm_clipboard')
  set clipboard=exclude:cons\\\|linux\\\|cygwin\\\|rxvt\\\|screen
endif "}}}

" Dein {{{1
if has('vim_starting')
  let s:dein_dir = expand($MYVIMDIR . '/dein')
  let s:dein_toml = expand($MYVIMDIR . '/dein.toml')
  let s:dein_local = expand($MYVIMDIR . '/dein.local')
  filetype off
  set rtp& rtp+=$MYVIMDIR/dein/repos/github.com/Shougo/dein.vim
  if dein#load_state(s:dein_dir)
    call dein#begin(s:dein_dir, [$MYVIMRC, s:dein_toml])
    call dein#load_toml(s:dein_toml, {})
    if isdirectory(s:dein_local)
      call dein#local(s:dein_local)
    endif
    call dein#end()
    call dein#save_state()
  endif
  filetype plugin indent on
endif

if dein#check_install()
  call dein#install()
endif

" singleton.vim {{{1
if has('gui_running')
  let g:singleton#opener = 'tab drop'
  call singleton#enable()
endif

" プラグイン無効化 {{{1
let g:loaded_gzip              = 1
let g:loaded_tar               = 1
let g:loaded_tarPlugin         = 1
let g:loaded_zip               = 1
let g:loaded_zipPlugin         = 1
let g:loaded_rrhelper          = 1
let g:loaded_2html_plugin      = 1
let g:loaded_vimball           = 1
let g:loaded_vimballPlugin     = 1
let g:loaded_getscript         = 1
let g:loaded_getscriptPlugin   = 1
let g:loaded_netrw             = 1
let g:loaded_netrwPlugin       = 1
let g:loaded_netrwSettings     = 1
let g:loaded_netrwFileHandlers = 1

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" 基本設定
"-----------------------------------------------------------------------------
" 検索に関する設定 {{{1
" 検索時に大文字小文字を無視 (noignorecase:無視しない)
set ignorecase
" 大文字小文字の両方が含まれている場合は大文字小文字を区別
set smartcase
" インクリメンタルな検索
set incsearch
" 検索結果文字列のハイライトを有効にする
set hlsearch
" 検索時にファイルの最後まで行ったら最初に戻る (nowrapscan:戻らない)
set wrapscan
" タグ検索パスの設定
"set tags=./tags,tags
au myvimrc FileType * exe "setlocal tags+="
\ . $HOME . "/.tags/" . &ft . ".tags,"
\ . $HOME . "/.tags/tags"
" タグ検索に二分検索をオフにする（vimdoc-jaフリーズ対策）
set notagbsearch
" バックスラッシュやクエスチョンを状況に合わせ自動的にエスケープ
cnoremap <expr> / getcmdtype() == '/' ? '\/' : '/'
cnoremap <expr> ? getcmdtype() == '?' ? '\?' : '?'
" ワイルドカード展開と補完で無視するパターン
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*.o,*.class,*.pyc
" jvgrep
if executable('jvgrep')
  set grepprg=jvgrep
endif

" 編集に関する設定 {{{1
" タブの画面上での幅
set tabstop=2
set shiftwidth=2
set softtabstop=2
" インデントにスペースを使う
set expandtab
" 自動的にインデントする
set autoindent
" 高度なオートインデント
set smartindent
" 折り返しでもインデント
set breakindent
" '<'や'>'でインデントする際に'shiftwidth'の倍数に丸める
set shiftround
" バックスペースでインデントや改行を削除できるようにする
set backspace=2
" 括弧入力時に対応する括弧を表示
set showmatch
" 対応括弧のハイライト表示の秒数
set matchtime=1
" 対応括弧に'<'と'>'のペアを追加
set matchpairs& matchpairs+=<:>
" コマンドライン補完するときに強化されたものを使う
set wildmenu
set wildmode=list:longest,full
" テキスト挿入中の自動折り返しを日本語に対応させる
set formatoptions&
set formatoptions+=mM
" コメント行で'o'で改行したらコメントをつけない
" ftpluginで上書きされてしまうためauでなんとかする
au myvimrc BufRead,BufNew,BufNewFile * set formatoptions-=o
" 文字数による自動折り返しはしない
set textwidth=0
" 区切り文字設定（単語の一部とする文字の設定）
"   Macではデフォルトの'iskeyword'がcp932に対応しきれていないので修正
"     @ : アルファベット
"     48-57 : 数字
"     128-167,224-235,192-255 : Extended ASCII characters（日本語には関係ない）
if has('mac')
  set iskeyword=@,48-57,_,128-167,224-235
  " '-'も単語の一部と認識させる
  set iskeyword+=-
else
  " '-'も単語の一部と認識させる
  set iskeyword&
  set iskeyword+=-
endif
" 日本語整形スクリプト(by. 西岡拓洋さん)用の設定
let format_allow_over_tw = 1	" ぶら下り可能幅
" 編集後保存していなくても別のファイルを開く
" set hidden
" 新しく開く代わりにすでに開いてあるバッファを開く
set switchbuf=useopen
" コマンドライン履歴
set history=10000
" 外部のエディタで編集中のファイルが変更されたら自動で読み直す
" （ウィンドウを移動する度に変更をチェックする）
set autoread
au myvimrc WinEnter * checktime
nnoremap <silent> <F5> :<C-u>checktime<CR>
" クイックフィックスは常にcwindowで表示する
autocmd myvimrc QuickFixCmdPost [^l]* nested botright cwindow
autocmd myvimrc QuickFixCmdPost    l* nested botright lwindow
" 補完時に大文字小文字を区別しない
set infercase
" カーソルを文字が存在しない部分でも動けるようにする
" set virtualedit=all
" 行頭行末で前行次行に移動する
" set whichwrap=b,s,h,l,<,>,[,]
" <C-a>で8進数は除く
set nrformats-=octal
" スクロールの設定
set scrolloff=5
set sidescroll=0
set sidescrolloff=9
" ビープ音を消す
set visualbell t_vb=

" 画面表示の設定 {{{1
" シンタックスハイライト
syntax enable
" カラースキーマ設定
set t_Co=256
if has('gui_running')
  set background=dark
  colorscheme ir_black
else
"   let g:molokai_original = 1
  let g:rehash256 = 1
  colorscheme molokai
"   solarized {{{
"   set background=dark
"   let g:solarized_termcolors = 256
"   let g:solarized_termtrans = 1
"   let g:solarized_contrast = "high"
"   let g:solarized_visibility = "high"
"   colorscheme solarized
"   }}}
endif
" TODOを常にハイライト
syn match MyTodo /\v\c \[?(TODO|FIXME)\]?:? /hs=s+1,he=e-1 containedin=ALL
hi MyTodo term=standout ctermfg=12 gui=bold guifg=#666666 guibg=yellow
hi! link Todo MyTodo
au myvimrc Syntax * syn match MyTodo /\v\c \[?(TODO|FIXME)\]?:? /hs=s+1,he=e-1 containedin=ALL
" 遅延描画
" set lazyredraw
" 行を強調表示
set cursorline
hi clear CursorLine
hi CursorLine term=underline cterm=underline gui=underline
" 行番号を表示 (nonumber:表示)
set number
" 行番号の左に余白をとる
" au myvimrc BufEnter,WinEnter,BufWinEnter * let &l:numberwidth = len(line("$")) + 2
" ルーラーを表示 (noruler:非表示)
set ruler
" タイトルを表示
set title titlestring=%t
" 終了後のウィンドウタイトル
set titleold=vim
" タブや改行を表示 (nolist:非表示)
set list
" どの文字でタブや改行を表示するかを設定
set listchars=tab:￫･,trail:_,extends:»,precedes:«,nbsp:%
" タブの左側にカーソル表示
"set listchars=tab:\ \
" 全角スペースも表示　
highlight JpSpace ctermfg=darkgrey guifg=darkgrey
au myvimrc BufRead,BufNew * match JpSpace /　/
" □や○の文字があってもカーソル位置をずらさせない
set ambiwidth=double
" 画面最後の行を出来る限り表示する
set display&
set display+=lastline
" modelineを無視する
"set nomodeline
" フォールディング方式の指定（マーカー使用）(=fdm)
set foldmethod=marker
" 長い行を折り返して表示 (nowrap:折り返さない)
set wrap
" コマンドラインの高さ (Windows用gvim使用時はgvimrcを編集すること)
set cmdheight=1
" コマンドをステータス行に表示
set showcmd
" 常にステータス行を表示 (詳細は:he laststatus)
set laststatus=2
" ステータスラインに文字コードと改行文字とファイルタイプを表示する
"set statusline=%<%f\%m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%l,%c
"set statusline=%<%t\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']['.&ft.']'}%=%l,%c%V%8P
" タブは非表示
"set showtabline=0
" vsplitは右に開く
set splitright
" 画面サイズが広い場合はバッファを右に移動させる
" TODO: Unite開くと低くなる
"au myvimrc BufRead,BufNew,BufNewFile * if winwidth(0) > 140 | wincmd L | wincmd _ | endif
" スプラッシュ
au myvimrc VimEnter * if !argc() | call s:my_splash() | endif
function! s:my_splash() "{{{
  " スプラッシュを開く
  enew
  silent read $MYVIMDIR/doc/splash.txt
  call cursor(1, 1)
  set ft=splash
  setlocal buftype=nofile nobuflisted nocursorcolumn nocursorline nolist nonumber noswapfile nomodifiable nomodified
  call localrc#load(g:localrc_filename, getcwd())

  " VimShellを画面下部に開く
"   VimShell -split-command=botright\ 5split
"   exe "normal! \<C-w>\<C-w>\<Esc>"

  " 引数リストのファイルをタブで開く
"   let i = 0
"   while i < argc()
"     exe 'tabe ' . argv(i)
"     let i = i + 1
"   endwhile
endfunction "}}}
" 補完メニューの高さ設定（デフォルト：最大）
set pumheight=10

" GUI固有の画面表示の設定 {{{1
if has('gui_running')
  set guioptions&
  " メニューファイルが存在しない場合、menu.vimを読み込まない
  if !filereadable($VIMRUNTIME . '/menu.vim')
    set guioptions+=M
  endif
  " ビジュアル選択を自動的にクリップボードへ
  "set guioptions+=a
  " スクロールバーを非表示にする
  set guioptions-=r
  set guioptions-=R
  set guioptions-=l
  set guioptions-=L
  " フォントを指定
  if has('win32') || has('win64')
    set guifont=Ricty_Diminished:h16:cSHIFTJIS
  else
    set guifont=Ricty\ Diminished\ Regular:h20
"     let g:vimshell_editor_command = '/usr/local/opt/macvim/MacVim.app/Contents/MacOS/MacVim'
  endif
  " ウィンドウサイズを最大化する
  if has('win32') || has('win64')
    au myvimrc GUIEnter * simalt ~x
  endif
  " 透明度
  if has('mac')
    set transparency=12
  endif
  " ヤンクでクリップボードを共有する
  "if has('clipboard')
  "  set clipboard=unnamed
  "endif
  " マウスを有効にする
  if has('mouse')
    set mouse=a
  endif
  " IME制御をオフにする
  set iminsert=0
  set imsearch=0
  set noimcmdline
  " Alt+CとAlt+Pでコピペする
  vnoremap <M-c> "+y
  inoremap <M-v> <C-r>+
  cnoremap <M-v> <C-r>+
  " C-Scrollでフォントサイズ変更（要Zoom.vim）
  nnoremap <C-ScrollWheelUp> :ZoomIn<CR>
  nnoremap <C-ScrollWheelDown> :ZoomOut<CR>
  " バッファがローカルバッファに表示されなくなった場合は削除する
  " （[No Name]バッファへの対策）
  set bufhidden=wipe
  " タブのラベル
  set guitablabel=%{tabpagenr()}:%h%t%m
  " 印刷オプション
  set printoptions=wrap:y,number:y
  set printheader=%<%f%h%m%=Page-%N
endif

" ファイル操作に関する設定 {{{1
" バックアップファイル、swapファイルを作成しない
set nobackup
set nowritebackup
set noswapfile
" スワップファイルの作成ディレクトリにパスを追加
" set directory&
" set directory+=,~/tmp,$TMP
" 永続undo
if has('persistent_undo')
  let s:undodir='~/.vimundo'
  if !isdirectory(s:undodir)
    call vimproc#system_bg('mkdir ' . s:undodir)
  endif
  set undodir=s:undodir
  set undofile
endif
" ファイルを開くと、そのファイルと同じディレクトリに移動
" 名無しのvim使い <http://nanasi.jp/articles/vim/cd_vim.html>
au myvimrc BufRead * call s:my_lcd()
function! s:my_lcd() "{{{
  if isdirectory(expand("%:p:h"))
    exe "lcd" expand("%:p:h")
  endif
  call localrc#load(g:localrc_filename, getcwd())
endfunction "}}}
"set autochdir （設定するとVimShellが動かなくなる）
" 前回終了したカーソル行に移動して真ん中にする（フォールドがあれば開く）
" TODO: 真ん中にならない。たぶんなんかのプラグインが悪さしてる。
au myvimrc BufReadPost * call s:my_last_position_jump()
function! s:my_last_position_jump()
  if line("'\"") > 1 && line("'\"") <= line("$")
    exe "normal! g`\"zvzz"
  endif
  exe "normal! zvzz"
endfunction

" ファイルタイプ別の設定 {{{1
" Vim {{{2
" vimrcの保存時に再読み込み
if !has('gui_running')
  au myvimrc BufWritePost *vimrc nested source $MYVIMRC |
  \ call localrc#load(g:localrc_filename)
else
  au myvimrc BufWritePost *vimrc nested source $MYVIMRC |
  \ if filereadable($MYGVIMRC) | source $MYGVIMRC | endif |
  \ call localrc#load(g:localrc_filename)
endif
" バックスラッシュのインデントを無くす
let g:vim_indent_cont = 0
" vimrc、helpでは:もiskに入れる
if expand("%") =~ "vimrc"
  setlocal iskeyword+=:,#
endif
au myvimrc FileType help setlocal iskeyword+=:
" vimrcは起動時だったらgit pull
" au myvimrc VimEnter *vimrc call s:my_vimenter_vimrc()
function! s:my_vimenter_vimrc() "{{{
  call s:my_vimproc_async({'cmd': 'git pull ' . resolve($MYVIMRC)})
  checktime
endfunction "}}}

" NeoSnippet {{{2
au myvimrc FileType neosnippet setlocal nofoldenable

" fugitive、vim-vcs {{{2
au myvimrc FileType gitcommit,vcs-*
\ setlocal nofoldenable |
\ wincmd L |
\ noh |
\ let @/ = "^@@ .*"

" html {{{2
" 閉じタグの自動入力設定
au myvimrc FileType html,xml,eruby inoremap <expr> <buffer> > MyHtmlEndwise()
function! MyHtmlEndwise() "{{{
  let val = ">"
  let col = col(".")
  let str = getline(".")
  let idx = strridx(str, "<", col - 2)
  let idx_slash = strridx(str, "/", col - 1)
  if idx == -1 || idx < idx_slash
    return val
  endif
  let str_part = strpart(str, idx, col - 1 - idx)
  if str_part !~ '\(<br\|<img\)'
    let val .= substitute(str_part, '<\([^ ]\+\).*', '</\1>', '')
    return val . "\<Esc>" . col . "|a"
  else
    return val
  endif
endfunction "}}}

" Java {{{2
" ハイライト設定
let java_highlight_all = 1
let java_highlight_functions = "style"
let java_highlight_debug = 1

" DOS {{{2
au myvimrc BufRead,BufNewFile *.bat setlocal fenc=sjis ff=dos

" ファイルタイプ指定 {{{2
" setfは二度書き防止をされているため、setlocal filetypeをすること！
" JavaScript
au myvimrc BufRead,BufNewFile *.json setlocal filetype=json
au myvimrc BufRead,BufNewFile jquery.*.js setlocal filetype=javascript syntax=jquery
au myvimrc BufRead,BufNewFile *.coffee setlocal filetype=coffee
" Apache
au myvimrc BufRead,BufNewFile httpd*.conf setlocal filetype=apache
" ctags
au myvimrc BufRead,BufNewFile *.tags setlocal filetype=tags
" log
au myvimrc BufRead,BufNewFile *.log* setlocal filetype=log
" markdown（workflowishで扱う）
au myvimrc BufNewFile,BufRead *.md,*.mkd,*.markdown setlocal filetype=workflowish
au myvimrc FileType workflowish let b:caw_wrap_oneline_comment = ["<!--", "-->"]
" yaml（vim-ansible-yamlで使う）
au myvimrc BufNewFile,BufRead *.yaml,*.yml setlocal filetype=ansible

" コマンド定義 {{{1
" 拡張 {{{2
" H(elp)
command! -nargs=? -complete=help H call s:my_help('<args>')
function! s:my_help(keyword) "{{{
  try
    if winwidth(0) > 140
      exe 'botright vertical help ' . a:keyword
      vertical resize 79
      " wincmd p
    else
      exe 'help ' . a:keyword
      " wincmd p
    endif
  catch
    echohl WarningMsg
    echo substitute(v:exception, '^Vim(help):', '', '')
    echohl None
  endtry
endfunction "}}}
" H(elp)f(unction-list)
command! -nargs=0 Hf H function-list
" K(otoba)
command! -nargs=1 K Ref webdict <args>
" Vimrc
command! Vimrc tabe $MYVIMRC
" So
command! So source %
" Bdo
command! Bdo call s:my_command_bd_other()
command! QuitOther call s:my_command_bd_other()
command! QO call s:my_command_bd_other()
function! s:my_command_bd_other() "{{{
  let i = 1
  let cur = bufnr("%")
  while i <= bufnr("$")
    if buflisted(i) && i != cur
      exe "bdelete" i
    endif
    let i = i + 1
  endwhile
endfunction "}}}
" Lcd
command! Lcd silent exe "lcd " . expand("%:p:h") | pwd
" LcdLocalrc
command! LcdLocalrc silent exe "lcd " . fnamemodify(get(reverse(localrc#search(get(g:, 'localrc_filename'))), 0), ":p:h") | pwd
" Ls
command! -nargs=* -complete=file Ls echo globpath('./<args>', '*', 1)
" Noh
command! Noh noh | QuickhlManualReset
" Info
nnoremap <C-g> :<C-u>Info<CR>
command! Info call s:my_info()
function! s:my_info() "{{{
  " ファイル名、パス
  echohl Identifier
  echo expand("%:t")
  echohl None
  echo expand("%:p")
  " 行数など
  let old_status = v:statusmsg
  exe "silent normal! g\<C-g>"
  let msg = split(v:statusmsg, "; ")
  for line in msg
    echo line
  endfor
  let v:statusmsg = old_status

  " ステップカウンタ
  let countEmpty = 0
  let countComment = 0
  let countSource = 0
  let lnum = 1
  while lnum <= line("$")
    let line = getline(lnum)
    if line =~ '^\s*$'
      let countEmpty = countEmpty + 1
    elseif synIDattr(synIDtrans(synID(lnum, match(line, '\S') + 1, 1)), "name") == 'Comment'
      let countComment = countComment + 1
    else
      let countSource = countSource + 1
    endif
    let lnum = lnum + 1
  endwhile
  echo "空白行：" . countEmpty
  echo "コメント行：" . countComment
  echo "ソース行：" . countSource

  " git-info
  if has('win32') || has('win64')
    let sep = ';'
  else
    let sep = ':'
  endif
  if exists('*fugitive#head') && strlen(fugitive#head()) && len(globpath(substitute($PATH, sep, ',', 'g'), 'git-info')) && executable('mktemp')
    echo vimproc#system('git info')
  endif
endfunction "}}}
" Open
command! -nargs=? Open if <q-args> == '' | call vimproc#open(expand("%:p:h")) | else | call vimproc#open(<q-args>) | endif
" Debug
command! -nargs=? Debug echohl Debug | echomsg "Debug : ".expand("<sfile>")." : ".expand("<slnum>") | echomsg <args> | echohl None
" Yank
command! -nargs=1 Yank redi @" | execute <q-args> | redi END

" 独自 {{{2
" QFClear
command! -nargs=0 QFClear call setqflist([])
" QFTodo
command! -nargs=0 QFTodo call s:my_qf_todo()
function! s:my_qf_todo() "{{{
  let qflist = []
  let index = 1
  for line in getline('1', line('$'))
    if line =~? ' \[\?\(todo\|fixme\)\]\?:\? '
      call add(qflist, {
      \ 'bufnr': bufnr('%'),
      \ 'lnum': index,
      \ 'text': line,
      \})
    endif
    let index += 1
  endfor
  call setqflist(qflist)
  botright cwindow 7
endfunction "}}}
" LocalInit
let g:my_local_init_skel_file = $MYVIMDIR . '/skel/local_init.vim'
command! -nargs=0 LocalInit call s:my_local_init()
function! s:my_local_init() "{{{
  if !filereadable('./.local.vimrc')
    call vimproc#system('cp ' . g:my_local_init_skel_file . ' ./.local.vimrc')
  endif
  call s:my_ctags()
endfunction "}}}
" Ctags
command! -nargs=0 Ctags call s:my_ctags()
function! s:my_ctags() "{{{
  call vimproc#system_bg('ctags -R -f tags ' . s:my_path_convert(getcwd()))
endfunction "}}}
" AG
command! -nargs=+ -complete=file AG call s:my_silver_searcher(<q-args>)
function! s:my_silver_searcher(args) "{{{
  " set search keyword
  let @/ = a:args
  " async
  call s:my_vimproc_async({
  \ 'cmd': 'ag --vimgrep ' . a:args,
  \ 'callback': 's:my_grep_finish'
  \})
endfunction "}}}
function! s:my_grep_finish(result) "{{{
  let qflist = []
  let lines = split(a:result, '\n')
  if empty(lines)
    echohl WarningMsg
    echo 'AG: Pattern not found.'
    echohl None
    return
  endif
  for line in lines
    let items = split(line, ':')
    let qfline = {
    \ 'filename': get(items, 0),
    \ 'lnum': get(items, 1),
    \ 'col': get(items, 2),
    \}
    call remove(items, 0, 2)
    let qfline['text'] = join(items, ':')
    call add(qflist, qfline)
  endfor
  call setqflist(qflist, 'r')
  tab copen
endfunction "}}}
" PT
command! -nargs=+ -complete=file PT call s:my_platinum_searcher(<q-args>)
function! s:my_platinum_searcher(args) "{{{
  " set search keyword
  let @/ = a:args
  " async
  call s:my_vimproc_async({
  \ 'cmd': 'pt --nocolor --nogroup ' . a:args,
  \ 'callback': 's:my_grep_finish'
  \})
endfunction "}}}
" Wofl2Md
command! -nargs=0 Wofl2Md call s:my_wofl_to_md()
function! s:my_wofl_to_md() "{{{
  exe '%s/#/\\#/'
  exe '%s/^\* /\r# /'
endfunction "}}}
" Lipsum
nmap \s :Lipsum \s<CR>
nmap \d :Lipsum \d<CR>
nmap \S :Lipsum \S<CR>
command! -count -nargs=1 Lipsum call s:my_lipsum(<q-args>)
function! s:my_lipsum(mode) "{{{
  if count == 0
    let cnt = 1
  else
    let cnt = count
  endif
  if a:mode ==# '\s'
    execute 'normal! ' . cnt . 'a '
  elseif a:mode ==# '\d'
    let str = ''
    let i = 1
    while i <= cnt
      let str .= string(i % 10)
      let i += 1
    endwhile
    execute 'normal! a' . str
  elseif a:mode ==# '\S'
    let lipsum = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. '
    let loop = cnt / len(lipsum)
    let len = cnt % len(lipsum)
    let str = ''
    let i = 0
    while i <= loop
      if i == loop
        let str .= strpart(lipsum, 0, len)
      else
        let str .= lipsum
      endif
      let i += 1
    endwhile
    execute 'normal! a' . str
  endif
endfunction "}}}
" Tw2Md
command! -nargs=0 -range Tw2Md call s:my_tw_to_md(<line1>, <line2>)
function! s:my_tw_to_md(line1, line2) "{{{
  execute a:line1 . ',' . a:line2 . 's/<\/+?code.*/```/e'
  execute a:line1 . ',' . a:line2 . 's/\(\s*\)\({{{\|}}}\)$/```/e'
  execute a:line1 . ',' . a:line2 . 's/\({{{\|}}}\)/`/eg'
  execute a:line1 . ',' . a:line2 . 's/\[\[\(.*\)|\(http.*\)\]\]/[\1](\2)/e'
  execute a:line1 . ',' . a:line2 . 's/^@@\(.*\)@@/\\ \1/e'
  execute a:line1 . ',' . a:line2 . 's/#/*/eg'
  execute a:line1 . ',' . a:line2 . 's/\*/* /eg'
  execute a:line1 . ',' . a:line2 . 's/\* \* /  \* /e'
  execute a:line1 . ',' . a:line2 . 's/\* \* /  \* /e'
  execute a:line1 . ',' . a:line2 . 's/\* \* /  \* /e'
  execute a:line1 . ',' . a:line2 . 's/\* \* /  \* /e'
  execute a:line1 . ',' . a:line2 . 's/\* \* /  \* /e'
  execute a:line1 . ',' . a:line2 . 's/^!!!/### /e'
  execute a:line1 . ',' . a:line2 . 's/^!!/## /e'
  execute a:line1 . ',' . a:line2 . 's/^!/# /e'
endfunction "}}}

" TortoiseSVN {{{2
" /endrev:-1 は HEAD（-2：ベースリビジョン、-3：ワーキングコピー）
if executable('TortoiseProc')
  command! -nargs=? -complete=dir TSlog silent call s:my_tsvn_log(expand("%"), <q-args>)
  function! s:my_tsvn_log(fname, path) "{{{
    let path = a:path == '' ? a:fname : a:path
    call vimproc#system_bg('TortoiseProc /command:log /path:"'.path.'" /notempfile /closeonend')
  endfunction "}}}
  command! TSdiff silent call vimproc#system_bg('TortoiseProc /command:diff /path:"'.expand("%").'" /notempfile /closeonend')
  command! TSdiffPrev silent call vimproc#system_bg('TortoiseProc /command:prevdiff /path:"'.expand("%").'" /notempfile /closeonend')
  command! -nargs=? -complete=dir TSupdate silent call s:my_tsvn_update(expand("%"), <q-args>)
  function! s:my_tsvn_update(fname, path) "{{{
    let path = a:path == '' ? a:fname : a:path
    call vimproc#system_bg('TortoiseProc /command:update /path:"'.path.'" /notempfile /closeonend')
  endfunction "}}}
  command! TSadd silent call vimproc#system_bg('TortoiseProc /command:add /path:"'.expand("%").'" /notempfile /closeonend')
  command! -nargs=? -complete=dir TScommit silent call s:my_tsvn_commit(expand("%"), <q-args>)
  function! s:my_tsvn_commit(fname, path) "{{{
    let path = a:path == '' ? a:fname : a:path
    call vimproc#system_bg('TortoiseProc /command:commit /path:"'.path.'" /notempfile /closeonend')
  endfunction "}}}
  command! TSrevert silent call vimproc#system_bg('TortoiseProc /command:revert /path:"'.expand("%").'" /notempfile /closeonend')
  command! TSprops silent call vimproc#system_bg('TortoiseProc /command:properties /path:"'.expand("%:h").'" /notempfile /closeonend')
  command! TSblame silent call vimproc#system_bg('TortoiseProc /command:blame /path:"'.expand("%").'" /notempfile /closeonend /line:'.line(".").' /endrev:-1')
endif
" SVNレポジトリ上のパスをコピー
if executable('svn_path_copy')
  command! SvnPathCopy silent call vimproc#system_bg('svn_path_copy '.expand("%"))
endif

" LoadYAML
command! -nargs=1 LoadYAML echo s:my_load_yaml(<args>)
function! s:my_load_yaml(file) "{{{
  perl << EOF
use YAML::Syck;
use JSON::Syck qw(Dump);
eval {
  VIM::DoCommand("let ret = " . Dump(LoadFile("".VIM::Eval('a:file'))));
};
VIM::DoCommand("let v:errmsg = substitute('$@', \"\\n\", '', 'g')") if $@;
EOF
  if !exists('ret')
    throw v:errmsg
  endif
  return ret
endfunction "}}}

" Diff {{{2
" DF
command! -nargs=0 DF windo diffthis | wincmd w | noh | exe "normal! ]c"
" diff
au myvimrc FilterWritePost * call s:my_diff()
function! s:my_diff() "{{{
  if &diff
    setl virtualedit=all
    " autocmd中はnohは効かない
    "noh
    " TODO: normal ]cが効かない…
    " exe 'normal! ]c'
  endif
endfunction "}}}
" DFOff
command! -nargs=0 DFOff call s:my_diffoff()
au myvimrc BufWinLeave * call s:my_diffoff()
function! s:my_diffoff() "{{{
  setl virtualedit&
  if &diff
    windo diffoff
    set foldmethod=marker
    wincmd w
  endif
endfunction "}}}
" DiffWith
command! -complete=file -nargs=1 DiffWith vertical diffsplit <args>
" DiffOrig（編集前とdiff）
command! -nargs=0 DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis

" 別ウィンドウ系 {{{2
" SnipEdit
command! -nargs=? -complete=customlist,neosnippet#commands#_edit_complete SnipEdit NeoSnippetEdit -vertical -split <args>
" Vimdoc
command! Vimdoc OpenBrowser http://vim-jp.org/vimdoc-ja/
" Cygwin
command! Cygwin call s:my_cygwin()
function! s:my_cygwin() "{{{
  let my_conque_term = conque_term#open($CYGWIN_HOME . '\Cygwin.bat', ['topleft split', 'resize 10'])
  while my_conque_term.read() == ''
  endwhile
  call my_conque_term.writeln('cd ' . MyGetCygwinDir(getcwd()))
endfunction "}}}
function! MyGetCygwinDir(fullpath) "{{{
  return "/cygdrive/" . substitute(a:fullpath, ':', '', '')
endfunction "}}}

" カラーリング {{{2
" Syn
command! Syn call s:get_syn_info()
function! s:get_syn_id(transparent) "{{{
  let synid = synID(line("."), col("."), 1)
  if a:transparent
    return synIDtrans(synid)
  else
    return synid
  endif
endfunction
function! s:get_syn_attr(synid)
  let name = synIDattr(a:synid, "name")
  let ctermfg = synIDattr(a:synid, "fg", "cterm")
  let ctermbg = synIDattr(a:synid, "bg", "cterm")
  let guifg = synIDattr(a:synid, "fg", "gui")
  let guibg = synIDattr(a:synid, "bg", "gui")
  return {
        \ "name": name,
        \ "ctermfg": ctermfg,
        \ "ctermbg": ctermbg,
        \ "guifg": guifg,
        \ "guibg": guibg}
endfunction
function! s:get_syn_info()
  let baseSyn = s:get_syn_attr(s:get_syn_id(0))
  echo "name: " . baseSyn.name .
        \ " ctermfg: " . baseSyn.ctermfg .
        \ " ctermbg: " . baseSyn.ctermbg .
        \ " guifg: " . baseSyn.guifg .
        \ " guibg: " . baseSyn.guibg
  let linkedSyn = s:get_syn_attr(s:get_syn_id(1))
  echo "link to"
  echo "name: " . linkedSyn.name .
        \ " ctermfg: " . linkedSyn.ctermfg .
        \ " ctermbg: " . linkedSyn.ctermbg .
        \ " guifg: " . linkedSyn.guifg .
        \ " guibg: " . linkedSyn.guibg
endfunction "}}}
" Colortest
command! Colortest belowright vsplit $VIMRUNTIME/syntax/colortest.vim | source $VIMRUNTIME/syntax/colortest.vim
" Hitest
command! Hitest belowright vsplit $VIMRUNTIME/syntax/hitest.vim | source $VIMRUNTIME/syntax/hitest.vim

" 共通ファンクション {{{2
" vital {{{3
" vital読み込むと後続の設定がおかしくなるのでvimrcでは直接使わない
" let s:V = vital#of('vital')

" パス変換 {{{3
function! s:my_path_convert(path) "{{{
  if has('win32') || has('win64')
    let system_enc = 'cp932'
    let path_separater = '\\\\'
  else
    let system_enc = 'utf-8'
    let path_separater = '/'
  endif

  let path = iconv(a:path, &encoding, system_enc)
  return substitute(path, '/', path_separater, 'g')
endfunction "}}}

" 非同期実行 {{{3
command! -nargs=+ MyVimprocAsync call s:my_vimproc_async({'cmd': <q-args>})
augroup my-vimproc-async
augroup END
function! s:my_vimproc_async(args) "{{{
  let cmd = a:args.cmd
  let callback = get(a:args, 'callback', 's:my_vimproc_finish')

  let vimproc = vimproc#pgroup_open(cmd)
  echom "[INFO] my vimproc async started. pid: " . vimproc.pid . ", cmd: " . cmd
  call vimproc.stdin.close()

  let s:vimproc = vimproc
  let s:result = ""

  augroup my-vimproc-async
    execute 'au! CursorHold,CursorHoldI * call'
    \       's:my_vimproc_receive_result("' . callback . '")'
  augroup END
endfunction "}}}
function! s:my_vimproc_receive_result(callback) "{{{
  if !has_key(s:, "vimproc")
    return
  endif

  let vimproc = s:vimproc

  try
    if !vimproc.stdout.eof
      let s:result .= vimproc.stdout.read()
    endif

    if !vimproc.stderr.eof
      let s:result .= vimproc.stderr.read()
    endif

    if !(vimproc.stdout.eof && vimproc.stderr.eof)
      return 0
    endif
  catch
    echom v:throwpoint
  endtry

  echom "[INFO] my vimproc async finished. pid: " . vimproc.pid . ", callback: " . a:callback
  let MyVimprocAsyncCallback = function(a:callback)
  call MyVimprocAsyncCallback(s:result)

  augroup my-vimproc-async
    au!
  augroup END

  call vimproc.stdout.close()
  call vimproc.stderr.close()
  call vimproc.waitpid()
  unlet s:vimproc
  unlet s:result
endfunction "}}}
function! s:my_vimproc_finish(result) "{{{
  call s:my_notify(a:result)
endfunction "}}}

" 通知 {{{3
function! s:my_notify(message) "{{{
  if has('mac') && executable('terminal-notifier')
    call vimproc#system_bg('terminal-notifier -message "' . a:message . '"')
  else
    echo a:message
  endif
endfunction "}}}

" キーマップ定義 {{{1
" 説明 {{{2
" map系はリンク先のコマンドを再帰的に展開する。
" noremap系はリンク先のコマンドを再帰的に展開しない。
" -----------------------------------------------------------------------------------"
"  コマンド        | n | i | c | v | s | o |
" -----------------|---|---|---|---|---|---|
"  map  / noremap  | @ | - | - | @ | @ | @ |
"  nmap / nnoremap | @ | - | - | - | - | - |
"  vmap / vnoremap | - | - | - | @ | @ | - |
"  omap / onoremap | - | - | - | - | - | @ |
"  xmap / xnoremap | - | - | - | @ | - | - |
"  smap / snoremap | - | - | - | - | @ | - |
"  map! / noremap! | - | @ | @ | - | - | - |
"  imap / inoremap | - | @ | - | - | - | - |
"  cmap / cnoremap | - | - | @ | - | - | - |
"  コマンド | ノーマル | 挿入 | コマンドライン | ビジュアル | 選択 | 演算待ち |
" -----------------------------------------------------------------------------------"
" 基本的にはnoremap系を使用する。
"   カーソル移動 => nnoremap
"   範囲選択     => vnoremap & onoremap
"     ビジュアルモードだけでセレクトモードを除くならxnoremp
"   テキスト入力補助 => inoremap
"   機能呼び出し => cnoremap
" <Nop>をリンク先に指定することでキーマップを無効にする。
" KEYMAP:
" 移動 {{{2
" 表示行単位で行移動
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap gj j
nnoremap gk k
vnoremap gj j
vnoremap gk k
" 先頭末尾で行移動
nnoremap <expr> h virtcol('.') == 1 ? 'k$' : 'h'
nnoremap <expr> l virtcol('.') == virtcol('$') - 1 ? 'j^' : 'l'
" 0/^のトグル
nnoremap <expr> 0 match(getline("."), '\S') == col(".") - 1 ? '0' : match(getline("."), '^\s*$') >= 0 ? '0' : '^'
nnoremap <expr> ^ match(getline("."), '\S') == col(".") - 1 ? '0' : match(getline("."), '^\s*$') >= 0 ? '0' : '^'
vnoremap <expr> 0 match(getline("."), '\S') == col(".") - 1 ? '0' : match(getline("."), '^\s*$') >= 0 ? '0' : '^'
vnoremap <expr> ^ match(getline("."), '\S') == col(".") - 1 ? '0' : match(getline("."), '^\s*$') >= 0 ? '0' : '^'
" markへのジャンプ
nnoremap gm `
" diffハンクへのジャンプ
nnoremap g[ [czz
nnoremap g] ]czz
nnoremap do do]czz
nnoremap dp dp]czz
" 折り畳み
nnoremap z] zj^
nnoremap z[ [z^
" インデント
nnoremap <silent> zj :<C-u>call<Space><SID>my_indent_move(1, 0)<CR>
nnoremap <silent> zk :<C-u>call<Space><SID>my_indent_move(0, 0)<CR>
nnoremap <silent> zJ :<C-u>call<Space><SID>my_indent_move(1, 1)<CR>
nnoremap <silent> zK :<C-u>call<Space><SID>my_indent_move(0, 1)<CR>
function! s:my_indent_move(isForward, isCursurLevel) "{{{
  echo ''
  let lnum = getcurpos()[1]
  if a:isCursurLevel
    let level = getcurpos()[2]
  else
    let level = match(getline(lnum), '\S') + 1
    if level == 0
      let level += 1
    endif
  endif

  if a:isForward
    let lnum += 1
  else
    let lnum -= 1
  endif
  while level < match(getline(lnum), '\S') + 1 || match(getline(lnum), '\S') == -1
    if a:isForward
      let lnum += 1
    else
      let lnum -= 1
    endif
    if lnum <= 0 || lnum >= getpos('$')[1]
      break
    endif
  endwhile

  if level == match(getline(lnum), '\S') + 1
    exe 'normal! ' . lnum . 'G'
  else
    echohl WarningMsg
    echo 'no match indent'
    echohl None
  endif
endfunction "}}}

" 検索 {{{2
" 検索語が真ん中にくるようにする
nmap n <Plug>(anzu-n)zVzz
nmap N <Plug>(anzu-N)zVzz
noremap * *zvzz
" #でも検索方向を揃える
noremap # *NNzvzz
noremap g* g*zvzz
noremap g# g#zvzz
noremap { {zz
noremap } }zz
" 選択した単語で検索
vnoremap / y/<C-r>"
vnoremap ? y?<C-r>"
vmap * <Plug>(visualstar-*)zVzz
vmap # <Plug>(visualstar-*)NNzVzz

" ウィンドウ／タブ {{{2
" バッファ移動用キーマップ
" nnoremap <Tab> <Esc>:MBEbn<CR>
" nnoremap <S-Tab> <Esc>:MBEbp<CR>
" タブページ操作
nnoremap L <C-PageDown>
nnoremap H <C-PageUp>
nnoremap ,t :<C-u>$tabnew<CR>
nnoremap ,l :<C-u>tabm<CR>
nnoremap ,L :<C-u>tabm 1<CR>
" gfはタブで開く
nnoremap gf :tab drop <cfile><CR>
vnoremap gf y:tab drop <C-r>"<CR>
" gFでカウンターパートを開く
nnoremap gF :exe 'tab drop ' . MyGetCounterpart()<CR>
function! MyGetCounterpart() "{{{
  let path = expand('%:h')
  let fname = expand('%:t')
  if fname =~ '^test_'
    let counterpart = substitute(path, '^test/', '', '') . '/' . substitute(fname, '^test_', '', '')
    if filereadable('src/' . counterpart)
      return 'src/' . counterpart
    elseif filereadable('lib/' . counterpart)
      return 'lib/' . counterpart
    else
      return counterpart
    endif
  else
    let test_path = 'test/' . substitute(path, '^\(src\|lib\)/', '', '')
    if ! isdirectory(test_path)
      call mkdir(test_path, 'p')
    endif
    return test_path . '/test_' . fname
  endif
endfunction "}}}
" ウィンドウサイズ変更
nnoremap <S-Up> <C-w>+
nnoremap <S-Down> <C-w>-
nnoremap <S-Left> <C-w><
nnoremap <S-Right> <C-w>>
" QuickFix、fugitiveでは<Esc><Esc>でバッファを閉じる
au myvimrc FileType qf,gitcommit nnoremap <buffer> <Esc><Esc> <C-w>c
" qでウィンドウを閉じる、マクロはQ（EXモードは使わない）
nnoremap q :<C-u>q<CR>
nnoremap Q q
" タブ番号指定
let s:tabnr = 1
while s:tabnr < 10
  exe 'nnoremap ,'.s:tabnr.' :tabn '.s:tabnr.'<CR>'
  let s:tabnr = s:tabnr + 1
endwhile
nnoremap ,0 :tabl<CR>

" タグジャンプ {{{2
nnoremap <C-]> g<C-]>
vnoremap <C-]> g<C-]>
nnoremap ,] g<C-]>
vnoremap ,] g<C-]>
nnoremap <C-j> :tab tj <C-r><C-w><CR>
vnoremap <C-j> y:tab tj <C-r>"<CR>
nnoremap ,[ <C-t>
nnoremap <C-k> <C-t>
nnoremap <C-h> <C-o>
nnoremap <C-l> <C-i>

" ノーマルモード {{{2
" ;を:にマップする
nnoremap ; :
" 画面下で再描画
nnoremap z<S-CR> z-
" 行末までヤンク
nnoremap Y yg_
" カーソル位置から末尾までビジュアル選択
nnoremap ,v vg_
" 直前に変更またはヤンクした文字を選択
nnoremap gp `[v`]
" ペースト後末尾に移動
nnoremap p p`]
nnoremap P P`]
" PASTEモードでクリップボード貼り付け
nnoremap ,p :<C-u>set paste<CR>a<C-r>+<Esc>:<C-u>set nopaste<CR>`]
nnoremap ,P :<C-u>set paste<CR>i<C-r>+<Esc>:<C-u>set nopaste<CR>`]
" すべてのフォールディングの開け閉め
nnoremap <silent> zO :FastFoldUpdate<CR>zR
nnoremap <silent> zC :FastFoldUpdate<CR>zMzz
nnoremap <silent> zv :FastFoldUpdate<CR>zozczO
" <Plug>マッピングのためzvを退避
nnoremap <silent> zV :FastFoldUpdate<CR>zv
nnoremap <silent> zo :FastFoldUpdate<CR>zv
nnoremap <silent> zc :FastFoldUpdate<CR>zczz
" 水平スクロール
nnoremap zh 4zh4zh4zh4zh4zh4zh
nnoremap zl 4zl4zl4zl4zl4zl4zl
nnoremap zH zh
nnoremap zL zl
" デフォルトアプリで開く
let g:netrw_nogx = 1 " disable netrw's gx mapping.
nnoremap gx :<C-u>call vimproc#open(escape('<C-r><C-w>', ' \'))<CR>
vnoremap gx y:<C-u>call vimproc#open(escape('<C-r>"', ' \'))<CR>
" Webで検索する
map gX <Plug>(openbrowser-smart-search)
" Esc+noh+ZoomReset
if has('gui_running')
  nnoremap <silent> <Esc> <Esc>:<C-u>Noh<CR>:<C-u>ZoomReset<CR>:<C-u>echo<CR>
endif
" CopyFileName
nnoremap gy :<C-u>CopyFileName<CR>
nnoremap gY :<C-u>MyCopyPath<CR>
command! -nargs=0 MyCopyPath call s:my_copy_path()
function! s:my_copy_path()
  let path = expand('%:p')
  if has('win32') || has('win64')
    let path = substitute(path, '/', '\\', 'g')
  endif
  let @* = path
endfunction
" 行の最後ならxで後方削除
nnoremap <expr> x virtcol(".") == virtcol("$") ? 'X' : 'x'

" ビジュアルモード {{{2
" ヤンク後末尾に移動
vnoremap y y`]
" 選択文字を削除してインサートモードを開始する
" （ただし<C-i>＝<Tab>であることは注意）
vnoremap <C-i> c

" オペレータ {{{2

" replace
map c <Plug>(operator-replace)
map C <Plug>(operator-replace)$
" カーソル下の文字列を置換
nnoremap ,c :%s/\<<C-r><C-w>\>//gc<Left><Left><Left>
" 選択した文字列を置換
vnoremap ,c "xy:%s/<C-r>=escape(@x, '\\/.*$^~[]')<CR>//gc<Left><Left><Left>

" surround
map s <Plug>(operator-surround-append)
let g:operator#surround#enable_xbrackets_mode = 1 " 定義済みブロックが現れるまでテキスト保持

" snake_case<=>CamelCase
vmap _ <Plug>(operator-camelize-toggle)

" 反転
vmap R <Plug>(operator-reverse-text)

" HTMLエスケープ
vmap <C-@>; <Plug>(operator-html-escape)

" パス置換
vmap <C-@>/ <Plug>(operator-path-convert)
cmap <C-@>/ <C-\>eMyCmdlinePathConvert()<CR>
call operator#user#define('path-convert', 'MyOpPathConvert')
function! MyOpPathConvert(motion_wiseness) "{{{
  '[,']s/\//\\/g
endfunction "}}}
function! MyCmdlinePathConvert() "{{{
  return substitute(getcmdline(), '\/', '\\', 'g')
endfunction "}}}

" URLエンコード
vmap <C-@>% <Plug>(operator-url-encode)
call operator#user#define('url-encode', 'Op_url_encode')
function! Op_url_encode(motion_wise) "{{{
  let visual_command = s:visual_command_from_wise_name(a:motion_wise)

  let put_command = (s:deletion_moves_the_cursor_p(
  \                    a:motion_wise,
  \                    getpos("']")[1:2],
  \                    len(getline("']")),
  \                    [line('$'), len(getline('$'))]
  \                  )
  \                  ? 'p'
  \                  : 'P')

  let @x = ''
  if !s:is_empty_region(getpos("'["), getpos("']"))
    let original_selection = &g:selection
    let &g:selection = 'inclusive'
    execute 'normal!' '`['.visual_command.'`]"xd'
    let &g:selection = original_selection
    let @x = webapi#http#encodeURI(@x)
  end
  execute 'normal! "x'.put_command
  return
endfunction "}}}

" ひらがなカタカナ変換
vmap ~ <Plug>(operator-hirakana)
call operator#user#define('hirakana', 'Op_hirakana')
function! Op_hirakana(motion_wise) "{{{
  let visual_command = s:visual_command_from_wise_name(a:motion_wise)

  let put_command = (s:deletion_moves_the_cursor_p(
  \                    a:motion_wise,
  \                    getpos("']")[1:2],
  \                    len(getline("']")),
  \                    [line('$'), len(getline('$'))]
  \                  )
  \                  ? 'p'
  \                  : 'P')

  let @x = ''
  if !s:is_empty_region(getpos("'["), getpos("']"))
    let original_selection = &g:selection
    let &g:selection = 'inclusive'
    execute 'normal!' '`['.visual_command.'`]"xd'
    let &g:selection = original_selection

    let value = ''
    for ch in split(@x, '.\zs')
      let nr = char2nr(ch)
      if char2nr('a') <= nr && nr <= char2nr('z')
        let value .= nr2char(nr + (char2nr('A') - char2nr('a')))
      elseif char2nr('A') <= nr && nr <= char2nr('Z')
        let value .= nr2char(nr + (char2nr('a') - char2nr('A')))
      elseif char2nr('ぁ') <= nr && nr <= char2nr('ゔ')
        let value .= nr2char(nr + (char2nr('ア') - char2nr('あ')))
      elseif char2nr('ァ') <= nr && nr <= char2nr('ヴ')
        let value .= nr2char(nr + (char2nr('あ') - char2nr('ア')))
      else
        let value .= ch
      endif
    endfor

    let @x = value
  end
  execute 'normal! "x'.put_command
  return
endfunction "}}}

" ヘルパーファンクション
function! s:deletion_moves_the_cursor_p(motion_wise, motion_end_pos, motion_end_last_col, buffer_end_pos) "{{{
  let [buffer_end_line, buffer_end_col] = a:buffer_end_pos
  let [motion_end_line, motion_end_col] = a:motion_end_pos
  if a:motion_wise ==# 'char'
    return ((a:motion_end_last_col == motion_end_col)
    \       || (buffer_end_line == motion_end_line
    \           && buffer_end_col <= motion_end_col))
  elseif a:motion_wise ==# 'line'
    return buffer_end_line == motion_end_line
  elseif a:motion_wise ==# 'block'
    return 0
  else
    echoerr 'E2: Invalid wise name:' string(a:wise_name)
    return 0
  endif
endfunction "}}}
function! s:is_empty_region(begin, end) "{{{
  " Whenever 'operatorfunc' is called, '[ is always placed before '] even if
  " a backward motion is given to g@.  But there is the only one exception.
  " If an empty region is given to g@, '[ and '] are set to the same line, but
  " '[ is placed after '].
  return a:begin[1] == a:end[1] && a:end[2] < a:begin[2]
endfunction "}}}
function! s:visual_command_from_wise_name(wise_name) "{{{
  if a:wise_name ==# 'char'
    return 'v'
  elseif a:wise_name ==# 'line'
    return 'V'
  elseif a:wise_name ==# 'block'
    return "\<C-v>"
  else
    echoerr 'E1: Invalid wise name:' string(a:wise_name)
    return 'v'  " fallback
  endif
endfunction "}}}

" インサートモード {{{2
" 移動
inoremap <expr> <C-a> match(getline("."), '\S') == col(".") - 1 ? '<Home>' : match(getline("."), '\S') == 0 ? '<Home>' : '<Home><S-Right>'
inoremap <C-e> <End>
inoremap <expr> <C-h> col('.') == 1 ? '<Up><End>' : '<Left>'
inoremap <expr> <C-l> col('.') == col('$') ? '<Down><Home>' : '<Right>'
inoremap <C-b> <S-Left>
inoremap <C-w> <S-Right>
inoremap <C-j> <Down>
inoremap <C-k> <Up>
inoremap <S-CR> <C-o>O
inoremap <C-@><CR> <C-o>:SplitjoinSplit<CR><Down><Home>
" 文字削除（NeoCompleteで設定するためコメントアウト）
" inoremap <C-d> <Del>
" CTRL-Uのundo対策（from exaple.vim）
inoremap <C-u> <C-g>u<C-u>
" 日時の挿入
inoremap <expr> <C-@>; strftime('%Y/%m/%d')
inoremap <expr> <C-@>: strftime('%H:%M:%S')
cnoremap <C-@>; <C-r>=strftime('%Y%m%d')<CR>
cnoremap <C-@>: <C-r>=strftime('%H%M%S')<CR>
" インデント（NeoCompleteで設定するためコメントアウト）
" inoremap <Tab> <C-t>
" inoremap <S-Tab> <C-d>
" YankRound
inoremap <C-@>y <C-o>:CtrlPYankRound<CR>
nnoremap ,y :CtrlPYankRound<CR>

" エンドワイズ {{{2
inoremap ( ()<Left>
inoremap <expr> ) match(getline("."), '()', col(".") - 2) == abs(col(".") - 2) ? '<Right>' : ')'
inoremap [ []<Left>
inoremap <expr> ] match(getline("."), '[]', col(".") - 2) == abs(col(".") - 2) ? '<Right>' : ']'
inoremap <expr> { synIDattr(synID(line("."), col(".") - 1, 1), "name") =~? 'comment' ? '{' : '{}<Left>'
inoremap <expr> } match(getline("."), '{}', col(".") - 2) == abs(col(".") - 2) ? '<Right>' : '}'
inoremap <expr> ' match(getline("."), "\'\'", col(".") - 2) == abs(col(".") - 2) ? '<Right>' :
\                 strlen(substitute(getline("."), "\[^\'\]", "", "g")) % 2 == 1 ? "\'" : "\'\'<Left>"
inoremap <expr> " match(getline("."), '""', col(".") - 2) == abs(col(".") - 2) ? '<Right>' :
\                 or(match(strpart(getline("."), 0, col(".")), '\S') == -1,
\                    strlen(substitute(getline("."), '[^"]', "", "g")) % 2 == 1) ? '"' : '""<Left>'

" コマンドモード {{{2
" 移動
cnoremap <C-a> <Home>
cnoremap <C-h> <Left>
cnoremap <C-l> <Right>
cnoremap <C-w> <S-Left>
cnoremap <C-b> <S-Right>
" 文字削除
cnoremap <C-d> <Del>
" ヒストリ
cnoremap <C-n> <Down>
cnoremap <C-p> <Up>

" コマンド実行 {{{2
" リファレンス
nnoremap ,k :<C-u>Ref webdict <C-r><C-w><CR>
vnoremap ,k y:<C-u>Ref webdict <C-r>"<CR>
au myvimrc FileType vim,help nnoremap <buffer> ,h :<C-u>H<Space><C-r><C-w><CR>
au myvimrc FileType vim,help vnoremap <buffer> ,h y:<C-u>H<Space><C-r>"<CR>
au myvimrc FileType ruby nnoremap <buffer> ,h :<C-u>Ref<Space>refe<Space><C-r><C-w><CR>
au myvimrc FileType ruby vnoremap <buffer> ,h y:<C-u>Ref<Space>refe<Space><C-r>"<CR>
au myvimrc FileType javascript nnoremap <buffer> ,h :<C-u>Ref<Space>javascript<Space><C-r><C-w><CR>
au myvimrc FileType javascript vnoremap <buffer> ,h y:<C-u>Ref<Space>javascript<Space><C-r>"<CR>
au myvimrc FileType sh nnoremap <buffer> ,h :<C-u>Ref<Space>man<Space><C-r><C-w><CR>
au myvimrc FileType sh vnoremap <buffer> ,h y:<C-u>Ref<Space>man<Space><C-r>"<CR>
" QuickRun
nmap ,r <Plug>(quickrun)
nnoremap <silent> ,R :<C-u>call<Space>quickrun#run([{'type': &filetype . '.alt'}])<CR>
vnoremap ,R y:QuickRun -src '<C-r>"'<CR>
vnoremap ,r y:QuickInspector<CR>
command! QuickInspector :call s:my_quick_inspector()
function! s:my_quick_inspector() "{{{
  if !exists('*s:my_quick_inspector_'.&ft)
    echoerr 'not implemented whis this filetype.'
    return
  endif
  hi QuickInspector term=underline cterm=underline ctermfg=67
  \ gui=underline guifg=darkcyan
  let expr = substitute(getreg('"'), '\(\s\|\n\)\+$', '', '')
  echohl QuickInspector
  echo 'expr: '.expr
  echohl None
  exe 'echo s:my_quick_inspector_'.&ft.'(expr)'
  echo ''
endfunction "}}}
function! s:my_quick_inspector_vim(expr) "{{{
  return eval(a:expr)
endfunction "}}}
function! s:my_quick_inspector_ruby(expr) "{{{
  return vimproc#system('ruby -e '.shellescape('p '.a:expr))
endfunction "}}}
" EasyMotion
nmap f <Plug>(easymotion-bd-w)
vmap ,f <Plug>(easymotion-bd-w)
omap ,f <Plug>(easymotion-bd-w)
nmap F <Plug>(easymotion-s2)
vmap ,F <Plug>(easymotion-s2)
omap ,F <Plug>(easymotion-s2)
au myvimrc FileType unite,vimfiler,gitcommit nmap <buffer> f <Plug>(easymotion-j)
au myvimrc FileType unite,vimfiler,gitcommit nmap <buffer> F <Plug>(easymotion-k)

" トグル {{{2
" コメントアウトの切り替え（caw.vim）
nmap ,/ <Plug>(caw:hatpos:toggle)
vmap ,/ <Plug>(caw:hatpos:toggle)
" VimFiler
nnoremap ,f :<C-u>VimFilerBufferDir<Space>-buffer-name=vimfiler<Space>-split<Space>-simple<Space>-winwidth=30<Space>-force-quit<Space>-toggle<CR>
" VimShell
nnoremap ,s :<C-u>VimShellPop<Space>-create<Space>-buffer-name=vimshell<CR>
" nnoremap ,S :<C-u>VimShellTab<Space>-create<Space>-buffer-name=vimshell_tab<Space>$HOME<CR>
nnoremap ,S :<C-u>VimShellTab<Space>-create<Space>-buffer-name=vimshell_tab<CR>
" MBEToggle
nnoremap ,b :<C-u>MBEToggle<CR>
" TagbarToggle
nnoremap ,; :<C-u>TagbarToggle<CR>
" QFToggle
nnoremap ,. :<C-u>QFToggle<CR>
command! QFToggle :call s:my_qf_toggle()
function! s:my_qf_toggle() "{{{
  let cur_win = winnr()
  windo if 'qf' == &ft | cclose | execute cur_win . "wincmd w" | return | endif
  execute cur_win . "wincmd w"
  botright cwindow 7
endfunction "}}}
" PreviewToggle
nnoremap ,, :<C-u>PreviewToggle<CR>zz
vnoremap ,, y:<C-u>call PreviewWord('<C-r>"')<CR>
command! PreviewToggle :call s:my_preview_toggle()
function! s:my_preview_toggle() "{{{
  silent! wincmd P
  if &previewwindow
    "au! Cursorhold
    pclose
  else
    "au! CursorHold * nested call PreviewWord()
    call PreviewWord()
  endif
endfunction
function! PreviewWord(...)
  " 設定
  let direction = "belowright"
  let height = 7
  let action = "ptjump"
  "hi PreviewWord term=bold ctermfg=black ctermbg=lightgreen guifg=black guibg=lightgreen
  hi link PreviewWord Search

  if &previewwindow			" プレビューウィンドウ内では実行しない
    return
  endif
  let w = a:0 == 0 ? expand("<cword>") : a:1		" カーソル下の単語を得る
  "if w =~ '\a'			" その単語が文字を含んでいるなら
  if w !~ '\s'			" その単語が文字を含んでいるなら

    " 別のタグを表示させる前にすでに存在するハイライトを消去する
    silent! wincmd P			" プレビューウィンドウにジャンプ
    if &previewwindow			" すでにそこにいるなら
      match none			" 存在するハイライトを消去する
      wincmd p			" もとのウィンドウに戻る
    endif

    " カーソル下の単語にマッチするタグを表示してみる
    try
       exe direction action w
    catch
      echohl ErrorMsg
      echo substitute(v:exception, '^Vim\%((\a\+)\)\=:', '', "")
      echohl None
      return
    endtry

    silent! wincmd P			" プレビューウィンドウにジャンプ
    if &previewwindow		" すでにそこにいるなら
      if has("folding")
        silent! .foldopen		" 閉じた折り畳みを開く
      endif
      exe "resize" height
      exe "normal! zz"
      call search("$", "b")		" 前の行の最後へ
      let w = substitute(w, '\\', '\\\\', "")
      call search('\<\V' . w . '\>')	" カーソルをマッチしたところへ
      " ここで単語にハイライトをつける
      exe 'match PreviewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
      wincmd p			" もとのウィンドウへ戻る
    endif
  endif
endfunction "}}}
" GundoToggle
nnoremap ,u :<C-u>GundoToggle<CR>
" QuickhlToggle
map ,<Space> <Plug>(quickhl-manual-this)
map ,<S-Space> <Plug>(quickhl-manual-reset)
" ShowMarks
nmap ,m :<C-u>ShowMarksToggle<CR>

" 無効化、退避 {{{2
" 保存して閉じる
nnoremap ZZ <Nop>
" 保存せずに閉じる
nnoremap ZQ <Nop>
" imap/cmapのマップリーダにするため、無効化
inoremap <C-@> <Nop>
" 退避
nnoremap <F2><C-g> <C-g>
nnoremap <F2>[[ [[
nnoremap <F2>]] ]]
inoremap <F2><C-a> <C-a>
inoremap <F2><C-e> <C-e>
inoremap <F2><C-w> <C-w>
inoremap <F2><C-b> <C-b>
inoremap <F2><C-u> <C-u>
cnoremap <F2><C-a> <C-a>
cnoremap <F2><C-w> <C-w>
cnoremap <F2><C-b> <C-b>
cnoremap <F2><C-n> <C-n>
cnoremap <F2><C-p> <C-p>

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" Plugin設定
"-----------------------------------------------------------------------------
" Unite {{{1
" 説明 {{{2
" COMMAND:
"  :Unite ${source} [${option}]
"  :Unite output:{コマンド名}
" KEYMAP:
"  <Tab> : Actionを開く
"  <Space> : 候補を選択する
"  * : 候補を全選択する
"  a : 候補でActionを開く
"  ? : Uniteのキーマップを表示

" Uniteコマンド定義 {{{2
" 汎用
command! -nargs=+ -complete=customlist,unite#complete#source U Unite <args>
\ -no-empty -silent -buffer-name=<args>

" 現在のバッファ内をグレップ
command! Ug Unite grep:%
\ -no-empty -silent -buffer-name=grep
" カーソル下の単語で現在のバッファをグレップ
command! Ugw exe 'Unite grep:%::' .
\ escape(expand("<cword>"), '- \\') .
\ ' -no-empty -silent -buffer-name=grep-word'
" ディレクトリをグレップ
command! Ugd exe 'Unite grep' .
\ ' -silent -buffer-name=grep-dir' .
\ ' -tab -no-split -no-quit'
\ | setlocal splitbelow | exe 'normal <Plug>(unite_toggle_auto_preview)'
" すべてのバッファをグレップ
command! Ugb exe 'Unite grep:$buffers' .
\ ' -silent -buffer-name=grep-all-bufs' .
\ ' -tab -no-split -no-quit
\ | setlocal splitbelow | exe 'normal <Plug>(unite_toggle_auto_preview)'

" ブックマーク（追加はUniteBookmarkAdd）
command! Ub Unite bookmark
\ -no-empty -silent -buffer-name=bookmark
" ブックマーク追加
command! Uba UniteBookmarkAdd
" ブックマーク手動編集
command! Ube edit $HOME/.unite/bookmark/default
" メニュー
command! Um Unite menu:shortcuts
\ -no-empty -silent -buffer-name=menushortcuts

" リファレンス参照
" ref
command! UR Unite ref
\ -no-empty -silent -buffer-name=ref
" refe
command! URr Unite ref/refe
\ -no-empty -silent -buffer-name=ref/refe
" カーソル下の単語でrefe
command! URrw exe 'Unite ref/refe ' .
\ '-no-empty -silent -buffer-name=ref/refe -input=' .
\ escape(expand("<cword>"), '- \\')
" ri
command! URri Unite ref/ri
\ -no-empty -silent -buffer-name=ref/ri

" ファイル
" file_rec
command! Uf Unite file_rec
\ -no-empty -silent -buffer-name=files

" 直前のUniteコマンドの結果に戻る
command! Ur UniteResume
\ -no-empty -silent
" スニペット候補の表示
command! Usnip Unite neosnippet
\ -no-empty -silent -buffer-name=neosnippet
" マッピング表示
command! Umap :Unite output:map|map!|lmap
\ -no-empty -silent -buffer-name=output:map

" 基本設定（以降はon_source） {{{2
function! MyDeinHookUnite() abort
" 入力モードで開始しない
let g:unite_enable_start_insert = 0
" 最近使ったファイルの履歴数
let g:unite_source_file_mru_file = 200
" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
" ステータスラインを上書きしない（lightline向け）
let g:unite_force_overwrite_statusline = 0
" ウィンドウの高さ
let g:unite_winheight = 10
" プロンプト文字
let g:unite_prompt = 'Unite>>> '
" カーソルラインのハイライト
let g:unite_cursor_line_highlight = 'MatchParen'
" unite grep に ag(The Silver Searcher) を使う
if executable('ag')
 let g:unite_source_grep_command = 'ag'
 let g:unite_source_grep_default_opts =
 \ '--line-numbers --nocolor --nogroup --smart-case --hidden ' .
 \ '--ignore ''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
 let g:unite_source_grep_recursive_opt = ''
endif

" キーマップ定義 {{{2
au myvimrc FileType unite call MyUniteKeymaps()
function! MyUniteKeymaps() "{{{
  " <C-j>/<C-k>で選択カーソル移動
  nmap <silent> <buffer> <C-j> <Plug>(unite_loop_cursor_down)
  imap <silent> <buffer> <C-j> <Plug>(unite_select_next_line)
  nmap <silent> <buffer> <C-k> <Plug>(unite_loop_cursor_up)
  imap <silent> <buffer> <C-k> <Plug>(unite_select_previous_line)
  " <C-h>/<C-l>で入力カーソル移動、<C-d>で削除
  inoremap <buffer> <C-h> <Left>
  inoremap <buffer> <C-l> <Right>
  imap <expr> <buffer> <C-d> virtcol(".") == virtcol("$") ? "\<BS>" : "\<Del>"
  " ESCキーを2回押すと終了する
  nmap <silent> <buffer> <Esc><Esc> <Plug>(unite_all_exit)
  " 入力文字が無い時に<BS>で前の画面に戻る
  imap <expr> <silent> <buffer> <BS> unite#helper#get_input() == '' ? "\<Plug>(unite_exit)" : "\<BS>"
  nmap <silent> <buffer> <BS> <Plug>(unite_exit)
  " キャッシュ更新
  nmap <silent> <buffer> <F5> <Plug>(unite_redraw)
  " pでオートプレビューのトグル
  nmap <silent> <buffer> p <Plug>(unite_toggle_auto_preview))
endfunction "}}}

" Unite menu {{{2
let g:unite_source_menu_menus = {
\ 'shortcuts': {
\   'description': 'command shortcuts.',
\   'command_candidates': [
\     ['[help] themis-quickref', 'H themis-quickref'],
\     ['[help] vim-regexp', 'H pattern-overview'],
\     ['[help] functions', 'H function-list'],
\     ['[help] registers', 'H registers'],
\     ['[help] map-overview', 'H map-overview'],
\     ['[help] vim-script', 'H usr_41.txt'],
\     ['[help] quickref-alpha', 'H index.txt'],
\     ['[help] quickref', 'H quickref.txt'],
\     ['[help] vim-goal', 'H design-goal'],
\     ['[unite] colorscheme', 'Unite colorscheme -auto-preview'],
\     ['[unite] output:message', 'Unite output:message'],
\     ['[unite] mapping(all)', 'Unite output:map|map!|lmap'],
\     ['[dein] clean plugins', 'for s:dein_clean_plugin in dein#check_clean() | call delete(s:dein_clean_plugin, "rf") | endfor'],
\   ],
\ },
\}

" デフォルトアクションの変更 {{{2
" openable
call unite#custom_default_action('file', 'tabopen')
" directory
call unite#custom_default_action('directory', 'vimfiler')
" ref
call unite#custom_default_action(
\ 'source/ref/refe/*,source/ref/ri/*,source/ref/javascript/*,source/ref/jquery/*,source/ref/man/*',
\ 'vsplit')
" help
call unite#custom_default_action('source/help/*', 'vsplit')

" アクションの追加 {{{2
" source:mappingにaction:verboseを追加する
let s:action = {
\ 'description': 'verbose',
\ 'is_selectable': 1,
\}
function! s:action.func(candidates)
  for candidate in a:candidates
    execute "verbose map" substitute(candidate.action__mapping, '\\\(<.*>\)', '\1', "g")
  endfor
endfunction
" kind ではなくて source の mapping に対して action を設定する
call unite#custom#action('source/mapping/*', 'verbose', s:action)
" preview（pキー）で action を実行したい場合は
" call unite#custom#action('source/mapping/*', 'preview', s:action)
unlet s:action

" Uniteソース {{{2
" ref {{{3
let s:unite_source = {
\   'name': 'ref',
\ }
function! s:unite_source.gather_candidates(args, context)
  return map(ref#available_source_names(), '{
  \   "word": v:val,
  \   "source": "ref",
  \   "kind": "source",
  \   "action__source_name": "ref/" . v:val,
  \ }')
endfunction
call unite#define_source(s:unite_source)
unlet s:unite_source
" サンプル {{{3
let s:unite_source = {
\   'name': 'lines',
\ }
function! s:unite_source.gather_candidates(args, context)
  let path = expand('%:p')
  let lines = getbufline('%', 1, '$')
  let format = '%' . strlen(len(lines)) . 'd: %s'
  return map(lines, '{
  \   "word": printf(format, v:key + 1, v:val),
  \   "source": "lines",
  \   "kind": "jump_list",
  \   "action__path": path,
  \   "action__line": v:key + 1,
  \ }')
endfunction
call unite#define_source(s:unite_source)
unlet s:unite_source

" （on_source終わり） {{{2
endfunction

" VimFiler {{{1
"
" KEYMAP:
"  h : up dir, l : down dir, t : tree view (1 dir), T : tree view all
"  e : edit, <Space> : mark, c : copy, m : move, d : delete, yy : yank path
"  N : new file, K : new dir, * : mark all, U : mark off all, ? : keymap
"  a : action, H : VimShell, ge : system filer, x : system app
"
" vimデフォルトのエクスプローラをvimfilerで置き換える
let g:vimfiler_as_default_explorer = 1
" セーフモードを無効にした状態で起動する
let g:vimfiler_safe_mode_by_default = 0
" ディレクトリ移動
let g:vimfiler_enable_auto_cd = 1
" タブで開く
let g:vimfiler_edit_action = 'tabopen'
" デフォルトでIDE風のFilerを開く
" au myvimrc VimEnter * VimFiler -split -simple -winwidth=30 -no-quit
" ステータスラインを上書きしない（lightline向け）
"let g:vimfiler_force_overwrite_statusline = 0
"let g:netrw_liststyle=3
" キーマップ定義
au myvimrc FileType vimfiler call MyVimfilerKeymaps()
function! MyVimfilerKeymaps() "{{{
  " Enterでツリー開閉、ファイル編集を可能に
  nmap <buffer> <expr> <CR> vimfiler#smart_cursor_map("\<Plug>(vimfiler_expand_tree)", "\<Plug>(vimfiler_edit_file)")
  " ESCキーを2回押すと終了する
  nnoremap <silent> <buffer> <Esc><Esc> :q<CR>
  " キーマップヘルプを表示
  nnoremap <buffer> ,h :MyVimFilerHelp<CR>
  " システムハンドラで開く
  nmap <buffer> gx <Plug>(vimfiler_execute_system_associated)
endfunction "}}}
command! MyVimFilerHelp :call MyVimfilerHelp()
function! MyVimfilerHelp() "{{{
  silent! wincmd P
  if &previewwindow
    pclose
    return
  endif

  hi link MyVimFilerHelp Comment
  hi link MyVimFilerHelpTitle PreProc
  hi link MyVimFilerHelpKey Identifier
  belowright pedit $MYVIMDIR/doc/vimfiler_help.txt
  silent! wincmd P
  if &previewwindow
    match none
    setlocal nonumber
    resize 20
    exe "normal! gg"
    nnoremap <buffer> ,, :MyVimFilerHelp<CR>
    call matchadd('MyVimFilerHelp', '.', 0)
    call matchadd('MyVimFilerHelpTitle', '--.*')
    call matchadd('MyVimFilerHelpKey', '\(.\+\):')
    wincmd p
  endif
endfunction "}}}

" VimShell {{{1
" VimShellPopの開き方
let g:vimshell_popup_command = 'botright 10split'
" vimコマンドで開いた時の開き方
let g:vimshell_split_command = 'tabe'
" 動的プロンプト
let g:vimshell_prompt_expr = 'getcwd()." > "'
let g:vimshell_prompt_pattern = '^\f\+ > '
" エディタコマンド指定
let g:vimshell_editor_command = 'mvim'
" VimShell独自のキーマッピングを使用する
let g:vimshell_no_default_keymappings = 0
" vimshell-inline-historyでコマンド履歴表示
let g:vimshell_inline_history#default_mappings = 0
" キーマップ定義
au myvimrc FileType vimshell call s:my_vimshell_keymapping()
function! s:my_vimshell_keymapping() "{{{
  nmap <buffer> <C-k> <Plug>(vimshell_previous_prompt)
  nmap <buffer> <C-j> <Plug>(vimshell_next_prompt)
  imap <buffer> <Up> <Plug>(vimshell_inline_history#prev)
  imap <buffer> <Down> <Plug>(vimshell_inline_history#next)
  inoremap <buffer> <C-h> <Left>
  inoremap <buffer> <C-l> <Right>
endfunction "}}}

" コマンド履歴の保存
let g:vimshell_data_directory = expand('~/.cache/vimshell')
" cdもコマンド履歴に残すようにする
let g:vimshell_no_save_history_commands = {}

" irbを非同期で起動
command! Irb VimShellInteractive irb
" 非同期で開いたインタプリタに現在の行を評価させる
command! VSSend VimShellSendString
command! VSAll %VimShellSendString

" NeoComplete {{{1
" 基本設定（以降はon_source）{{{2
function! MyDeinHookNeoComplete() abort
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use ignorecase.
let g:neocomplete#enable_ignore_case = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
" Use fuzzy completion.
let g:neocomplete#enable_fuzzy_completion = 1

" Define dictionary. {{{2
let g:neocomplete#sources#dictionary#dictionaries = {
\ 'default' : '',
\ 'vimshell' : $HOME.'/.cache/vimshell/command-history',
\ 'scheme' : $HOME.'/.gosh_completions',
\ 'html': $MYVIMDIR.'/dict/bootstrap.dict',
\ 'ruby': $MYVIMDIR.'/dict/pocke_dicts/ruby.dict',
\}

" Define keyword. {{{2
if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings. {{{2
inoremap <expr> <C-p> pumvisible() ? '<C-p>' : ""
inoremap <expr> <C-d> pumvisible() ? neocomplete#undo_completion() : virtcol(".") == virtcol("$") ? '<BS>' : '<Del>'
" inoremap <expr> <C-l> neocomplete#complete_common_string()

" <CR>: close popup and save indent.
" inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
" function! s:my_cr_function()
" "   return neocomplete#smart_close_popup() . '<CR>'
"   " For no inserting <CR> key.
"   return pumvisible() ? neocomplete#close_popup() : '<CR>'
" endfunction

" <Tab>: completion.
inoremap <expr> <Tab> pumvisible() ? '<C-n>' : '<C-t>'
inoremap <expr> <S-Tab> pumvisible() ? '<C-p>' : '<C-d>'

" <BS>: close popup and delete backword char.
inoremap <expr> <BS> neocomplete#smart_close_popup() . '<BS>'
" inoremap <expr> <BS> pumvisible() ? neocomplete#smart_close_popup() : '<BS>'
" inoremap <expr> <BS> match(getline("."), '\S') == col(".") - 1 ? neocomplete#smart_close_popup() . "\<C-o>:left\<CR>" : match(getline("."), '^\s*$') >= 0 ? neocomplete#smart_close_popup() . "\<C-o>:left\<CR>" : neocomplete#smart_close_popup() . "\<BS>"
" <BS>: close popup.
" inoremap <expr> <BS> pumvisible() ? neocomplete#smart_close_popup() : '<BS>'
" inoremap <expr> <C-y> neocomplete#close_popup()
" inoremap <expr> <C-e> neocomplete#cancel_popup()

" Close popup by <Space>.
"inoremap <expr> <Space> pumvisible() ? neocomplete#close_popup() : '<Space>'

" For cursor moving in insert mode(Not recommended)
"inoremap <expr> <Left>  neocomplete#close_popup() . '<Left>'
"inoremap <expr> <Right> neocomplete#close_popup() . '<Right>'
"inoremap <expr> <Up>    neocomplete#close_popup() . '<Up>'
"inoremap <expr> <Down>  neocomplete#close_popup() . '<Down>'
" Or set this.
"let g:neocomplete#enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplete#enable_insert_char_pre = 1

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr> <TAB> pumvisible() ? '<Down>' : '<C-x>\<C-u>'

" Enable omni completion. {{{2
au myvimrc FileType css         setlocal omnifunc=csscomplete#CompleteCSS
au myvimrc FileType html        setlocal omnifunc=htmlcomplete#CompleteTags
au myvimrc FileType javascript  setlocal omnifunc=javascriptcomplete#CompleteJS
au myvimrc FileType python      setlocal omnifunc=pythoncomplete#Complete
au myvimrc FileType xml         setlocal omnifunc=xmlcomplete#CompleteTags
au myvimrc FileType workflowish setlocal omnifunc=github_complete#complete

" Enable heavy omni completion. {{{2
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
if !exists('g:neocomplete#force_omni_input_patterns')
  let g:neocomplete#force_omni_input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.workflowish = ':'
let g:neocomplete#sources#omni#input_patterns.markdown = ':'
let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
let g:neocomplete#force_omni_input_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
" let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

" （on_source終わり）{{{2
endfunction

" NeoComplCache {{{1
" 基本設定（以降はon_source）
function! MyDeinHookNeoComplcache() abort
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
"
" Enable heavy features.
" Use camel case completion.
"let g:neocomplcache_enable_camel_case_completion = 1
" Use underbar completion.
"let g:neocomplcache_enable_underbar_completion = 1
"
" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
\  'default': '',
\  'vimshell': $HOME.'/.cache/vimshell/command-history',
\  'scheme': $HOME.'/.gosh_completions',
\  'html': $MYVIMDIR.'/dict/bootstrap.dict',
\}
"
" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
  let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
"
" Plugin key-mappings.
inoremap <expr> <C-d> pumvisible() ? neocomplcache#undo_completion() : virtcol(".") == virtcol("$") ? "\<BS>" : "\<Del>"
" inoremap <expr><C-l>     neocomplcache#complete_common_string()
"
" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplcache#smart_close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
endfunction
" <Tab>: completion.
inoremap <expr> <Tab>  pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab>  pumvisible() ? "\<C-p>" : "\<S-Tab>"
" <C-h>, <BS>: close popup and delete backword char.
" inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
"inoremap <expr><C-e>  neocomplcache#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"
"
" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplcache_enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplcache_enable_insert_char_pre = 1
"
" AutoComplPop like behavior.
"let g:neocomplcache_enable_auto_select = 1
"
" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplcache_enable_auto_select = 1
"let g:neocomplcache_disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"
"
" Enable omni completion.
au myvimrc FileType css setlocal omnifunc=csscomplete#CompleteCSS
au myvimrc FileType html,mkd setlocal omnifunc=htmlcomplete#CompleteTags
au myvimrc FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
au myvimrc FileType python setlocal omnifunc=pythoncomplete#Complete
au myvimrc FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"
" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
if !exists('g:neocomplcache_force_omni_patterns')
  let g:neocomplcache_force_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.php =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.c =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.cpp =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
"
" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplcache_omni_patterns.perl =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
" （on_source終わり）
endfunction

" NeoSnippet {{{1
" KEYMAP:
imap <expr> <C-e> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<End>"
smap <C-e> <Plug>(neosnippet_expand_or_jump)
xmap <C-e> <Plug>(neosnippet_expand_target)
" imap <expr> <Tab> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \ : pumvisible() ? "\<C-n>" : "\<Tab>"
smap <expr> <Tab> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\ : "\<Tab>"
" スニペットの保存場所を変更
let g:neosnippet#snippets_directory = $MYVIMDIR . '/neosnippets'
" スニペットファイルの保存時に再読み込み
au myvimrc BufWritePost *.snip NeoSnippetSource %:p

" CtrlP {{{1
" 説明 {{{2
" KEYMAP:
"  C-f/C-b: モード切替（file<=>mru<=>buffer）
"  C-r: 正規表現モードのオン／オフ

" コマンド設定 {{{2
" CtrlPMRUFiles
nnoremap t :<C-u>CtrlPMRUFiles<CR>
" CtrlPMenu
nnoremap ,T :<C-u>CtrlPMenu<CR>
" CtrlPTag
nnoremap <C-@> :<C-u>CtrlPTag<CR>
" CtrlPLine
nnoremap <C-o> :<C-u>execute 'CtrlPLine ' . expand('%')<CR>
" CtrlPCmdline
nnoremap ,<C-r> :<C-u>CtrlPCmdline<CR>
" コマンドエイリアス
command! -nargs=? -complete=dir Bookmark CtrlPBookmarkDirAdd <args>
command! -nargs=? -complete=dir BookmarkEdit exe 'tabe ' g:ctrlp_cache_dir . '/bkd/cache.txt'
" function! MyBookmark(name) "{{{
"   for line in readfile(g:ctrlp_cache_dir . '/bkd/cache.txt')
"     let kv = split(line, '\t')
"     if a:name == kv[0]
"       return kv[1]
"     endif
"   endfor
"   echoerr 'no bookmark'
" endfunction "}}}
" 拡張機能を有効にする
let g:ctrlp_extensions = [
\ 'register',
\ 'line',
\ 'tag',
\ 'help',
\ 'yankround',
\ 'cmdline',
\ 'slack_files',
\ 'gista',
\ 'menu',
\ 'bookmarkdir',
\]

" キーマップ設定 {{{2
" タブで開く
" t: Tab, e: Enter, h: Horizontal(split), v: Vertical(vsplit)
let g:ctrlp_prompt_mappings = {
\ 'AcceptSelection("t")': ['<CR>'],
\ 'AcceptSelection("e")': ['<C-CR>'],
\ 'AcceptSelection("h")': ['<C-s>'],
\ 'AcceptSelection("v")': ['<C-v>'],
\ 'ToggleByFname()':      ['<C-t>'],
\ 'PrtDelete()':          ['<del>', '<C-d>'],
\ 'PrtInsert()':          ['<C-@>'],
\ 'PrtInsert("c")':       ['<M-v>'],
\ 'OpenMulti()':          ['<C-o>'],
\ 'MarkToOpen()':         ['<C-Space>', '<C-z>', '<C-x>'],
\}

" 詳細設定 {{{2
" ウィンドウの設定
let g:ctrlp_match_window = 'max:20'
" CtrlP動作モード
" （'w'：ワークディレクトリ、'r'：プロジェクトルート）
let g:ctrlp_working_path_mode = 'rw'
" ルートディレクトリのマーカー
" let g:ctrlp_root_markers = [g:localrc_filename]
" キャッシュを使う
let g:ctrlp_use_caching = 1
let g:ctrlp_cache_dir = $HOME . '/.cache/ctrlp'
" キャッシュを終了後も残す（<F5>でキャッシュ更新）
let g:ctrlp_clear_cache_on_exit = 0
" 新規ファイルをタブで開く
let g:ctrlp_open_new_file = 't'
" 開いたタブを一番最後にする
let g:ctrlp_tabpage_position = 'l'
" MRUファイルの数
let g:ctrlp_mruf_max = 10000
" MRUファイルの大文字小文字無視
let g:ctrlp_mruf_case_sensitive = 0
" helpプラグインのデフォルト動作モード
let g:ctrlp_help_default_mode = 'v'
" ドットファイルを検索対象にする
let g:ctrlp_show_hidden = 1
" 複数ファイルオープン設定
let g:ctrlp_open_multiple_files = 'tj'
" 除外設定
let g:ctrlp_custom_ignore = {
\ 'dir': '\.metadata',
\}
let g:ctrlp_mruf_exclude = '.*\.svn[0-9]\{3\}\.tmp\..*'
" migemoを使って日本語正規表現検索 {{{
if executable('migemogrep')
  function! MigemoMatch(items, str, limit, mmode, ispath, crfile, regex)
    let tmp = tempname()
    try
      if a:str =~ '^\s*$'
        return a:items
      endif
      call writefile(split(iconv(join(a:items, "\n"), &encoding, 'utf-8'), "\n"), tmp)
      return split(iconv(system(
      \  printf('migemogrep %s %s',
      \    shellescape(a:str),
      \    shellescape(tmp))), 'utf-8', &encoding), "\n")
    catch
      return []
    finally
      call delete(tmp)
    endtry
  endfunction
"   let g:ctrlp_match_func = {'match' : 'MigemoMatch' }
endif "}}}
" 拡張子に応じて外部プログラムで開く
let g:ctrlp_open_func = {
\ 'files': 'MyExternalOpenFunc',
\ 'mru files': 'MyExternalOpenFunc',
\}
function! MyExternalOpenFunc(action, line) "{{{
  let extension_regexp = '^\(xls\|xlsx\)$'
  if a:action =~ '^[tx]$' && fnamemodify(a:line, ':e') =~? extension_regexp
    " Get the filename
    let filename = fnameescape(fnamemodify(a:line, ':p'))
    " Close CtrlP
    call ctrlp#exit()
    " Open the file
    silent! call vimproc#open(filename)
  elseif a:action == 'x' && fnamemodify(a:line, ':e') !~? extension_regexp
    " Not a HTML file, simulate pressing <c-o> again and wait for new input
    call feedkeys("\<c-o>")
  else
    " Use CtrlP's default file opening function
    call call('ctrlp#acceptfile', [a:action, a:line])
  endif
endfunction "}}}

" EasyMotion {{{1
" 大文字小文字を無視しない
let g:EasyMotion_smartcase = 1
" migemo検索
let g:EasyMotion_use_migemo = 1
" 使用する文字
let g:EasyMotion_keys = 'FDSAJKLGHREWQUIOPVCXZMTYBN/.;'
" 大文字で表示する
let g:EasyMotion_use_upper = 1
" JKモーションでカラム位置キープ
let g:EasyMotion_startofline = 0
" フォールディングを飛ばさない
let g:EasyMotion_skipfoldedline = 0
" Enterで直近に飛ぶ
let g:EasyMotion_enter_jump_first = 1

" Ref {{{1
"
" COMMAND:
"  :Ref refe Array
let g:ref_no_default_key_mappings = 1
let g:ref_use_vimproc = 1 " 0:disable / 1:enable
let g:ref_open = 'vsplit'
let g:ref_detect_filetype = {
\ 'ruby': 'refe',
\ 'ruby.rspec': 'refe',
\}
au myvimrc FileType ref* call MyRefMappings()
function! MyRefMappings() "{{{
  nmap <buffer> <C-]> <Plug>(ref-keyword)
  nmap <buffer> ,] <Plug>(ref-keyword)
  nmap <buffer> <C-j> <Plug>(ref-keyword)
  nmap <buffer> ,[ <Plug>(ref-back)
  nmap <buffer> <C-h> <Plug>(ref-back)
  nmap <buffer> <C-l> <Plug>(ref-forward)
endfunction "}}}
" ref/refe
let g:ref_refe_version = 2
command! -nargs=* Refe :Ref refe <args>
" ref/webdict
" 要：lynx or w3m or elinks or links
let g:ref_source_webdict_sites = {
\ 'default': 'ej',
\ 'ej': {
\   'url': 'http://dictionary.infoseek.ne.jp/ejword/%s',
\ },
\ 'je': {
\   'url': 'http://dictionary.infoseek.ne.jp/jeword/%s',
\ },
\ 'wp': {
\   'url': 'http://ja.wikipedia.org/wiki/%s',
\ },
\}
" 出力に対するフィルタ。最初の数行を削除。
function! g:ref_source_webdict_sites.ej.filter(output)
  return join(split(a:output, "\n")[9 :], "\n")
endfunction
function! g:ref_source_webdict_sites.je.filter(output)
  return join(split(a:output, "\n")[9 :], "\n")
endfunction
function! g:ref_source_webdict_sites.wp.filter(output)
  return join(split(a:output, "\n")[2 :], "\n")
endfunction
" ローカルファイルを参照するため、.local.vimrcに以下を宣言
" ref/javascript
" let g:ref_javascript_doc_path = 'jsref/htdocs'
" ref/jquery
" let g:ref_jquery_doc_path = 'jqapi'

" QuickRun {{{1
" 説明 {{{2
" デフォルトの設定を見る場合、
" let g:quickrun#default_configを使う。
" <C-c> で実行を強制終了させる
" COMMAND:
"  :QuickRun -args foo
" KEYMAP:
"  ,r : バッファの内容を実行

" on_source設定 {{{2
function! MyDeinHookQuickrun() abort

" quickrun.vim が実行していない場合には <C-c> を呼び出す
nnoremap <expr> <silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"

" アニメーション
call quickrun#module#register(shabadou#make_quickrun_hook_anim(
\ "animation",
\ ['QuickRun: ／', 'QuickRun: ―', 'QuickRun: ＼', 'QuickRun: ｜',],
\ 12,
\), 1)

" CRLFを消す
let s:my_quickrun_hook_delete_crlf = {
\ 'name' : 'delete_crlf',
\ 'kind' : 'hook',
\ 'config' : {
\   'enable' : 1,
\ }
\}
function! s:my_quickrun_hook_delete_crlf.on_output(session, context) "{{{
  let a:context.data = substitute(a:context.data, '\r', '', 'g')
endfunction "}}}
call quickrun#module#register(s:my_quickrun_hook_delete_crlf, 1)

" Oracle出力設定
let s:my_quickrun_outputter_oracle = {
\ 'name': 'oracle',
\ 'kind': 'outputter',
\ 'config': {
\   'enable': 0,
\ }
\}
function! s:my_quickrun_outputter_oracle.output(data, session) "{{{
  silent! echon a:data
endfunction "}}}
function! s:my_quickrun_outputter_oracle.finish(session) "{{{
  exe '%Alignta ,'
  echomsg winnr()
endfunction "}}}
call quickrun#module#register(s:my_quickrun_outputter_oracle, 1)

" （on_source終わり） {{{2
endfunction

" 共通設定 {{{2
"  実行にvimprocを使う
"  エラー時はquickfixに表示する
"  TODO: close_quickfixフックが動かない、、
let g:quickrun_config = {}
let g:quickrun_config = {
\  "_": {
\    'runner': 'vimproc',
\    'runner/vimproc/updatetime': 100,
\    'outputter': 'error',
\    'outputter/error': 'quickfix',
\    'outputter/error/success': 'buffer',
\    'outputter/buffer/split': ':belowright 5',
\    'outputter/buffer/close_on_empty': 1,
\    'hook/animation/enable': 1,
\    'hook/animation/wait': 10,
\    'hook/close_buffer/enable_hook_loaded': 1,
\    'hook/close_quickfix/enable_hook_loaded': 1,
\    'hook/close_quickfix/enable_success': 1,
\  },
\}
" \    'outputter/buffer/split': ':vert 20',

" AnsiEscでカラーリング
au myvimrc FileType quickrun AnsiEsc

" ruby {{{2
let g:quickrun_config['ruby.alt'] = {'type': 'ruby.bundle'}
let g:quickrun_config['ruby.bundle'] = {
\ 'command': 'bundle',
\ 'cmdopt': 'exec ruby',
\ 'exec': '%c %o %s',
\}

" Gemfile
au myvimrc BufRead,BufNewFile Gemfile let b:quickrun_config = {'type': 'ruby.gemfile'}
au myvimrc BufRead,BufNewFile *.gemspec let b:quickrun_config = {'type': 'ruby.gemfile'}
let g:quickrun_config['ruby.gemfile'] = {
\ 'exec': 'bundle',
\}

" ruby.test
au myvimrc BufRead,BufNewFile *_test.rb let b:quickrun_config = {'type': 'ruby.test'}
let g:quickrun_config['ruby.test'] = {
\ 'command': 'bundle',
\ 'cmdopt': 'exec rake test',
\ 'exec': '%c %o',
\}

" ruby.rspec
au myvimrc BufRead,BufNewFile *_spec.rb let b:quickrun_config = {'type': 'ruby.rspec'}
let g:quickrun_config['ruby.rspec'] = {
\ 'command': 'rspec',
\ 'cmdopt': '--color',
\ 'exec': '%c %o %s',
\}

" swift {{{2
if executable('swift')
  let g:quickrun_config['swift'] = {
  \ 'command': 'swift',
  \ 'exec': '%c %o %s',
  \}
endif

" vim {{{2
" themis
au myvimrc BufRead,BufNewFile test_*.vim let b:quickrun_config = {'type': 'vim.themis'}
let g:quickrun_config['vim.themis'] = {
\ 'command': 'themis',
\ 'cmdopt': '',
\ 'exec': '%c %o %s',
\}

" vspec
au myvimrc BufRead,BufNewFile *_spec.vim let b:quickrun_config = {'type': 'vim.vspec'}
if (has('win32') || has('win64')) && exists('$CYGWIN_HOME')
  let g:quickrun_config['vim.vspec'] = {
  \ 'exec': '%c --login -c ' .
  \         '"cd %%{MyGetCygwinDir(%s:p:h)}/..; ' .
  \         '%%{MyGetCygwinDir(expand($MYVIMDIR))}/bundle/vim-vspec/bin/vspec ' .
  \         '%%{MyGetCygwinDir(expand($MYVIMDIR))}/bundle/vim-vspec ' .
  \         '%%{MyGetCygwinDir(expand($MYVIMDIR))}/bundle/vim-vspec-matchers ' .
  \         '. ' .
  \         '%%{MyGetCygwinDir(%s:p)}"',
  \ 'command': $CYGWIN_HOME . '\bin\bash.exe',
  \}
  let g:quickrun_config['vim.vspec.alt'] = {
  \ 'exec': '%c --login -c ' .
  \         '"cd %%{MyGetCygwinDir(%s:p:h)}/..; rake test"',
  \ 'command': $CYGWIN_HOME . '\bin\bash.exe',
  \}
elseif executable('bash')
  let g:quickrun_config['vim.vspec'] = {
  \ 'exec': '%c %o %a %s',
  \ 'command': $MYVIMDIR . '/bundle/vim-vspec/bin/vspec',
  \ 'args': $MYVIMDIR . '/bundle/vim-vspec ..',
  \}
  let g:quickrun_config['vim.vspec.alt'] = {
  \ 'exec': 'rake test',
  \}
endif

" html, mkd {{{2
" （tyru/open-browser.vim プラグインが必要）
let g:quickrun_config['html'] = {
\ 'command': 'open',
\ 'exec': has('win32') || has('win64') ? '%c file:///%s' : '%c file://%s',
\ 'outputter': 'browser',
\}
let g:quickrun_config['xhtml'] = {'type': 'html'}
let g:quickrun_config['md'] = {'command': 'kramdown', 'outputter': 'browser'}
let g:quickrun_config['markdown'] = {'command': 'kramdown', 'outputter': 'browser'}
let g:quickrun_config['workflowish'] = {'command': 'kramdown', 'outputter': 'browser'}

" javascript {{{2
let g:quickrun_config['javascript'] = {'command': 'node'}
let g:quickrun_config['jshint'] = {
\ 'exec': '%c %s:p',
\ 'command': 'jshint',
\ 'outputter': 'quickfix',
\ 'quickfix/errorformat': '%f: line %l\\,\ col %c\\, %m',
\ 'vimproc/sleep': 0,
\ 'hook/unite_quickfix/enable': 0,
\ 'hook/close_unite_quickfix/enable': 0,
\ 'hook/close_buffer/enable_exit': 1,
\ 'hook/u_nya_/enable': 0,
\}

" sql {{{2
let g:quickrun_config['sql'] = {'type': executable('sqlite3') ? 'sql.sqlite3' : 'sql.alt'}
let g:quickrun_config['sql.alt'] = {'type': executable('sqlplus') ? 'sql.oracle' : ''}
let g:quickrun_config['sql.sqlite3'] = {
\ 'exec': '%c %o %a < %S',
\ 'command': 'sqlite3',
\ 'cmdopt': '-header -column',
\}
let g:quickrun_config['sql.oracle'] = {
\ 'exec': '%c %o \@%s',
\ 'command': 'sqlplus',
\ 'cmdopt': '-S %{get(g:, "quickrun_oracle_conn", "/nolog")}',
\ 'hook/output_encode/encoding': 'sjis',
\ 'hook/eval/enable': 1,
\ 'hook/eval/template':
\   'set echo off' . "\r" .
\   'set linesize 1000' . "\r" .
\   '-- set pagesize 1000' . "\r" .
\   'set trimspool on' . "\r" .
\   'set feedback off' . "\r" .
\   'set colsep ","' . "\r" .
\   'set heading on' . "\r" .
\   'set underline off' . "\r" .
\   '%s',
\ 'outputter/oracle/enable': 1,
\}
" \ 'outputter': 'oracle',

" その他 {{{2
" Brewfile
au myvimrc BufRead,BufNewFile Brewfile* let b:quickrun_config = {'type': 'brewfile'}
let g:quickrun_config['brewfile'] = {
\ 'exec': 'brew bundle --file="%s"',
\}

" lightline {{{1
let g:lightline = {}
" let g:lightline.colorscheme = 'wombat'
let g:lightline.active = {
\ 'left': [['mode', 'paste'], ['filename', 'vcs', 'gista', 'anzu']],
\ 'right': [['lineinfo', 'syntastic'], ['percent'], ['pwd', 'fileformat', 'fileencoding', 'filetype']]
\}
" \ 'left': [['mode', 'paste'], ['filename', 'gista', 'anzu']],
let g:lightline.inactive = {
\ 'left': [],
\ 'right': [['filename']]
\}
let g:lightline.component_function = {
\ 'modified': 'MyModified',
\ 'readonly': 'MyReadonly',
\ 'pwd': 'MyPwd',
\ 'filename': 'MyFilename',
\ 'vcs': 'MyVcs',
\ 'gista': 'gista#statusline#components#gistid',
\ 'anzu': 'anzu#search_status',
\ 'syntastic': 'SyntasticStatuslineFlag',
\ 'fileformat': 'MyFileformat',
\ 'filetype': 'MyFiletype',
\ 'fileencoding': 'MyFileencoding',
\ 'mode': 'MyMode'
\}
function! MyModified() " {{{2
  "return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : ''
endfunction
function! MyReadonly() " {{{2
  "return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '[RO]' : ''
endfunction
function! MyFilename() " {{{2
  return (&ft == 'vimfiler' ? vimfiler#get_status_string() :
\         &ft == 'unite' ? unite#get_status_string() :
\         &ft == 'vimshell' ? '' :
\         &ft == '' && 'ControlP' == expand('%:t') ? '' :
\         '' != expand('%:t') ? expand('%:t') : '[No Name]') .
\        ('' != MyModified() ? ' ' . MyModified() : '') .
\        ('' != MyReadonly() ? ' ' . MyReadonly() : '')
endfunction
" \         &ft == 'vimshell' ? vimshell#get_status_string() :
function! MyPwd() " {{{2
  let path = ''
  if winwidth(0) > 100
    let path = getcwd()
    while len(path) >= 50 && stridx(path, '/') >= 0
      let path = '.../' . strpart(path, stridx(path, '/', 4) + 1)
    endwhile
  endif
  return path
endfunction
function! MyVcs() " {{{2
  " try
  "   if winwidth(0) > 80 && &ft !~? 'vimfiler\|gundo' && exists(':Vcs')
  "     let branch = vcs#info('%b')
  "     let target_statuses = ['added', 'modified', 'deleted', 'conflicted', 'untracked', 'renamed']
  "     return branch
  "   endif
  " catch
  " endtry
  " return ''
  if exists('*fugitive#head')
    return fugitive#head()
  endif
  return ''
endfunction
function! MyFileformat() " {{{2
  return winwidth(0) > 80 ? &fileformat : ''
endfunction
function! MyFiletype() " {{{2
  return winwidth(0) > 80 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction
function! MyFileencoding() " {{{2
  return winwidth(0) > 80 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction
function! MyMode() " {{{2
  return &ft == 'help' ? 'Help' :
\        &ft == '' && 'ControlP' == expand('%:t') ? 'CtrlP' :
\        &ft == 'vimshell' ? 'VimShell' :
\        &ft == 'qf' ? 'QuickFix' :
\        &ft == 'unite' ? 'Unite' :
\        &ft == 'quickrun' ? 'QuickRun' :
\        &ft == 'minibufexpl' ? 'MBE' :
\        winwidth(0) > 60 ? lightline#mode() : ''
endfunction

" Tagbar {{{1
let g:tagbar_auto_focus = 1
if executable('jsctags')
  let g:tagbar_type_javascript = {'ctagsbin': '/opt/local/bin/jsctags'}
endif
if executable('markdown2ctags.py')
  let g:tagbar_type_workflowish = {
    \ 'ctagstype': 'markdown',
    \ 'ctagsbin' : 'markdown2ctags.py',
    \ 'ctagsargs' : '-f - --sort=yes',
    \ 'kinds' : [
      \ 's:sections',
      \ 'i:images'
    \ ],
    \ 'sro' : '|',
    \ 'kind2scope' : {
      \ 's' : 'section',
    \ },
    \ 'sort': 0,
  \}
else
  let g:tagbar_type_workflowish = {
    \ 'ctagstype' : 'markdown',
    \ 'kinds' : [
      \ 'h:Heading_L1',
      \ 'i:Heading_L2',
      \ 'k:Heading_L3'
    \]
  \}
endif

" IndentGuides {{{1
" vim立ち上げたときに、自動的にIndentGuidesをオンにする
let g:indent_guides_enable_on_vim_startup = 1
" ガイドをスタートするインデントの量
let g:indent_guides_start_level = 1
" ガイドの幅
let g:indent_guides_guide_size = 2
" ガイドの最大値
let g:indent_guides_indent_levels = 40
" 自動カラーを無効にする
let g:indent_guides_auto_colors = 0
" 奇数インデントのカラー
hi IndentGuidesOdd  guibg=#262626 ctermbg=gray guifg=#000000 ctermfg=black
au myvimrc VimEnter,ColorScheme * :hi IndentGuidesOdd  guibg=#262626 ctermbg=gray guifg=#000000 ctermfg=black
" 偶数インデントのカラー
hi IndentGuidesEven guibg=#3c3c3c ctermbg=darkgray guifg=#000000 ctermfg=black
au myvimrc VimEnter,ColorScheme * :hi IndentGuidesEven guibg=#3c3c3c ctermbg=darkgray guifg=#000000 ctermfg=black
" ハイライト色の変化の幅
let g:indent_guides_color_change_percent = 30
" 無視するファイルタイプ
let g:indent_guides_exclude_filetypes = ['help', 'unite', 'vimfiler', 'vimshell', 'splash', 'tagbar']

" ShowMarks {{{1
let g:showmarks_ignore_type = 'hqmp'

" MiniBufExplorer {{{1
"
" 自動起動
let g:miniBufExplAutoStart = 0
" バッファが２つ以上で開く
" let g:miniBufExplBuffersNeeded = 2
" Diffモードでは隠す
let g:miniBufExplHideWhenDiff = 1
" バッファリストのサイクル化
let g:miniBufExplCycleArround = 1
" 表示行数を制限
let g:miniBufExplMaxSize = 1
" カラーリング
let g:did_minibufexplorer_syntax_inits = 1
" for buffers that have NOT CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveNormal ctermfg=black ctermbg=lightgray guifg=black guibg=lightgray
" for buffers that have CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveChanged ctermfg=black ctermbg=lightred guifg=black guibg=lightred
" buffers that have NOT CHANGED and are VISIBLE
hi MBEVisibleNormal cterm=bold ctermfg=white gui=bold guifg=white guibg=black
" buffers that have CHANGED and are VISIBLE
hi MBEVisibleChanged cterm=bold ctermfg=lightred gui=bold guifg=lightred guibg=black
" for buffers that have NOT CHANGED and are NOT VISIBLE.
hi MBENormal ctermfg=darkgray guifg=darkgray guibg=black
" for buffers that HAVE CHANGED and are NOT VISIBLE
hi MBEChanged ctermfg=red guifg=red guibg=black

" Acceralated Smooth Scroll {{{1
map <silent> <Space> <Plug>(ac-smooth-scroll-c-d)
map <silent> <S-Space> <Plug>(ac-smooth-scroll-c-u)
vmap <silent> <Space> <Plug>(ac-smooth-scroll-c-d_v)
vmap <silent> <S-Space> <Plug>(ac-smooth-scroll-c-u_v)
map <silent> <C-w><Space> <C-w>p<Plug>(ac-smooth-scroll-c-d)<C-w>p
map <silent> <C-w><S-Space> <C-w>p<Plug>(ac-smooth-scroll-c-u)<C-w>p

" vim-vcs {{{1
command! Vs silent Vcs status
command! Va silent Vcs add
command! Vc silent Vcs commit
command! Vca silent call vcs#vcs('add', '.') | silent Vcs commit
command! Vl silent Vcs log
command! Vpush call s:my_vimproc_async({'cmd': 'git push'})
command! Vpull call s:my_vimproc_async({'cmd': 'git pull'})
" Vpush/Vpullのためのvimproc（非同期ファンクション使用のため廃止）
" function! s:my_git_vimproc(gitcommand) "{{{
"   let command = 'git ' . a:gitcommand
"   let sub = vimproc#popen2(command)
"   let res = ''
"   while !sub.stdout.eof
"     let res .= sub.stdout.read()
"     let res .= sub.stderr.read()
"   endwhile
"   let [cond, status] = sub.waitpid()
"   if 0 != status
"     echohl ErrorMsg
"   endif
"   for line in split(res, '\r\n\|\r\|\n')
"     echomsg "[".command."] ".line
"   endfor
"   echohl None
" endfunction "}}}

" fugitive {{{1
" 説明 {{{
" DESC:
"  VimにGitコマンドを追加。
" COMMAND:
"  :Gstatus      : git status
"    Gstatusのバッファ上で
"      - : add/reset
"      D : diff
"      C : commit
"      cvc : commit -v
"  :Gwrite/:Gadd : git add
"  :Gdiff        : git diff
"  :Gcommit -v   : git commit -v
" }}}
command! Gs Gstatus
command! Ga Gwrite
command! Gw Gwrite
command! Gd Gvdiff
command! Gc Gcommit -v
command! Gca Gcommit -va
command! Gl Glog
command! Gb Gblame
" HEADに戻す
command! Gr Gread! show HEAD:%

" Gitv {{{1
let g:Gitv_OpenHorizontal = 1

" vimagit {{{1
" ヘルプ非表示
" let g:magit_show_help = 0
" diffを最初から開いておく
let g:magit_default_show_all_files = 2
let g:magit_default_fold_level = 2
" 表示するセクションと並び順
let g:magit_default_sections = ['commit', 'info', 'global_help', 'staged', 'unstaged']

" vim-unified-diff {{{1
set diffexpr=unified_diff#diffexpr()
let unified_diff#executable = 'git'
let unified_diff#arguments = [
\ 'diff', '--no-index', '--no-color', '--no-ext-diff', '--unified=0', '--histogram'
\ ]
let unified_diff#iwhite_arguments = [
\ '--ignore--all-space',
\ ]

" Linediff {{{1
command! -range LD call linediff#Linediff(<line1>, <line2>)

" vim-dirdiff {{{1
let g:DirDiffExcludes = ".svn,.git,CVS,*.class,*.exe,.*.swp"

" Gundo {{{1
let g:gundo_close_on_revert = 1

" incsearch {{{1
" incsearch
" map / <Plug>(incsearch-forward)
" map ? <Plug>(incsearch-backward)
" map g/ <Plug>(incsearch-stay)

" incsearch-migemo
map g/ <Plug>(incsearch-migemo-/)
map g? <Plug>(incsearch-migemo-?)
" map g/ <Plug>(incsearch-migemo-stay)
command! MigemoIncsearch call incsearch#call(incsearch#config#migemo#make())

" incsearch-fuzzy
command! FuzzyIncsearch call incsearch#call(incsearch#config#fuzzy#make())

" incsearch-migemo-fuzzy
" function! s:config_migemo_fuzzy(...) abort "{{{
"   return extend(copy({
"   \ 'converters': [
"   \   incsearch#config#migemo#converter(),
"   \   incsearch#config#fuzzy#converter(),
"   \ ],
"   \}), get(a:, 1, {}))
" endfunction "}}}
" noremap <silent><expr> g/ incsearch#go(<SID>config_migemo_fuzzy())
" noremap <silent><expr> g? incsearch#go(<SID>config_migemo_fuzzy({'command', '?'}))
" noremap <silent><expr> g/ incsearch#go(<SID>config_migemo_fuzzy({'is_stay': 1}))

" anzu {{{1
let g:anzu_status_format = "(%i/%l)"
au myvimrc CursorHold,CursorHoldI,WinLeave,TabLeave * call anzu#clear_search_status()

" jplus {{{1
" キーマッピング
nmap J <Plug>(jplus)
vmap J <Plug>(jplus)
nmap gJ <Plug>(jplus-getchar)
vmap gJ <Plug>(jplus-getchar)
" 初期化
let g:jplus#config = {}
" 区切り文字はなし
let g:jplus#config._ = {'delimiter': ''}

" FastFold {{{1
" キーマップを変えない
let g:fastfold_fold_command_suffixes = []
let g:fastfold_fold_movement_commands = []
" 自動でフォールドを更新しない
let g:fastfold_fold_movement_commands = []
let g:fastfold_savehook = 0
let g:fastfold_fdmhook = 0
let g:fastfold_skip_filetypes = [ 'workflowish' ]

" textobj-user {{{1
" entire
let g:textobj_entire_no_default_key_mappings = 1
omap aa <Plug>(textobj-entire-a)
vmap aa <Plug>(textobj-entire-a)
omap ia <Plug>(textobj-entire-i)
vmap ia <Plug>(textobj-entire-i)
" postexpr
let g:textobj_postexpr_no_default_key_mappings = 1
omap af <Plug>(textobj-postexpr-a)
vmap af <Plug>(textobj-postexpr-a)
omap if <Plug>(textobj-postexpr-i)
vmap if <Plug>(textobj-postexpr-i)
" wiw
let g:textobj_wiw_no_default_key_mappings = 1
omap a_ <Plug>(textobj-wiw-a)
vmap a_ <Plug>(textobj-wiw-a)
omap i_ <Plug>(textobj-wiw-i)
vmap i_ <Plug>(textobj-wiw-i)
" between
let g:textobj_between_no_default_key_mappings = 1
omap a= <Plug>(textobj-between-a)
vmap a= <Plug>(textobj-between-a)
omap i= <Plug>(textobj-between-i)
vmap i= <Plug>(textobj-between-i)
" multitextojb
let g:textobj_multitextobj_textobjects_a =
\ ["a'", 'a"', 'a<', 'a(', 'a[', 'a]', 'a{', 'a}']
let g:textobj_multitextobj_textobjects_i =
\ ["i'", 'i"', 'i<', 'i(', 'i[', 'i]', 'i{', 'i}']
omap am <Plug>(textobj-multitextobj-a)
vmap am <Plug>(textobj-multitextobj-a)
omap im <Plug>(textobj-multitextobj-i)
vmap im <Plug>(textobj-multitextobj-i)
" multiblock
let g:textobj_multiblock_blocks = [
\ ['function.*\_$', '\s*endfunction'], ['def.*\_$', '\s*end'],
\ ['for.*\_$', '\s*endfor'], ['while.*\_$', '\s*endwhile'], ['do.*\_$', '\s*end'],
\ ['if.*\_$', '\s*endif'], ['if.*\_$', '\s*fi'], ['if.*\_$', '\s*end'],
\ ['[', ']'], ['{', '}'], ['(', ')'],
\]
omap aM <Plug>(textobj-multiblock-a)
vmap aM <Plug>(textobj-multiblock-a)
omap iM <Plug>(textobj-multiblock-i)
vmap iM <Plug>(textobj-multiblock-i)

" expand-region {{{1
" キーマップ
vmap v <Plug>(expand_region_expand)
vmap - <Plug>(expand_region_shrink)
" テキストオブジェクト設定
let g:expand_region_text_objects = {
\ 'i_'  :1,
\ 'a_'  :1,
\ 'iw'  :0,
\ 'iW'  :0,
\ 'aW'  :0,
\ 'i"'  :0,
\ 'a"'  :0,
\ 'i''' :0,
\ 'a''' :0,
\ 'i,'  :0,
\ 'a,'  :0,
\ 'i>'  :0,
\ 'a>'  :0,
\ 'i]'  :1,
\ 'a]'  :1,
\ 'ib'  :1,
\ 'ab'  :1,
\ 'iB'  :1,
\ 'aB'  :1,
\ 'iM'  :1,
\ 'aM'  :1,
\ 'il'  :0,
\ 'ii'  :1,
\ 'ip'  :0,
\ 'iz'  :0,
\ 'ia'  :0,
\}

" surround {{{1
" KEYMAP:
"  cs'" : 'を"に変換する
"  ds' : 'で囲まれた範囲を消す
let g:surround_no_mappings = 1
nmap cs <Plug>Csurround
nmap ds <Plug>Dsurround
" 置換時の空白を入れない
let g:surround_34 = "\"\r\""
let g:surround_39 = "\'\r\'"
let g:surround_40 = "(\r)"
let g:surround_41 = "( \r )"
let g:surround_91 = "[\r]"
let g:surround_93 = "[ \r ]"
let g:surround_123 = "{\r}"
let g:surround_125 = "{ \r }"

" smartchr {{{1
" inoremap <expr> < smartchr#loop('<', '<<', '<=')
" inoremap <expr> > smartchr#loop('>', '>>', '>=')

" Switch {{{1
nnoremap <expr> <C-a> strpart(getline("."), col(".") - 1, 1) =~ '\d' ? "\<C-a>" : ":\<C-u>Switch\<CR>"
let g:switch_custom_definitions =
\ [
\   ['=', '<=', '>='],
\ ]

" Alingta {{{1
" デフォルト整列オプション
let g:alignta_default_options = '<<<1:1'
" 引数なしは非空白文字で整列
let g:alignta_default_arguments = '<< \S\+'
" コマンド短縮名
" command! -range ALe <line1>,<line2>Alignta =
" command! -range ALl <line1>,<line2>Alignta >>> \S\+
" command! -range -bang -nargs=* AL <line1>,<line2>Alignta<bang> <args>
" unite-alignta
let g:unite_source_alignta_preset_arguments = [
\ ['Alignta at "="', '='],
\ ['Alignta Left at "\\S\\+"', '>>> \S\+'],
\]

" EasyAlign {{{1
" カスタムデリミタ
" （括弧対応関係のためのコメント [[((<<）
let g:easy_align_delimiters = {
\ ']': {'pattern': '\]', 'left_margin': 0, 'right_margin': 1, 'stick_to_left': 1},
\ ')': {'pattern': ')', 'left_margin': 0, 'right_margin': 1, 'stick_to_left': 1},
\ '>': {'pattern': '>', 'left_margin': 0, 'right_margin': 1, 'stick_to_left': 1},
\}
" コマンド短縮名
command! -range -bang -nargs=* AL <line1>,<line2>EasyAlign<bang> <args>

" submode {{{1
" xで連続で消した履歴を一つにまとめる {{{2
nnoremap <silent> <Plug>(my-submode-x) :<C-u>call <SID>my_submode_x()<CR>
function! s:my_submode_x() "{{{
  undojoin
  normal! "_x
endfunction "}}}
" サブモード抜け時の挙動が気になるので無効化
" call submode#enter_with('submode-x', 'n', '', 'x', '"_x')
" call submode#map('submode-x', 'n', 'r', 'x', '<Plug>(my-submode-x)')

" zl/zhで連続横移動 {{{2
call submode#enter_with('submode-zl/zh', 'n', '', 'zl', '4zl4zl4zl4zl4zl4zl')
call submode#enter_with('submode-zl/zh', 'n', '', 'zh', '4zh4zh4zh4zh4zh4zh')
call submode#map('submode-zl/zh', 'n', '', 'l', '4zl4zl4zl4zl4zl4zl')
call submode#map('submode-zl/zh', 'n', '', 'h', '4zh4zh4zh4zh4zh4zh')

" clever-f {{{1
" マッピング
let g:clever_f_not_overwrites_standard_mappings = 1
vmap f <Plug>(clever-f-f)
vmap F <Plug>(clever-f-F)
vmap t <Plug>(clever-f-t)
vmap T <Plug>(clever-f-T)
" 大文字小文字無視
let g:clever_f_smart_case = 1
" migemo
let g:clever_f_use_migemo = 1
" 検索方向固定
let g:clever_f_fix_key_direction = 1

" vim-smartword & CamelCaseMotion {{{1
map <Plug>(smartword-basic-w) <Plug>CamelCaseMotion_w
map <Plug>(smartword-basic-b) <Plug>CamelCaseMotion_b
map <Plug>(smartword-basic-e) <Plug>CamelCaseMotion_e
nmap w <Plug>(smartword-w)
nmap b <Plug>(smartword-b)
nmap e <Plug>(smartword-e)
nmap ge <Plug>(smartword-ge)
vmap w <Plug>(smartword-w)
vmap b <Plug>(smartword-b)
vmap e <Plug>(smartword-e)
vmap ge <Plug>(smartword-ge)
" omap w <Plug>CamelCaseMotion_w
" omap b <Plug>CamelCaseMotion_b
" omap e <Plug>CamelCaseMotion_e

" editqf {{{1
let g:editqf_saveqf_filename = "~/.editqf_save_data"

" qfixhowm {{{1
" デフォルトキーマップ無効
let g:qfixmemo_default_keymap = 0
" コマンド定義
command! Memo QFixHowm c
command! MemoAppend QFixHowm N
command! MemoList QFixHowm m
command! MemoListAll QFixHowm ra

" previm {{{1
" リアルタイムプレビュー
let g:previm_enable_realtime = 0

" markdown-folding {{{1
" フォールディングをネストする
let g:markdown_fold_style = 'nested'

" vim-slack_files "{{{1
nnoremap T :<C-u>CtrlPSlackFiles<CR>
command! SFu SlackFilesUpload

" vim-gista {{{1
" Github設定
let g:gista#github_user = 'zeero'
let g:gista#client#default_username = 'zeero'
let g:gista#client#default_apiname = 'GitHub'
" プライベートをデフォルトに
let g:gista#post_private = 1
" アップデート時の警告を無効に
let g:gista#warn_in_partial_save = 0
" ポストしたら自動でコネクト
let g:gista#auto_connect_after_post = 1
" :wで保存時にアップデート（デフォルトは:w!）
let g:gista#update_on_write = 1
" リストを自動で閉じる
" let g:gista#close_list_after_open = 1
" リスト表示の開き方
let g:gista#list_opener = 'tabe'
" リストのカラー設定
hi link GistaFiles Directory
" タブで開く
let g:gista#gist_default_opener = 'tabe'
let g:gista#gist_opener = {
\ 'edit': 'tabe',
\ 'split': 'rightbelow split',
\ 'vsplit': 'rightbelow vsplit',
\}
" descriptionは聞かない
let g:gista#interactive_description = 0
" Uniteコマンド
command! UGista exe 'Unite gista' .
\ ' -silent -buffer-name=gista' .
\ ' -tab -no-split -no-quit'

" Emmet {{{1
"
" KEYMAP:
"  <C-e> : 展開
"  <C-_> : コメントアウト／イン
"          （_と/が同じキーマップになってるのでCtrl+/でできる）
" HTML/CSSのみキーマッピングする
" let g:user_emmet_leader_key = '<C-@><C-e>'
let g:user_emmet_install_global = 0
au myvimrc FileType html,css nmap <buffer> <C-@><C-e> <Plug>(emmet-expand-abbr)
" let g:user_emmet_togglecomment_key = '<C-_>'
" タグのコンプリート
let g:use_emmet_complete_tag = 1

" カスタマイズ設定
let g:user_emmet_settings = {
\  'lang': 'ja',
\  'indentation': "  ",
\  'html': {
\    'filters': 'html',
\    'snippets': {
\      'meta:viewport': "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">",
\      'css:bs': "<link href=\"css/bootstrap.min.css\" rel=\"stylesheet\">",
\      'cd': "<![CDATA[|]]>",
\      'js:jq': "<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n<script>\n\\$(function() {\n\t|\n})()\n</script>",
\      'js:bs': "<script src=\"https://code.jquery.com/jquery.js\"></script>\n<script src=\"js/bootstrap.min.js\"></script>",
\    },
\  },
\  'javascript': {
\    'snippets': {
\      'jq': "\\$(function() {\n\t\\${cursor}\\${child}\n});",
\      'jq:json': "\\$.getJSON(\"${cursor}\", function(data) {\n\t\\${child}\n});",
\      'jq:each': "\\$.each(data, function(index, item) {\n\t\\${child}\n});",
\      'fn': "(function() {\n\t\\${cursor}\n})();",
\      'tm': "setTimeout(function() {\n\t\\${cursor}\n}, 100);",
\    },
\    'use_pipe_for_cursor': 0,
\  },
\  'css': {
\    'filters': 'fc',
\    'snippets': {
\      'box-shadow': "-webkit-box-shadow: 0 0 0 # 000;\n-moz-box-shadow: 0 0 0 0 # 000;\nbox-shadow: 0 0 0 # 000;",
\    },
\  },
\  'vim': {
\    'snippets': {
\      'nn': 'nnoremap <silent> ${cursor} :<C-u>',
\      'nnu': 'nnoremap <silent> [unite]${cursor}<CR> :<C-u>Unite<Space>\n\\<Space>-no-empty<Space>-silent<Space>-buffer-name=<CR>',
\    },
\  },
\  'java': {
\    'snippets': {
\     'main': "public static void main(String[] args) {\n\t|\n}",
\     'println': "System.out.println(\"|\");",
\     'class': "public class | {\n}\n",
\    },
\  },
\  'php': {
\    'extends': 'html',
\    'filters': 'html,c',
\  },
\  'less': {
\    'filters': 'fc',
\    'extends': 'css',
\  },
\  'lorem_ipsum_ja': {
\    '^\%(lorem\|ipsum\)\(\d*\)$': function('emmet#lorem#ja#expand'),
\  },
\}

" rcodetools {{{1
"
" DESC: xmpfilterの呼び出し設定
" <F1>でバッファ全体にxmpfilterを実行
"{{{ xmpfilter mapping (disable)
"nmap <silent> <F1> mzggVG!xmpfilter -a<cr>'z
"imap <silent> <F1> <Esc><F1>
"" <F2>で現在行/選択行にxmpfilterを実行
"map <silent> <F2> !xmpfilter -a<cr>
"nmap <silent> <F2> V<F2>
"imap <silent> <F2> <Esc><F2>a
"" <F3>で現在行/選択行に「# =>」マークを追加
"vmap <silent> <F3> !xmpfilter -m<cr>
"nmap <silent> <F3> V<F3>
"imap <silent> <F3> <Esc><F3>a
"" <F4>で現在行/選択行の「# =>」マークを削除
"vmap <silent> <F4> ms:call RemoveRubyEval()<CR>
"nmap <silent> <F4> V<F4>
"imap <silent> <F4> <Esc><F4>a
"" RemoveRubyEval() の定義
"function! RemoveRubyEval() range
  "let begv = a:firstline
  "let endv = a:lastline
  "normal Hmt
  "set lz
  "execute ":" . begv . "," . endv . 's/\s*# \(=>\|!!\).*$//e'
  "normal 'tzt`s
  "set nolz
  "redraw
"endfunction
"" JRuby用<F11>でバッファ全体にjxmpfilterを実行
"nmap <silent> <F11> mzggVG!jxmpfilter -a<cr>'z
"imap <silent> <F11> <Esc><F11>
"}}}

" monster.vim {{{1
" Set async completion.
let g:monster#completion#rcodetools#backend = "async_rct_complete"

" SQLUtilities {{{1
" カンマで行分割
let g:sqlutil_align_comma = 1
" 比較子で整列させない
let g:sqlutil_align_where = 0
" 左寄せにする
let g:sqlutil_align_keyword_right = 0
" キーワードを大文字にする
let g:sqlutil_keyword_case = '\U'

" splitjoin {{{1
" キーマッピング
let g:splitjoin_split_mapping = ',o'
let g:splitjoin_join_mapping = ',J'

" Syntastic {{{1
" チェック設定
let g:syntastic_mode_map = {
\ 'mode': 'passive',
\ 'active_filetypes': ['coffee', 'javascript', 'json']
\}
" \ 'mode': 'active',
" \ 'passive_filetypes': ['html', 'swift']
let g:syntastic_quiet_messages = {
\ 'type': 'style',
\}
" ファイルタイプ別設定
if executable('rubocop')
  let g:syntastic_ruby_checkers = ['rubocop']
endif
if executable('coffeelint')
  let g:syntastic_coffee_checkers = ['coffeelint']
endif
if executable('eslint')
  let g:syntastic_javascript_checkers = ['eslint']
elseif executable('jshint')
  let g:syntastic_javascript_checkers = ['jshint']
endif
if executable('jsonlint')
  let g:syntastic_json_checkers = ['jsonlint']
endif
" ロケーションリスト設定
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 5
" サイン表示しない（する場合はb:変数で上書きする）
let g:syntastic_enable_signs = 0
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'
" :wqでチェックしない
let g:syntastic_check_on_wq = 0

" Restart {{{1
let g:restart_sessionoptions = 'blank,curdir,folds,help,localoptions,tabpages'

" Conque {{{1
" 終了時に閉じる
let g:ConqueTerm_CloseOnEnd = 1
" InsertモードでC-wを使用できるようにする
let g:ConqueTerm_CWInsert = 1
" カラー
let g:ConqueTerm_Color = 1
" trail非表示
au myvimrc FileType conque_term setlocal nolist

" vim-precious {{{1
" Filetype切り替えを無効にする（手動でPreciousSwitchする）
let g:precious_enable_switchers = {
\ "*": { "setfiletype": 0}
\}
" カーソル移動時のPreciousSwitchを無効にする
let g:precious_enable_switch_CursorMoved = {
\ "*": 0
\}
let g:precious_enable_switch_CursorMoved_i= {
\ "*": 0
\}
" カーソル位置から前後 300行の範囲で判定を行う
let g:context_filetype#search_offset = 300
" workflowish中の埋め込み判別
let g:context_filetype#filetypes = {
\ 'workflowish': [
\   {
\     'start': '^\s*```ruby',
\     'end': '^\s*```',
\     'filetype': 'ruby',
\   },
\   {
\     'start': '^\s*```sh',
\     'end': '^\s*```',
\     'filetype': 'sh',
\   },
\   {
\     'start': '^\s*```diff',
\     'end': '^\s*```',
\     'filetype': 'diff',
\   },
\   {
\     'start': '^\s*```vim',
\     'end': '^\s*```',
\     'filetype': 'vim',
\   },
\   {
\     'start': '^\s*```js',
\     'end': '^\s*```',
\     'filetype': 'javascript',
\   },
\   {
\     'start': '^\s*```coffee',
\     'end': '^\s*```',
\     'filetype': 'coffee',
\   },
\   {
\     'start': '^\s*```yaml',
\     'end': '^\s*```',
\     'filetype': 'yaml',
\   },
\ ],
\}

"}}}1-------------------------------------------------------------------------

