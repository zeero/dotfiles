" Last Change: 18-Sep-2014. {{{
" vim:ts=2:fdm=marker
" }}}
"-----------------------------------------------------------------------------
" 初期設定
"-----------------------------------------------------------------------------
" 初期設定 {{{1
" VI互換モードOFF
if has('vim_starting')
  set nocompatible
endif
" 内部エンコーディングをutf-8に指定
set encoding=utf-8
scriptencoding utf-8
" Winコマンドプロンプトではcp932
if !has('gui_running') && &encoding != 'cp932' && &term == 'win32'
  set termencoding=cp932
endif
" ファイルエンコーディング設定
set fencs=utf-8,cp932,euc-jp,iso-2022-jp
set ffs=unix,dos,mac
" キー入力をタイムアウトさせない
set notimeout
set ttimeout
" 高速ターミナル接続を行う
set ttyfast
" パス区切り文字を共通化する
set shellslash
" 自動コマンドの初期化
augroup myvimrc
  au!
augroup END
" 環境変数
let $MYVIMDIR = '~/.vim'
if !isdirectory($MYVIMDIR) && isdirectory($HOME . '/vimfiles')
  let $MYVIMDIR = '~/vimfiles'
endif
let $LANG = 'ja_JP.UTF-8'
" コンソール版で環境変数$DISPLAYが設定されていると起動が遅くなる件へ対応 {{{
if !has('gui_running') && has('xterm_clipboard')
  set clipboard=exclude:cons\\\|linux\\\|cygwin\\\|rxvt\\\|screen
endif "}}}

" NeoBundle {{{1
" 説明 {{{2
" COMMAND:
"  :NeoBundleInstall : Bundleされたプラグインをインストール
"  :NeoBundleSearch : vim-scriptにあるプラグインを検索
"
" NeoBundle開始 {{{2
filetype off
set rtp& rtp+=$MYVIMDIR/bundle/neobundle.vim
call neobundle#rc(expand($MYVIMDIR . '/bundle'))

" 基本 {{{2
NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundle 'Shougo/vimproc'
\, {'build': {
\    'windows': 'make -f make_mingw32.mak',
\    'cygwin':  'make -f make_cygwin.mak',
\    'mac':     'make -f make_mac.mak',
\    'unix':    'make -f make_unix.mak',
\  }}
NeoBundleLazy 'Shougo/vimshell'
\, {'autoload': {'commands': ['VimShell', 'VimShellPop']}
\,  'depends': 'Shougo/vimproc'}
if has('lua') && (v:version >= 704 || (v:version == 703 && has('patch885')))
  NeoBundleLazy 'Shougo/neocomplete'
  \, {'autoload': {'insert': 1}}
else
  NeoBundleLazy 'Shougo/neocomplcache'
  \, {'autoload': {'insert': 1}}
endif
NeoBundleLazy 'Shougo/neosnippet'
\, {'autoload': {'insert': 1
\,               'commands': ['NeoSnippetEdit']
\,               'unite_source': ['neosnippet']
\,               'filetypes': ['neosnippet']}}
NeoBundleLazy 'Shougo/neosnippet-snippets'
\, {'autoload': {'insert': 1}}
NeoBundle 'ctrlpvim/ctrlp.vim'
NeoBundleLazy 'Lokaltog/vim-easymotion'
\, {'autoload': {'mappings':
\    ['<Plug>(easymotion-bd-w)', '<Plug>(easymotion-s2)',
\     '<Plug>(easymotion-j)', '<Plug>(easymotion-k)']}}

" Unite {{{2
NeoBundleLazy 'Shougo/unite.vim'
\, {'autoload': {'commands': ['Unite', 'UniteWithBufferDir', 'UniteResume']}}
NeoBundleLazy 'Shougo/vimfiler'
\, {'autoload': {'commands': ['VimFiler', 'VimFilerBufferDir']}
\,  'depends': ['Shougo/unite.vim']}
NeoBundleLazy 'Shougo/unite-outline'
\, {'autoload': {'unite_sources': ['outline']}}
NeoBundleLazy 'osyo-manga/unite-fold'
\, {'autoload': {'unite_sources': ['fold']}}
NeoBundleLazy 'thinca/vim-unite-history'
\, {'autoload': {'unite_sources': ['history']}}
NeoBundleLazy 'tsukkee/unite-help'
\, {'autoload': {'unite_sources': ['help']}}
NeoBundleLazy 'tsukkee/unite-tag'
\, {'autoload': {'unite_sources': ['tag']}}
NeoBundleLazy 'basyura/unite-rails'
\, {'autoload': {'unite_sources': ['rails']}}
NeoBundleLazy 'ujihisa/unite-rake'
\, {'autoload': {'unite_sources': ['rake']}}
NeoBundleLazy 'ujihisa/unite-gem'
\, {'autoload': {'unite_sources': ['gem']}}
NeoBundleLazy 'ujihisa/unite-locate'
\, {'autoload': {'unite_sources': ['locate']}}
NeoBundleLazy 'ujihisa/unite-colorscheme'
\, {'autoload': {'unite_sources': ['colorscheme']}}
NeoBundleLazy 'osyo-manga/unite-highlight'
\, {'autoload': {'unite_sources': ['highlight']}}
NeoBundleLazy 'tacroe/unite-alias'
\, {'autoload': {'unite_sources': ['alias']}}
NeoBundleLazy 'mattn/unite-gist'
\, {'autoload': {'unite_sources': ['gist']}
\,  'depends': ['mattn/gist-vim']}
NeoBundleLazy 'pasela/unite-webcolorname'
\, {'autoload': {'unite_sources': ['webcolorname']}}
NeoBundleLazy 'zeero/unite-localrc'
\, {'autoload': {'unite_sources': ['localrc']}
\,  'depends': ['thinca/vim-localrc']}
NeoBundleLazy 'osyo-manga/unite-quickfix'
\, {'autoload': {'unite_sources': ['quickfix']}}

" 入力補助 {{{2
NeoBundleLazy 'tyru/caw.vim'
\, {'autoload': {'mappings': '<Plug>(caw:'}}
NeoBundleLazy 'thinca/vim-qfreplace'
\, {'autoload': {'filetypes': ['unite', 'quickfix']}}
NeoBundleLazy 'kana/vim-smartchr'
\, {'autoload': {'insert': 1}}
NeoBundleLazy 'autodate.vim'
\, {'autoload': {'insert': 1}}
NeoBundleLazy 'AndrewRadev/switch.vim'
\, {'autoload': {'commands': ['Switch']}}

" テキストオブジェクト {{{2
NeoBundleLazy 'kana/vim-textobj-user'
NeoBundleLazy 'kana/vim-textobj-fold'
\, {'autoload': {'mappings': [['ov', 'iz', 'az']]}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'kana/vim-textobj-entire'
\, {'autoload': {'mappings': '<Plug>(textobj-entire-'}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'kana/vim-textobj-line'
\, {'autoload': {'mappings': [['ov', 'il', 'al']]}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'kana/vim-textobj-indent'
\, {'autoload': {'mappings': [['ov', 'ii', 'ai']]}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'kana/vim-textobj-lastpat'
\, {'autoload': {'mappings': [['ov', 'i/', 'a/']]}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'syngan/vim-textobj-postexpr'
\, {'autoload': {'mappings': '<Plug>(textobj-postexpr-'}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'rhysd/vim-textobj-wiw'
\, {'autoload': {'mappings': '<Plug>(textobj-wiw-'}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'thinca/vim-textobj-between'
\, {'autoload': {'mappings': '<Plug>(textobj-between-'}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'sgur/vim-textobj-parameter'
\, {'autoload': {'mappings': [['ov', 'i,', 'a,']]}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'deris/vim-textobj-enclosedsyntax'
\, {'autoload': {'mappings': [['ov', 'iq', 'aq']]
\,               'filetypes': ['ruby', 'perl']}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'osyo-manga/vim-textobj-multiblock'
\, {'autoload': {'mappings': '<Plug>(textobj-multiblock-'}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'osyo-manga/vim-textobj-multitextobj'
\, {'autoload': {'mappings': '<Plug>(textobj-multitextobj-'}
\,  'depends': 'kana/vim-textobj-user'}
NeoBundleLazy 'tpope/vim-surround'
\, {'autoload': {'mappings':
\    [['n', 'cs']
\,    ['x', 'gS']
\,    ['n', 'ds']
\,    ['n', 'ySS']
\,    ['n', 'yss']
\,    ['n', 'ySs']
\,    ['n', 'yS']
\,    ['n', 'ys']
\,    ['i', '<C-G>S']
\,    ['i', '<C-G>s']
\,    ['i', '<C-S>']]}}

" オペレータ {{{2
NeoBundleLazy 'kana/vim-operator-user'
NeoBundleLazy 'kana/vim-operator-replace.git'
\, {'autoload': {'mappings': '<Plug>(operator-replace)'}
\,  'depends': ['kana/vim-operator-user']}
" NeoBundleLazy 'rhysd/vim-operator-surround'
NeoBundleLazy 'zeero/vim-operator-surround', 'keep_input_option'
\, {'autoload': {'mappings': '<Plug>(operator-surround-'}
\,  'depends': ['kana/vim-operator-user']}
NeoBundleLazy 'tyru/operator-camelize.vim'
\, {'autoload': {'mappings': '<Plug>(operator-camelize-'}
\,  'depends': ['kana/vim-operator-user']}
NeoBundleLazy 'tyru/operator-html-escape.vim'
\, {'autoload': {'mappings': '<Plug>(operator-html-'}
\,  'depends': ['kana/vim-operator-user']}
NeoBundleLazy 'tyru/operator-reverse.vim'
\, {'autoload': {'mappings': '<Plug>(operator-reverse-'}
\,  'depends': ['kana/vim-operator-user']}
NeoBundleLazy 'terryma/vim-expand-region'
\, {'autoload': {'mappings': '<Plug>(expand_region_'}}

" コマンド {{{2
NeoBundleLazy 'thinca/vim-ref'
\, {'autoload': {'commands': ['Ref']
\,               'unite-sources': ['ref']}
\,  'depends': ['mattn/webapi-vim']}
NeoBundle 'mojako/ref-sources.vim'
NeoBundle 'thinca/vim-quickrun'
" \, {'autoload': {'commands': ['QuickRun']
" \,               'mappings': '<Plug>(quickrun)'}}
NeoBundle 'osyo-manga/shabadou.vim'
\, {'depends': ['thinca/vim-quickrun']}
NeoBundle 'tpope/vim-fugitive'
\, {'augroup': 'fugitive'}
NeoBundleLazy 'mattn/gist-vim'
\, {'autoload': {'commands': ['Gist']}
\,  'depends': ['mattn/webapi-vim']}
NeoBundleLazy 'gregsexton/gitv'
\, {'autoload': {'commands': ['Gitv']}
\,  'depends': ['tpope/vim-fugitive']}
NeoBundleLazy 'majutsushi/tagbar'
\, {'autoload': {'commands': ['TagbarToggle', 'TagbarOpen']}}
NeoBundleLazy 'tyru/restart.vim'
\, {'autoload': {'commands': ['Restart']}
\,  'gui': 1}
NeoBundleLazy 'sjl/gundo.vim'
\, {'autoload': {'commands': ['GundoToggle']}}
NeoBundleLazy 't9md/vim-quickhl'
\, {'autoload': {'mappings': '<Plug>(quickhl-'}}
NeoBundleLazy 'AndrewRadev/linediff.vim'
\, {'autoload': {'commands': ['Linediff']}}
NeoBundleLazy 'thinca/vim-prettyprint'
\, {'autoload': {'commands': ['PP']}}
NeoBundleLazy 'AndrewRadev/splitjoin.vim'
\, {'autoload': {'commands': ['SplitjoinSplit', 'SplitjoinJoin']}}
NeoBundleLazy 'thinca/vim-scall'
\, {'autoload': {'commands': ['Scall']}}
NeoBundleLazy 'osyo-manga/vim-over'
\, {'autoload': {'commands': ['OverCommandLine']}}
NeoBundleLazy 'http://conque.googlecode.com/svn/trunk/'
\, {'autoload': {'commands': ['ConqueTerm', 'ConqueTermSplit', 'ConqueTermTab', 'ConqueTermVSplit']
\,               'functions': ['conque_term#open', 'conque_term#subprocess', 'conque_term#register_function']}
\,  'name': 'Conque'}
NeoBundleLazy 'h1mesuke/vim-alignta.git'
\, {'autoload': {'commands': ['Align']}}
NeoBundleLazy 'copypath.vim'
\, {'autoload': {'commands': ['CopyPath', 'CopyFileName']}}
NeoBundleLazy 'jceb/vim-editqf'
\, {'autoload': {'commands': ['QFAddNote']}}

" 表示 {{{2
NeoBundle 'itchyny/lightline.vim'
NeoBundleLazy 'fholgado/minibufexpl.vim'
\, {'autoload': {'commands': ['MBEbp', 'MBEbn', 'MBEToggle']}
\,  'augroup': 'MiniBufExpl'}
NeoBundle 'molokai'
\, {'terminal': 1}
NeoBundle 'http://blog.toddwerth.com/entry_files/8/ir_black.vim'
\, {'name': 'ir_black.vim'
\,  'script_type': 'colors'
\,  'gui': 1}
" 普段使わないカラースキームは使用時に:NeoBundleSource
NeoBundleLazy 'wombat256.vim'
NeoBundleLazy 'altercation/vim-colors-solarized'
NeoBundleLazy 'w0ng/vim-hybrid'
NeoBundleLazy 'nanotech/jellybeans.vim'
NeoBundleLazy 'jpo/vim-railscasts-theme'
NeoBundleLazy 'jonathanfilip/vim-lucius'
NeoBundleLazy 'Zephyr-Color-Scheme'
NeoBundleLazy 'cocopon/iceberg.vim'
NeoBundleLazy 'newspaper.vim'
NeoBundleLazy 'thinca/vim-guicolorscheme'
\, {'autoload': {'commands': ['GuiColorScheme']}
\,  'terminal': 1}
NeoBundleLazy 'godlygeek/csapprox'
\, {'autoload': {'commands': ['CSApproxSnapshot']}
\,  'gui': 1}
NeoBundleLazy 'ScrollColors'
\, {'autoload': {'commands': ['SCROLLCOLOR']}}
NeoBundleLazy 'cocopon/colorswatch.vim'
\, {'autoload': {'commands': ['ColorSwatchGenerate']}}
NeoBundle 'osyo-manga/vim-anzu'
NeoBundle 'itchyny/landscape.vim'

" 補助 {{{2
NeoBundle 'thinca/vim-singleton'
\, {'gui': 1}
NeoBundle 'thinca/vim-localrc'
NeoBundle 'vim-jp/vimdoc-ja'
NeoBundleLazy 'plasticboy/vim-markdown'
\, {'autoload': {'filetypes': ['mkd']}}
NeoBundleLazy 'mattn/webapi-vim'
NeoBundleLazy 'tyru/open-browser.vim'
\, {'autoload': {'filetypes': ['html', 'mkd']
\,               'mappings': '<Plug>(openbrowser-'}}
NeoBundleLazy 'mattn/benchvimrc-vim'
\, {'autoload': {'commands': ['BenchVimrc']}}
NeoBundle 'haya14busa/vim-migemo'
NeoBundle 'rhysd/migemo-search.vim'
NeoBundleLazy 'sudo.vim'
\, {'autoload': {'commands': ['SudoWrite', 'SudoRead']}}
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundleLazy 'thinca/vim-splash'
\, {'autoload': {'commands': ['Splash']}}
NeoBundleLazy 'mklabs/vim-cowsay'
\, {'autoload': {'commands': ['Cowsay']}}
NeoBundle 'mhinz/vim-startify'
\, {'augroup': 'startify'}
NeoBundleLazy 'taku-o/vim-zoom'
\, {'autoload': {'commands': ['ZoomIn', 'ZoomOut', 'ZoomReset']
\,               'mappings': [['n', '+'], ['n', '-']]}
\,  'gui': 1}
NeoBundleLazy 'yonchu/accelerated-smooth-scroll'
\, {'autoload': {'mappings': '<Plug>(ac-smooth-scroll-'}}
NeoBundleLazy 'ShowMarks'
\, {'autoload': {'commands': ['ShowMarksToggle']}}
NeoBundleLazy 'AnsiEsc.vim'
\, {'autoload': {'commands': ['AnsiEsc']}}
NeoBundleLazy 'kana/vim-submode'
\, {'autoload': {'mappings': [['n', 'x']]}}
NeoBundleLazy 'tpope/vim-repeat'
\, {'autoload': {'mappings': ['.']}}
NeoBundleLazy 'fuenor/qfixhowm'
\, {'autoload': {'mappings': ['g,c', 'g,m']}}

" Ruby {{{2
NeoBundleLazy 'tpope/vim-rails'
\, {'autoload': {'filetypes': ['ruby']}}
NeoBundle 'taka84u9/vim-ref-ri'
" \, {'autoload': {'filetypes': ['ruby']
" \,               'unite_sources': ['ref/ri']}
" \,  'depends': 'thinca/vim-ref'}
NeoBundle 'edsono/vim-matchit'
" NeoBundleLazy 'tpope/vim-bundler'
" \, {'autoload': {'filetypes': ['ruby']}}

" HTML/JavaScript {{{2
NeoBundleLazy 'mattn/emmet-vim'
\, {'autoload': {'filetypes': ['html']}
\,               'insert': 1}
" NeoBundleLazy 'jiangmiao/simple-javascript-indenter'
" \, {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'jelera/vim-javascript-syntax'
\, {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'jQuery'
\, {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'https://bitbucket.org/teramako/jscomplete-vim'
\, {'autoload': {'filetypes': ['javascript']
\,               'insert': 1}
\,  'type': 'git'}
NeoBundleLazy 'scrooloose/syntastic'
\, {'autoload': {'insert': 1}}

" Java {{{2
NeoBundleLazy 'http://www.fleiner.com/vim/syntax_60/javaid.vim'
\, {'autoload': {'filetypes': ['java']}
\,  'name': 'javaid.vim'
\,  'type': 'raw'
\,  'script_type': 'syntax'}

" VimScript {{{2
NeoBundleLazy 'vim-jp/vital.vim'
\, {'autoload': {'commands': ['Vitalize']}}
NeoBundle 'kana/vim-vspec'
NeoBundle 'rhysd/vim-vspec-matchers'
NeoBundleLazy 'Shougo/vesting'
\, {'autoload': {'unite_sources': ['vesting']}}

" ローカル {{{2
if isdirectory(expand($MYVIMDIR) . '/bundle.local')
  NeoBundleLocal $MYVIMDIR/bundle.local
endif

" NeoBundle終了 {{{2
filetype plugin indent on
" インストールチェック
NeoBundleCheck

" NeoBundleコマンド定義 {{{2
command! Bi NeoBundleInstall
command! Bu NeoBundleUpdate
command! -nargs=? Bs NeoBundleSearch <args>
command! Bc NeoBundleClean
command! Bls NeoBundleList
command! Blog NeoBundleLog
command! -nargs=? Bso NeoBundleSource <args>

" singleton.vim {{{1
if has('gui_running')
  let g:singleton#opener = 'tab drop'
  call singleton#enable()
endif

" プラグイン無効化 {{{1
let g:loaded_gzip = 1
let g:loaded_tar = 1
let g:loaded_tarPlugin = 1
let g:loaded_zip = 1
let g:loaded_zipPlugin = 1

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" 基本設定
"-----------------------------------------------------------------------------
" 検索に関する設定 {{{1
" 検索時に大文字小文字を無視 (noignorecase:無視しない)
set ignorecase
" 大文字小文字の両方が含まれている場合は大文字小文字を区別
set smartcase
" インクリメンタルな検索
set incsearch
" 検索結果文字列のハイライトを有効にする
set hlsearch
" 検索時にファイルの最後まで行ったら最初に戻る (nowrapscan:戻らない)
set wrapscan
" タグ検索パスの設定
"set tags=./tags,tags
au myvimrc FileType * exe "setlocal tags+="
\ . $HOME . "/.tags/" . &ft . ".tags,"
\ . $HOME . "/.tags/tags"
" タグ検索に二分検索をオフにする（vimdoc-jaフリーズ対策）
set notagbsearch
" バックスラッシュやクエスチョンを状況に合わせ自動的にエスケープ
cnoremap <expr> / getcmdtype() == '/' ? '\/' : '/'
cnoremap <expr> ? getcmdtype() == '?' ? '\?' : '?'

" 編集に関する設定 {{{1
" タブの画面上での幅
set tabstop=2
set shiftwidth=2
set softtabstop=2
" タブをスペースに展開する (noexpandtab:展開しない)
set expandtab
" 自動的にインデントする (noautoindent:インデントしない)
set autoindent
" 高度なオートインデント
set smartindent
" '<'や'>'でインデントする際に'shiftwidth'の倍数に丸める
set shiftround
" バックスペースでインデントや改行を削除できるようにする
set backspace=2
" 括弧入力時に対応する括弧を表示 (noshowmatch:表示しない)
set showmatch
" 対応括弧のハイライト表示の秒数
set matchtime=1
" 対応括弧に'<'と'>'のペアを追加
set matchpairs& matchpairs+=<:>
" コマンドライン補完するときに強化されたものを使う
set wildmenu
set wildmode=list:longest,full
" テキスト挿入中の自動折り返しを日本語に対応させる
set formatoptions&
set formatoptions+=mM
" コメント行で'o'で改行したらコメントをつけない
" ftpluginで上書きされてしまうためauでなんとかする
au myvimrc BufRead,BufNew,BufNewFile * set formatoptions-=o
" 文字数による自動折り返しはしない
set textwidth=0
" 区切り文字設定（単語の一部とする文字の設定）
"   Macではデフォルトの'iskeyword'がcp932に対応しきれていないので修正
"     @ : アルファベット
"     48-57 : 数字
"     128-167,224-235,192-255 : Extended ASCII characters（日本語には関係ない）
if has('mac')
  set iskeyword=@,48-57,_,128-167,224-235
  " '-'も単語の一部と認識させる
  set iskeyword+=-
else
  " '-'も単語の一部と認識させる
  set iskeyword&
  set iskeyword+=-
endif
" 日本語整形スクリプト(by. 西岡拓洋さん)用の設定
let format_allow_over_tw = 1	" ぶら下り可能幅
" 編集後保存していなくても別のファイルを開く
" set hidden
" 新しく開く代わりにすでに開いてあるバッファを開く
set switchbuf=useopen
" コマンドライン履歴
set history=1000
" 外部のエディタで編集中のファイルが変更されたら自動で読み直す
" （ウィンドウを移動する度に変更をチェックする）
set autoread
au myvimrc WinEnter * checktime
" クイックフィックスは常にcwindowで表示する
autocmd myvimrc QuickFixCmdPost [^l]* nested botright cwindow
autocmd myvimrc QuickFixCmdPost    l* nested botright lwindow
" 補完時に大文字小文字を区別しない
set infercase
" カーソルを文字が存在しない部分でも動けるようにする
" set virtualedit=all
" 行頭行末で前行次行に移動する
" set whichwrap=b,s,h,l,<,>,[,]
" <C-a>で8進数は除く
set nrformats-=octal
" スクロールの設定
set scrolloff=3
set sidescroll=0
set sidescrolloff=9
" ビープ音を消す
set visualbell t_vb=

" 画面表示の設定 {{{1
" シンタックスハイライト
syntax enable
" カラースキーマ設定
set t_Co=256
if has('gui_running')
  set background=dark
  colorscheme ir_black
else
"   let g:molokai_original = 1
  let g:rehash256 = 1
  colorscheme molokai
"   solarized {{{
"   set background=dark
"   let g:solarized_termcolors = 256
"   let g:solarized_termtrans = 1
"   let g:solarized_contrast = "high"
"   let g:solarized_visibility = "high"
"   colorscheme solarized
"   }}}
endif
" 遅延描画
" set lazyredraw
" 行を強調表示
set cursorline
" 行番号を表示 (nonumber:表示)
set number
" 行番号の左に余白をとる
" au myvimrc BufEnter,WinEnter,BufWinEnter * let &l:numberwidth = len(line("$")) + 2
" ルーラーを表示 (noruler:非表示)
set ruler
" タイトルを表示
set title
" 終了後のウィンドウタイトル
set titleold=vim
" タブや改行を表示 (nolist:非表示)
set list
" どの文字でタブや改行を表示するかを設定
set listchars=tab:»-,trail:-,extends:»,precedes:«,nbsp:%
" タブの左側にカーソル表示
"set listchars=tab:\ \
" 全角スペースも表示　
highlight JpSpace cterm=underline ctermfg=darkgrey gui=underline guifg=darkgrey
au myvimrc BufRead,BufNew * match JpSpace /　/
" □や○の文字があってもカーソル位置をずらさせない
set ambiwidth=double
" 画面最後の行を出来る限り表示する
set display&
set display+=lastline
" modelineを無視する
"set nomodeline
" フォールディング方式の指定（マーカー使用）(=fdm)
set foldmethod=marker
" 長い行を折り返して表示 (nowrap:折り返さない)
set wrap
" コマンドラインの高さ (Windows用gvim使用時はgvimrcを編集すること)
set cmdheight=1
" コマンドをステータス行に表示
set showcmd
" 常にステータス行を表示 (詳細は:he laststatus)
set laststatus=2
" ステータスラインに文字コードと改行文字とファイルタイプを表示する
"set statusline=%<%f\%m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%l,%c
"set statusline=%<%t\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']['.&ft.']'}%=%l,%c%V%8P
" タブは非表示
"set showtabline=0
" vsplitは右に開く
set splitright
" 画面サイズが広い場合はバッファを右に移動させる
" TODO: Unite開くと低くなる
"au myvimrc BufRead,BufNew,BufNewFile * if winwidth(0) > 140 | wincmd L | wincmd _ | endif

" GUI固有の画面表示の設定 {{{1
if has('gui_running')
  set guioptions&
  " メニューファイルが存在しない場合、menu.vimを読み込まない
  if !filereadable($VIMRUNTIME . '/menu.vim')
    set guioptions+=M
  endif
  " ビジュアル選択を自動的にクリップボードへ
  "set guioptions+=a
  " スクロールバーを非表示にする
  set guioptions-=r
  set guioptions-=R
  set guioptions-=l
  set guioptions-=L
  " フォントを指定
  if has('win32') || has('win64')
    set guifont=Ricty_Diminished:h12:cSHIFTJIS
  else
    set guifont=Ricty\ Diminished\ Regular:h20
    let g:vimshell_editor_command = "/Applications/MacPorts/MacVim.app/Contents/MacOS/Vim"
  endif
  " ウィンドウサイズを最大化する
  if has('win32') || has('win64')
    au myvimrc GUIEnter * simalt ~x
  endif
  " 透明度
  if has('mac')
    set transparency=12
  endif
  " ヤンクでクリップボードを共有する
  "if has('clipboard')
  "  set clipboard=unnamed
  "endif
  " マウスを有効にする
  if has('mouse')
    set mouse=a
  endif
  " IME制御をオフにする
  set iminsert=0
  set imsearch=0
  set noimcmdline
  " Alt+CとAlt+Pでコピペする
  vnoremap <M-c> "+y
  inoremap <M-v> <C-r>+
  cnoremap <M-v> <C-r><C-o>+
  " C-Scrollでフォントサイズ変更（要Zoom.vim）
  nnoremap <C-ScrollWheelUp> :ZoomIn<CR>
  nnoremap <C-ScrollWheelDown> :ZoomOut<CR>
  " バッファがローカルバッファに表示されなくなった場合は削除する
  " （[No Name]バッファへの対策）
  set bufhidden=wipe
  " タブのラベル
  set guitablabel=%n:%t
  " 印刷オプション
  set printoptions=wrap:y,number:y
endif

" ファイル操作に関する設定 {{{1
" バックアップファイル、swapファイルを作成しない
set nobackup
set nowritebackup
set noswapfile
" スワップファイルの作成ディレクトリにパスを追加
" set directory&
" set directory+=,~/tmp,$TMP
" 永続undo
if has('persistent_undo')
  set undodir=$HOME/.vimundo
  set undofile
endif
" ファイルを開くと、そのファイルと同じディレクトリに移動
" 名無しのvim使い <http://nanasi.jp/articles/vim/cd_vim.html>
au myvimrc BufRead * if isdirectory(expand("%:p:h")) | exe "lcd" expand("%:p:h") | endif
"set autochdir （設定するとVimShellが動かなくなる）
" 前回終了したカーソル行に移動して真ん中にする（フォールドがあれば開く）
" TODO: 真ん中にならない。たぶんなんかのプラグインが悪さしてる。
au myvimrc BufRead * call s:my_readpost_move()
function! s:my_readpost_move()
  if line("'\"") > 0 && line("'\"") <= line("$")
    exe "normal! g`\""
  endif
  exe "normal! zvz\<CR>"
endfunction

" ファイルタイプ別の設定 {{{1
" Vim
" vimrcの保存時に再読み込み
if !has('gui_running')
  au myvimrc BufWritePost *vimrc nested source $MYVIMRC |
  \ call localrc#load(g:localrc_filename)
else
  au myvimrc BufWritePost *vimrc nested source $MYVIMRC |
  \ if filereadable($MYGVIMRC) | source $MYGVIMRC | endif |
  \ call localrc#load(g:localrc_filename)
endif
" バックスラッシュのインデントを無くす
let g:vim_indent_cont = 0
" vimrc、helpでは:もiskに入れる
if expand("%") =~ "vimrc"
  setlocal iskeyword+=:,#
endif
au myvimrc FileType help setlocal iskeyword+=:
" vimrcは起動時だったらgit pull
" au myvimrc VimEnter *vimrc call s:my_vimenter_vimrc()
function! s:my_vimenter_vimrc() "{{{
  exe "lcd " . expand("%:p:h")
  if exists('*fugitive#head')
    call s:my_git_vimproc('pull')
  endif
  checktime
endfunction "}}}

" NeoSnippet
au myvimrc FileType neosnippet setlocal nofoldenable
" fugitive
au myvimrc FileType gitcommit
\ setlocal nofoldenable |
\ wincmd L |
\ noh |
\ let @/ = "^@@ .*"
" diff
" TODO: normal ]cが効かない…
au myvimrc BufRead * if 1 == &diff | noh | exe "normal! ]c" | endif

" html
" 閉じタグの自動入力設定
au myvimrc FileType html,xml inoremap <expr> <buffer> > MyHtmlEndwise()
function! MyHtmlEndwise() "{{{
  let val = ">"
  let col = col(".")
  let str = getline(".")
  let idx = strridx(str, "<", col - 2)
  let idx_slash = strridx(str, "/", col - 1)
  echomsg "idx:" . idx
  echomsg "idx_slash:" . idx_slash
  if idx == -1 || idx < idx_slash
    return val
  endif
  let val .= substitute(strpart(str, idx, col - 1 - idx), '<\([^ ]\+\).*', '</\1>', '')
  return val . "\<Esc>" . col . "|a"
endfunction "}}}
" Java
" ハイライト設定
let java_highlight_all = 1
let java_highlight_functions = "style"
let java_highlight_debug = 1

" ファイルタイプ指定
" JavaScript
au myvimrc BufRead,BufNew,BufNewFile *.json setlocal ft=javascript
au myvimrc BufRead,BufNew,BufNewFile jquery.*.js setlocal ft=javascript syntax=jquery
" Apache
au myvimrc BufRead,BufNew,BufNewFile httpd*.conf setlocal ft=apache
" ctags
au myvimrc BufRead,BufNew,BufNewFile *.tags setlocal ft=tags

" コマンド定義 {{{1
" ユーティリティ {{{2
" H(elp)
command! -nargs=? -complete=help H if winwidth(0) > 140 | botright vertical help <args> | vertical resize 79 | else | help <args> | endif
" H(elp)f(unction-list)
command! -nargs=0 Hf H function-list
" K(otoba)
command! -nargs=1 K Ref kotobankej <args>
" Vimrc
command! Vimrc tabe $MYVIMRC
" So
command! So source %
" Bdo
command! Bdo call s:my_command_bd_other()
function! s:my_command_bd_other() "{{{
  let i = 1
  let cur = bufnr("%")
  while i <= bufnr("$")
    if buflisted(i) && i != cur
      exe "bdelete" i
    endif
    let i = i + 1
  endwhile
endfunction "}}}
" Lcd
command! Lcd exe "lcd " . expand("%:p:h") | pwd
" LcdLocalrc
command! LcdLocalrc exe "lcd " . fnamemodify(get(reverse(localrc#search(get(g:, 'localrc_filename'))), 0), ":p:h") | pwd
" Ls
command! -nargs=* -complete=file Ls echo vimproc#system("ls <args>")
" Noh
command! Noh noh | QuickhlManualReset
" Info
nnoremap <C-g> :<C-u>Info<CR>
command! Info call s:my_info()
function! s:my_info() "{{{
  " ファイル名、パス
  echohl Identifier
  echo expand("%:t")
  echohl None
  echo expand("%:p")
  " 行数など
  let old_status = v:statusmsg
  exe "silent normal! g\<C-g>"
  let msg = split(v:statusmsg, "; ")
  for line in msg
    echo line
  endfor
  let v:statusmsg = old_status
  " ステップカウンタ
  let countEmpty = 0
  let countComment = 0
  let countSource = 0
  let lnum = 1
  while lnum <= line("$")
    if getline(lnum) =~ '^\s*$'
      let countEmpty = countEmpty + 1
    elseif synIDattr(synIDtrans(synID(lnum, match(getline(lnum), '\S') + 1, 1)), "name") == 'Comment'
      let countComment = countComment + 1
    else
      let countSource = countSource + 1
    endif
    let lnum = lnum + 1
  endwhile
  echo "空白行：" . countEmpty
  echo "コメント行：" . countComment
  echo "ソース行：" . countSource
endfunction "}}}
" Open
command! Open call vimproc#open(expand("%:p:h"))

" Diff
command! -nargs=0 DF windo diffthis | set ve=all
" Diffoff
command! -nargs=0 DFOff windo diffoff | set ve=
" DiffWith
command! -complete=file -nargs=1 DiffWith vertical diffsplit <args>
" DiffOrig（編集前とdiff）
command! -nargs=0 DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis

" QFClear
command! -nargs=0 QFClear call setqflist([])
" LocalInit
command! -nargs=0 LocalInit call s:my_local_init()
let g:my_local_init_skel_file = $MYVIMDIR . '/skel/local_init.vim'
function! s:my_local_init() "{{{
  call vimproc#system("cp -f " . g:my_local_init_skel_file . " ./.local.vimrc")
  call vimproc#system("ctags -R -f tags " . s:my_path_convert(getcwd()))
endfunction "}}}

" TortoiseSVN
" /endrev:-1 は HEAD（-2：ベースリビジョン、-3：ワーキングコピー）
if executable('TortoiseProc')
  command! TSVNLog silent call vimproc#system_bg('TortoiseProc /command:log /path:"'.expand("%").'" /notempfile /closeonend')
  command! TSVNLogDir silent call vimproc#system_bg('TortoiseProc /command:log /path:. /notempfile /closeonend')
  command! TSVNDiff silent call vimproc#system_bg('TortoiseProc /command:diff /path:"'.expand("%").'" /notempfile /closeonend')
  command! TSVNUpdate silent call vimproc#system_bg('TortoiseProc /command:update /path:"'.expand("%").'" /notempfile /closeonend')
  command! TSVNUpdateDir silent call vimproc#system_bg('TortoiseProc /command:update /path:. /notempfile /closeonend')
  command! TSVNCommit silent call vimproc#system_bg('TortoiseProc /command:commit /path:"'.expand("%").'" /notempfile /closeonend')
  command! TSVNRevert silent call vimproc#system_bg('TortoiseProc /command:revert /path:"'.expand("%").'" /notempfile /closeonend')
  command! TSVNProps silent call vimproc#system_bg('TortoiseProc /command:properties /path:"'.expand("%:h").'" /notempfile /closeonend')
  command! TSVNBlame silent call vimproc#system_bg('TortoiseProc /command:blame /path:"'.expand("%").'" /notempfile /closeonend /line:'.line(".").' /startrev:1 /endrev:-1')
endif

" LoadYAML
command! -nargs=1 LoadYAML echo s:my_load_yaml(<args>)
function! s:my_load_yaml(file) "{{{
  perl << EOF
use YAML::Syck;
use JSON::Syck qw(Dump);
eval {
  VIM::DoCommand("let ret = " . Dump(LoadFile("".VIM::Eval('a:file'))));
};
VIM::DoCommand("let v:errmsg = substitute('$@', \"\\n\", '', 'g')") if $@;
EOF
  if !exists('ret')
    throw v:errmsg
  endif
  return ret
endfunction "}}}

" 別ウィンドウ系 {{{2
" Esnip
command! -nargs=? -complete=customlist,neosnippet#commands#_edit_complete Esnip NeoSnippetEdit -vertical -split <args>
" Vimdoc
command! Vimdoc OpenBrowser http://vim-jp.org/vimdoc-ja/
" Cygwin
command! Cygwin call s:my_cygwin()
function! s:my_cygwin() "{{{
  let my_conque_term = conque_term#open($CYGWIN_HOME . '\Cygwin.bat', ['topleft split', 'resize 10'])
  while my_conque_term.read() == ''
  endwhile
  call my_conque_term.writeln('cd ' . MyGetCygwinDir(getcwd()))
endfunction "}}}
function! MyGetCygwinDir(fullpath) "{{{
  return "/cygdrive/" . substitute(a:fullpath, ':', '', '')
endfunction "}}}

" カラーリング {{{2
" SyntaxInfo
command! SyntaxInfo call s:get_syn_info()
function! s:get_syn_id(transparent) "{{{
  let synid = synID(line("."), col("."), 1)
  if a:transparent
    return synIDtrans(synid)
  else
    return synid
  endif
endfunction
function! s:get_syn_attr(synid)
  let name = synIDattr(a:synid, "name")
  let ctermfg = synIDattr(a:synid, "fg", "cterm")
  let ctermbg = synIDattr(a:synid, "bg", "cterm")
  let guifg = synIDattr(a:synid, "fg", "gui")
  let guibg = synIDattr(a:synid, "bg", "gui")
  return {
        \ "name": name,
        \ "ctermfg": ctermfg,
        \ "ctermbg": ctermbg,
        \ "guifg": guifg,
        \ "guibg": guibg}
endfunction
function! s:get_syn_info()
  let baseSyn = s:get_syn_attr(s:get_syn_id(0))
  echo "name: " . baseSyn.name .
        \ " ctermfg: " . baseSyn.ctermfg .
        \ " ctermbg: " . baseSyn.ctermbg .
        \ " guifg: " . baseSyn.guifg .
        \ " guibg: " . baseSyn.guibg
  let linkedSyn = s:get_syn_attr(s:get_syn_id(1))
  echo "link to"
  echo "name: " . linkedSyn.name .
        \ " ctermfg: " . linkedSyn.ctermfg .
        \ " ctermbg: " . linkedSyn.ctermbg .
        \ " guifg: " . linkedSyn.guifg .
        \ " guibg: " . linkedSyn.guibg
endfunction "}}}
" Colortest
command! Colortest belowright vsplit $VIMRUNTIME/syntax/colortest.vim | source $VIMRUNTIME/syntax/colortest.vim
" Hitest
command! Hitest belowright vsplit $VIMRUNTIME/syntax/hitest.vim | source $VIMRUNTIME/syntax/hitest.vim

" 共通ファンクション {{{2
" パス変換
function! s:my_path_convert(path) "{{{
  if has('win32') || has('win64')
    let system_enc = 'cp932'
    let path_separater = '\\\\'
  else
    let system_enc = 'utf-8'
    let path_separater = '/'
  endif

  let path = iconv(a:path, &encoding, system_enc)
  return substitute(path, '/', path_separater, 'g')
endfunction "}}}

" キーマップ定義 {{{1
" 説明 {{{2
" map系はリンク先のコマンドを再帰的に展開する。
" noremap系はリンク先のコマンドを再帰的に展開しない。
" -----------------------------------------------------------------------------------"
"  コマンド        | n | i | c | v | s | o |
" -----------------|---|---|---|---|---|---|
"  map  / noremap  | @ | - | - | @ | @ | @ |
"  nmap / nnoremap | @ | - | - | - | - | - |
"  vmap / vnoremap | - | - | - | @ | @ | - |
"  omap / onoremap | - | - | - | - | - | @ |
"  xmap / xnoremap | - | - | - | @ | - | - |
"  smap / snoremap | - | - | - | - | @ | - |
"  map! / noremap! | - | @ | @ | - | - | - |
"  imap / inoremap | - | @ | - | - | - | - |
"  cmap / cnoremap | - | - | @ | - | - | - |
"  コマンド | ノーマル | 挿入 | コマンドライン | ビジュアル | 選択 | 演算待ち |
" -----------------------------------------------------------------------------------"
" 基本的にはnoremap系を使用する。
"   カーソル移動 => nnoremap
"   範囲選択     => vnoremap & onoremap
"     ビジュアルモードだけでセレクトモードを除くならxnoremp
"   テキスト入力補助 => inoremap
"   機能呼び出し => cnoremap
" <Nop>をリンク先に指定することでキーマップを無効にする。
" KEYMAP:
" 移動 {{{2
" 表示行単位で行移動
nnoremap j gj
nnoremap k gk
xnoremap j gj
xnoremap k gk
" 行末に移動
nnoremap <C-e> $
" 0/^のトグル
nnoremap <expr> 0 match(getline("."), '\S') == col(".") - 1 ? '0' : '^'
nnoremap <expr> ^ match(getline("."), '\S') == col(".") - 1 ? '0' : '^'
" diffハンクへのジャンプ
nnoremap g[ [czz
nnoremap g] ]czz
nnoremap do do]czz
nnoremap dp dp]czz
" markへのジャンプ
nnoremap gm `

" 検索 {{{2
" 検索語が真ん中にくるようにする
" noremap n nzvzz
" noremap N Nzvzz
noremap * *zvzz
" nnoremap # #zvzz
noremap g* g*zvzz
noremap g# g#zvzz
noremap { {zz
noremap } }zz
" #でも検索方向を揃える
noremap # *NNzvzz
" 選択した単語で検索
vnoremap / y/<C-r>"

" ウィンドウ／タブ {{{2
" バッファ移動用キーマップ
" nnoremap <Tab> <Esc>:MBEbn<CR>
" nnoremap <S-Tab> <Esc>:MBEbp<CR>
" タブページ操作
nnoremap L <C-PageDown>
nnoremap H <C-PageUp>
nnoremap t :<C-u>tabnew<CR>
nnoremap ,l :<C-u>tabm<CR>
nnoremap ,L :<C-u>tabm 0<CR>
" gfはタブで開く
nnoremap gf :tabe <cfile><CR>
vnoremap gf y:tabe <C-r>"<CR>
" ウィンドウサイズ変更
nnoremap <S-Up> <C-w>+
nnoremap <S-Down> <C-w>-
nnoremap <S-Left> <C-w><
nnoremap <S-Right> <C-w>>
" QuickFix、fugitiveでは<Esc><Esc>でバッファを閉じる
au myvimrc FileType qf,gitcommit nnoremap <buffer> <Esc><Esc> <C-w>c
" qでウィンドウを閉じる、マクロはQ（EXモードは使わない）
nnoremap q :<C-u>q<CR>
nnoremap Q q

" タグジャンプ {{{2
nnoremap <C-]> g<C-]>
vnoremap <C-]> g<C-]>
nnoremap ,] g<C-]>
vnoremap ,] g<C-]>
nnoremap <C-j> :tab tj <C-R>=expand('<cword>')<CR><CR>
vnoremap <C-j> y:tab tj <C-r>"<CR>
nnoremap ,[ <C-t>
nnoremap <C-k> <C-t>
nnoremap <C-h> <C-o>z<CR>
nnoremap <C-l> <C-i>z<CR>

" ノーマルモード操作 {{{2
" 行末までヤンク
nnoremap Y y$
" すべてのフォールディングの開け閉め
nnoremap zO zRz<CR>
nnoremap zC zMz<CR>
nnoremap zo zvz<CR>
nnoremap zc zcz<CR>
" 水平スクロール
nnoremap zh 4zh4zh4zh4zh4zh4zh
nnoremap zl 4zl4zl4zl4zl4zl4zl
nnoremap zH zh
nnoremap zL zl
" 直前に変更またはヤンクした文字を選択
nnoremap gp `[v`]
" カーソル位置から末尾までビジュアル選択
nnoremap ,v v$
" PASTEモードでクリップボード貼り付け
nnoremap ,p :<C-u>set paste<CR>i<C-r>+<Esc>:<C-u>set nopaste<CR>
" URLを開く
let g:netrw_nogx = 1 " disable netrw's gx mapping.
map gx <Plug>(openbrowser-smart-search)
" Esc+noh
nnoremap <silent> <Esc> <Esc>:<C-u>noh<CR>
" CopyFileName
nnoremap gy :<C-u>CopyFileName<CR>

" オペレータ {{{2
" replace
map c <Plug>(operator-replace)
map C <Plug>(operator-replace)$
" カーソル下の文字列を置換
nnoremap ,c :%s/\<<C-r><C-w>\>//gc<Left><Left><Left>
" 選択した文字列を置換
vnoremap ,c "xy:%s/<C-r>=escape(@x, '\\/.*$^~[]')<CR>//gc<Left><Left><Left>
" surround
map s <Plug>(operator-surround-append)
map S <Plug>(operator-surround-delete)
map <C-s> <Plug>(operator-surround-replace)
let g:operator#surround#enable_xbrackets_mode = 1 " 定義済みブロックが現れるまでテキスト保持
" snake_case<=>CamelCase
map _ <Plug>(operator-camelize-toggle)
" HTMLエスケープ
" vmap ; <Plug>(operator-html-escape)
" 反転
vmap r <Plug>(operator-reverse-text)
" エリア拡大
vmap + <Plug>(expand_region_expand)
vmap - <Plug>(expand_region_shrink)

" インサートモード {{{2
" 移動
inoremap <C-a> <Home>
inoremap <C-e> <End>
inoremap <C-h> <Left>
inoremap <C-l> <Right>
inoremap <C-b> <S-Left>
inoremap <C-w> <S-Right>
inoremap <C-j> <Down>
inoremap <C-k> <Up>
inoremap <S-CR> <C-o>O
" 文字削除
inoremap <C-d> <Del>
" CTRL-Uのundo対策（from exaple.vim）
inoremap <C-u> <C-g>u<C-u>
" 日時の挿入
inoremap <expr> ,df strftime('%Y/%m/%d %H:%M:%S')
inoremap <expr> ,dd strftime('%Y/%m/%d')
inoremap <expr> ,dt strftime('%H:%M:%S')

" エンドワイズ {{{2
inoremap ( ()<Left>
inoremap <expr> ) match(getline("."), '()', col(".") - 2) == abs(col(".") - 2) ? '<Right>' : ')'
inoremap [ []<Left>
inoremap <expr> ] match(getline("."), '[]', col(".") - 2) == abs(col(".") - 2) ? '<Right>' : ']'
inoremap <expr> { synIDattr(synID(line("."), col(".") - 1, 1), "name") =~? 'comment' ? '{' : '{}<Left>'
inoremap <expr> } match(getline("."), '{}', col(".") - 2) == abs(col(".") - 2) ? '<Right>' : '}'
inoremap <expr> ' match(getline("."), "\'\'", col(".") - 2) == abs(col(".") - 2) ? '<Right>' :
\                 strlen(substitute(getline("."), "\[^\'\]", "", "g")) % 2 == 1 ? "\'" : "\'\'<Left>"
inoremap <expr> " match(getline("."), '""', col(".") - 2) == abs(col(".") - 2) ? '<Right>' :
\                 or(match(strpart(getline("."), 0, col(".")), '\S') == -1,
\                    strlen(substitute(getline("."), '[^"]', "", "g")) % 2 == 1) ? '"' : '""<Left>'

" コマンドモード {{{2
" 移動
cnoremap <C-a> <Home>
cnoremap <C-h> <Left>
cnoremap <C-l> <Right>
cnoremap <C-w> <S-Left>
cnoremap <C-b> <S-Right>
" 文字削除
cnoremap <C-d> <Del>
" ヒストリ
cnoremap <C-n> <Down>
cnoremap <C-p> <Up>

" コマンド実行 {{{2
" リファレンス
nnoremap K :<C-u>Ref kotobankej <C-r><C-w><CR>
vnoremap K y:<C-u>Ref kotobankej <C-r>"<CR>
au myvimrc FileType vim,help nnoremap <buffer> ,h :<C-u>H<Space><C-r><C-w><CR>
au myvimrc FileType vim,help vnoremap <buffer> ,h y:<C-u>H<Space><C-r>"<CR>
au myvimrc FileType ruby nnoremap <buffer> ,h :<C-u>Ref<Space>refe<Space><C-r><C-w><CR>
au myvimrc FileType ruby vnoremap <buffer> ,h y:<C-u>Ref<Space>refe<Space><C-r>"<CR>
au myvimrc FileType javascript nnoremap <buffer> ,h :<C-u>Ref<Space>javascript<Space><C-r><C-w><CR>
au myvimrc FileType javascript vnoremap <buffer> ,h y:<C-u>Ref<Space>javascript<Space><C-r>"<CR>
au myvimrc FileType sh nnoremap <buffer> ,h :<C-u>Ref<Space>man<Space><C-r><C-w><CR>
au myvimrc FileType sh vnoremap <buffer> ,h y:<C-u>Ref<Space>man<Space><C-r>"<CR>
" QuickRun
nmap ,r <Plug>(quickrun)
nnoremap <silent> ,R :<C-u>call<Space>quickrun#run([{'type': &filetype . '.alt'}])<CR>
vnoremap ,R y:QuickRun -src '<C-r>"'<CR>
vnoremap ,r y:QuickInspector<CR>
command! QuickInspector :call s:my_quick_inspector()
function! s:my_quick_inspector() "{{{
  if !exists('*s:my_quick_inspector_'.&ft)
    echoerr 'not implemented whis this filetype.'
    return
  endif
  hi QuickInspector term=underline cterm=underline ctermfg=67
  \ gui=underline guifg=darkcyan
  let expr = substitute(getreg('"'), '\(\s\|\n\)\+$', '', '')
  echohl QuickInspector
  echo 'expr: '.expr
  echohl None
  exe 'echo s:my_quick_inspector_'.&ft.'(expr)'
  echo ''
endfunction "}}}
function! s:my_quick_inspector_vim(expr) "{{{
  return eval(a:expr)
endfunction "}}}
function! s:my_quick_inspector_ruby(expr) "{{{
  return vimproc#system('ruby -e '.shellescape('p '.a:expr))
endfunction "}}}
" EasyMotion
nmap f <Plug>(easymotion-bd-w)
vmap ,f <Plug>(easymotion-bd-w)
omap ,f <Plug>(easymotion-bd-w)
nmap F <Plug>(easymotion-s2)
vmap ,F <Plug>(easymotion-s2)
omap ,F <Plug>(easymotion-s2)
au myvimrc FileType unite,vimfiler,gitcommit nmap <buffer> f <Plug>(easymotion-j)
au myvimrc FileType unite,vimfiler,gitcommit nmap <buffer> F <Plug>(easymotion-k)

" トグル {{{2
" コメントアウトの切り替え（caw.vim）
nmap ,/ <Plug>(caw:I:toggle)
vmap ,/ <Plug>(caw:I:toggle)
" VimFiler
nnoremap ,f :<C-u>VimFilerBufferDir
\<Space>-buffer-name=vimfiler<Space>-split<Space>-simple<Space>-winwidth=30<Space>-quit<Space>-toggle<CR>
" VimShell
nnoremap ,s :<C-u>VimShellPop<Space>-toggle<Space>-buffer-name=vimshell<CR>
nnoremap ,S :<C-u>VimShell<Space>-split-command=tabe<Space>-buffer-name=vimshell_tab<Space>$HOME<CR>
" MBEToggle
nnoremap ,b :<C-u>MBEToggle<CR>
" TagbarToggle
nnoremap ,; :<C-u>TagbarToggle<CR>
" PreviewToggle
nnoremap ,, :<C-u>PreviewToggle<CR>
vnoremap ,, y:call PreviewWord('<C-r>"')<CR>
command! PreviewToggle :call s:my_preview_toggle()
function! s:my_preview_toggle() "{{{
  silent! wincmd P
  if &previewwindow
    "au! Cursorhold
    pclose
  else
    "au! CursorHold * nested call PreviewWord()
    call PreviewWord()
  endif
endfunction
function! PreviewWord(...)
  " 設定
  let direction = "belowright"
  let height = 7
  let action = "ptjump"
  "hi PreviewWord term=bold ctermfg=black ctermbg=lightgreen guifg=black guibg=lightgreen
  hi link PreviewWord Search

  if &previewwindow			" プレビューウィンドウ内では実行しない
    return
  endif
  let w = a:0 == 0 ? expand("<cword>") : a:1		" カーソル下の単語を得る
  "if w =~ '\a'			" その単語が文字を含んでいるなら
  if w !~ '\s'			" その単語が文字を含んでいるなら

    " 別のタグを表示させる前にすでに存在するハイライトを消去する
    silent! wincmd P			" プレビューウィンドウにジャンプ
    if &previewwindow			" すでにそこにいるなら
      match none			" 存在するハイライトを消去する
      wincmd p			" もとのウィンドウに戻る
    endif

    " カーソル下の単語にマッチするタグを表示してみる
    try
       exe direction action w
    catch
      echohl ErrorMsg
      echo substitute(v:exception, '^Vim\%((\a\+)\)\=:', '', "")
      echohl None
      return
    endtry

    silent! wincmd P			" プレビューウィンドウにジャンプ
    if &previewwindow		" すでにそこにいるなら
      if has("folding")
        silent! .foldopen		" 閉じた折り畳みを開く
      endif
      exe "resize" height
      exe "normal! zz"
      call search("$", "b")		" 前の行の最後へ
      let w = substitute(w, '\\', '\\\\', "")
      call search('\<\V' . w . '\>')	" カーソルをマッチしたところへ
      " ここで単語にハイライトをつける
      exe 'match PreviewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
      wincmd p			" もとのウィンドウへ戻る
    endif
  endif
endfunction "}}}
" GundoToggle
nnoremap ,u :<C-u>GundoToggle<CR>
" QuickhlToggle
map ,<Space> <Plug>(quickhl-manual-this)
map ,<S-Space> <Plug>(quickhl-manual-reset)
" ShowMarks
nmap ,m :<C-u>ShowMarksToggle<CR>

" 無効化、退避 {{{2
" 保存して閉じる
nnoremap ZZ <Nop>
" 保存せずに閉じる
nnoremap ZQ <Nop>
" 退避
nnoremap <F2><C-y> <C-y>
nnoremap <F2><C-e> <C-e>
nnoremap <F2><C-g> <C-g>
nnoremap <F2>[[ [[
nnoremap <F2>]] ]]
inoremap <F2><C-a> <C-a>
inoremap <F2><C-e> <C-e>
inoremap <F2><C-w> <C-w>
inoremap <F2><C-b> <C-b>
inoremap <F2><C-u> <C-u>
cnoremap <F2><C-a> <C-a>
cnoremap <F2><C-w> <C-w>
cnoremap <F2><C-b> <C-b>
cnoremap <F2><C-n> <C-n>
cnoremap <F2><C-p> <C-p>

"}}}1-------------------------------------------------------------------------

"-----------------------------------------------------------------------------
" Plugin設定
"-----------------------------------------------------------------------------
" Unite {{{1
" 説明 {{{2
" COMMAND:
"  :Unite ${source} [${option}]
"  :Unite output:{コマンド名}
" KEYMAP:
"  <Tab> : Actionを開く
"  <Space> : 候補を選択する
"  * : 候補を全選択する
"  a : 候補でActionを開く
"  ? : Uniteのキーマップを表示

" Uniteコマンド定義 {{{2
" 汎用
command! -nargs=+ -complete=customlist,unite#complete#source U Unite <args>
\ -no-empty -silent -buffer-name=<args>

" 現在のバッファ内をグレップ
command! Ug Unite grep:%
\ -no-empty -silent -buffer-name=grep
" カーソル下の単語で現在のバッファをグレップ
command! Ugw exe 'Unite grep:%::' .
\ escape(expand("<cword>"), '- \\') .
\ ' -no-empty -silent -buffer-name=grep-word'
" ディレクトリをグレップ
command! Ugd exe 'Unite grep' .
\ ' -silent -buffer-name=grep-dir' .
\ ' -tab -no-split -no-quit'
\ | setlocal splitbelow | exe 'normal <Plug>(unite_toggle_auto_preview)'
" すべてのバッファをグレップ
command! Ugb exe 'Unite grep:$buffers' .
\ ' -silent -buffer-name=grep-all-bufs' .
\ ' -tab -no-split -no-quit
\ | setlocal splitbelow | exe 'normal <Plug>(unite_toggle_auto_preview)'

" ブックマーク（追加はUniteBookmarkAdd）
command! Ub Unite bookmark
\ -no-empty -silent -buffer-name=bookmark
" ブックマーク追加
command! Uba UniteBookmarkAdd
" ブックマーク手動編集
command! Ube edit $HOME/.unite/bookmark/default
" TODO: 'TODO:'をつけた行をファイル保存時に自動でブックマークするau
command! Ubt Unite bookmark:todos
\ -no-empty -silent -buffer-name=bookmarktodos
" メニュー
command! Um Unite menu:shortcuts
\ -no-empty -silent -buffer-name=menushortcuts

" リファレンス参照
" ref
command! UR Unite ref
\ -no-empty -silent -buffer-name=ref
" refe
command! URr Unite ref/refe
\ -no-empty -silent -buffer-name=ref/refe
" カーソル下の単語でrefe
command! URrw exe 'Unite ref/refe ' .
\ '-no-empty -silent -buffer-name=ref/refe -input=' .
\ escape(expand("<cword>"), '- \\')
" ri
command! URri Unite ref/ri
\ -no-empty -silent -buffer-name=ref/ri

" ファイル
" file_rec
command! Uf Unite file_rec
\ -no-empty -silent -buffer-name=files

" 直前のUniteコマンドの結果に戻る
command! Ur UniteResume
\ -no-empty -silent
" ヤンクヒストリ
command! Uy Unite history/yank
\ -no-empty -silent -buffer-name=history/yank
" スニペット候補の表示
command! Usnip Unite neosnippet
\ -no-empty -silent -buffer-name=neosnippet
" マッピング表示
command! Umap :Unite output:map|map!|lmap
\ -no-empty -silent -buffer-name=output:map

" 基本設定（以降はon_source） {{{2
let s:bundle = neobundle#get('unite.vim')
let s:bundle.hooks = get(s:bundle, "hooks", {})
function! s:bundle.hooks.on_source(bundle)
" 入力モードで開始しない
let g:unite_enable_start_insert = 0
call unite#custom#profile('action', 'context', {'start_insert': 0})
" ヤンク履歴を使用可能にする
let g:unite_source_history_yank_enable = 1
" 最近使ったファイルの履歴数
let g:unite_source_file_mru_file = 200
" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
" ステータスラインを上書きしない（lightline向け）
let g:unite_force_overwrite_statusline = 0
" プロンプト文字
let g:unite_prompt = 'Unite>>> '
" カーソルラインのハイライト
let g:unite_cursor_line_highlight = 'MatchParen'
" unite grep に ag(The Silver Searcher) を使う
if executable('ag')
 let g:unite_source_grep_command = 'ag'
 let g:unite_source_grep_default_opts =
 \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
 \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
 let g:unite_source_grep_recursive_opt = ''
endif

" キーマップ定義 {{{2
au myvimrc FileType unite call MyUniteKeymaps()
function! MyUniteKeymaps() "{{{
  " <C-j>/<C-k>で移動
  nmap <silent> <buffer> <C-j> <Plug>(unite_loop_cursor_down)
  imap <silent> <buffer> <C-j> <Plug>(unite_select_next_line)
  nmap <silent> <buffer> <C-k> <Plug>(unite_loop_cursor_up)
  imap <silent> <buffer> <C-k> <Plug>(unite_select_previous_line)
  " ESCキーを2回押すと終了する
  nmap <silent> <buffer> <Esc><Esc> <Plug>(unite_all_exit)
  " 入力文字が無い時に<BS>で前の画面に戻る
  imap <expr> <silent> <buffer> <BS> unite#helper#get_input() == '' ? "\<Plug>(unite_exit)" : "\<BS>"
  nmap <silent> <buffer> <BS> <Plug>(unite_exit)
  " キャッシュ更新
  nmap <silent> <buffer> <F5> <Plug>(unite_redraw)
  " pでオートプレビューのトグル
  nmap <silent> <buffer> p <Plug>(unite_toggle_auto_preview))
endfunction "}}}

" メニュー設定 {{{2
let g:unite_source_menu_menus = {
\ 'shortcuts': {
\   'description': 'command shortcuts.',
\   'command_candidates': [
\     ['help-functions', 'H function-list'],
\     ['help-neobundle-autoload', 'H neobundle-options-autoload'],
\     ['help-registers', 'H registers'],
\     ['help-map-overview', 'H map-overview'],
\     ['help-vim-script', 'H usr_41.txt'],
\     ['help-quickref-alpha', 'H index.txt'],
\     ['help-quickref', 'H quickref.txt'],
\     ['help-vim-goal', 'H design-goal'],
\     ['unite-colorscheme', 'Unite colorscheme -auto-preview'],
\     ['unite-output:message', 'Unite output:message'],
\     ['unite-mapping(all)', 'Unite output:map|map!|lmap'],
\   ],
\ },
\}

" デフォルトアクションの変更 {{{2
" openable
call unite#custom_default_action('file', 'tabopen')
" directory
call unite#custom_default_action('directory', 'vimfiler')
" ref
call unite#custom_default_action(
\ 'source/ref/refe/*,source/ref/ri/*,source/ref/javascript/*,source/ref/jquery/*,source/ref/man/*',
\ 'vsplit')
" help
call unite#custom_default_action('source/help/*', 'vsplit')

" アクションの追加 {{{2
" source:mappingにaction:verboseを追加する
let s:action = {
\ 'description': 'verbose',
\ 'is_selectable': 1,
\}
function! s:action.func(candidates)
  for candidate in a:candidates
    execute "verbose map" substitute(candidate.action__mapping, '\\\(<.*>\)', '\1', "g")
  endfor
endfunction
" kind ではなくて source の mapping に対して action を設定する
call unite#custom#action('source/mapping/*', 'verbose', s:action)
" preview（pキー）で action を実行したい場合は
" call unite#custom#action('source/mapping/*', 'preview', s:action)
unlet s:action

" Uniteソース {{{2
" ref {{{3
let s:unite_source = {
\   'name': 'ref',
\ }
function! s:unite_source.gather_candidates(args, context)
  return map(ref#available_source_names(), '{
  \   "word": v:val,
  \   "source": "ref",
  \   "kind": "source",
  \   "action__source_name": "ref/" . v:val,
  \ }')
endfunction
call unite#define_source(s:unite_source)
unlet s:unite_source
" サンプル {{{3
let s:unite_source = {
\   'name': 'lines',
\ }
function! s:unite_source.gather_candidates(args, context)
  let path = expand('%:p')
  let lines = getbufline('%', 1, '$')
  let format = '%' . strlen(len(lines)) . 'd: %s'
  return map(lines, '{
  \   "word": printf(format, v:key + 1, v:val),
  \   "source": "lines",
  \   "kind": "jump_list",
  \   "action__path": path,
  \   "action__line": v:key + 1,
  \ }')
endfunction
call unite#define_source(s:unite_source)
unlet s:unite_source

" （on_source終わり） {{{2
endfunction
unlet s:bundle

" VimFiler {{{1
"
" KEYMAP:
"  h : up dir, l : down dir, t : tree view (1 dir), T : tree view all
"  e : edit, <Space> : mark, c : copy, m : move, d : delete, yy : yank path
"  N : new file, K : new dir, * : mark all, U : mark off all, ? : keymap
"  a : action, H : VimShell, ge : system filer, x : system app
"
" vimデフォルトのエクスプローラをvimfilerで置き換える
let g:vimfiler_as_default_explorer = 1
" セーフモードを無効にした状態で起動する
let g:vimfiler_safe_mode_by_default = 0
" ディレクトリ移動
let g:vimfiler_enable_auto_cd = 1
" タブで開く
let g:vimfiler_edit_action = 'tabopen'
" デフォルトでIDE風のFilerを開く
" au myvimrc VimEnter * VimFiler -split -simple -winwidth=30 -no-quit
" ステータスラインを上書きしない（lightline向け）
"let g:vimfiler_force_overwrite_statusline = 0
"let g:netrw_liststyle=3
" キーマップ定義
au myvimrc FileType vimfiler call MyVimfilerKeymaps()
function! MyVimfilerKeymaps() "{{{
  " Enterでツリー開閉、ファイル編集を可能に
  nmap <buffer> <expr> <CR> vimfiler#smart_cursor_map("\<Plug>(vimfiler_expand_tree)", "\<Plug>(vimfiler_edit_file)")
  " ESCキーを2回押すと終了する
  nnoremap <silent> <buffer> <Esc><Esc> :q<CR>
  " キーマップヘルプを表示
  nnoremap <buffer> ,, :MyVimFilerHelp<CR>
  " システムハンドラで開く
  nmap gx <Plug>(vimfiler_execute_system_associated)
endfunction "}}}
command! MyVimFilerHelp :call MyVimfilerHelp()
function! MyVimfilerHelp() "{{{
  silent! wincmd P
  if &previewwindow
    pclose
    return
  endif

  hi link MyVimFilerHelp Comment
  hi link MyVimFilerHelpTitle PreProc
  hi link MyVimFilerHelpKey Identifier
  belowright pedit $MYVIMDIR/doc/vimfiler_help.txt
  silent! wincmd P
  if &previewwindow
    match none
    setlocal nonumber
    resize 20
    exe "normal! gg"
    nnoremap <buffer> ,, :MyVimFilerHelp<CR>
    call matchadd('MyVimFilerHelp', '.', 0)
    call matchadd('MyVimFilerHelpTitle', '--.*')
    call matchadd('MyVimFilerHelpKey', '\(.\+\):')
    wincmd p
  endif
endfunction "}}}

" VimShell {{{1
" VimShellPopの開き方
let g:vimshell_popup_command = 'topleft 10split'
" 動的プロンプト
let g:vimshell_prompt_expr = 'getcwd()." > "'
let g:vimshell_prompt_pattern = '^\f\+ > '
" irbを非同期で起動
command! Irb VimShellInteractive irb
" 非同期で開いたインタプリタに現在の行を評価させる
command! VSSend VimShellSendString
command! VSAll %VimShellSendString
" vimコマンドで開いた時の開き方
let g:vimshell_split_command = 'tabe'

" NeoComplete {{{1
" 基本設定（以降はon_source）{{{2
let s:bundle = neobundle#get('neocomplete')
let s:bundle.hooks = get(s:bundle, "hooks", {})
function! s:bundle.hooks.on_source(bundle)
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use ignorecase.
let g:neocomplete#enable_ignore_case = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
" Use fuzzy completion.
let g:neocomplete#enable_fuzzy_completion = 1

" Define dictionary. {{{2
let g:neocomplete#sources#dictionary#dictionaries = {
\ 'default' : '',
\ 'vimshell' : $HOME.'/.vimshell_hist',
\ 'scheme' : $HOME.'/.gosh_completions',
\ 'html': $MYVIMDIR.'/dict/bootstrap.dict',
\}

" Define keyword. {{{2
if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings. {{{2
inoremap <expr> <C-d> pumvisible() ? neocomplete#undo_completion() : "\<Del>"
" inoremap <expr> <C-l> neocomplete#complete_common_string()
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplete#smart_close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction
" <Tab>: completion.
inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr> <C-h> neocomplete#smart_close_popup() . "\<Left>"
inoremap <expr> <BS> neocomplete#smart_close_popup() . "\<C-h>"
" inoremap <expr> <C-y> neocomplete#close_popup()
" inoremap <expr> <C-e> neocomplete#cancel_popup()
" Close popup by <Space>.
"inoremap <expr> <Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

" For cursor moving in insert mode(Not recommended)
"inoremap <expr> <Left>  neocomplete#close_popup() . "\<Left>"
"inoremap <expr> <Right> neocomplete#close_popup() . "\<Right>"
"inoremap <expr> <Up>    neocomplete#close_popup() . "\<Up>"
"inoremap <expr> <Down>  neocomplete#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplete#enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplete#enable_insert_char_pre = 1

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr> <TAB> pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion. {{{2
au myvimrc FileType css setlocal omnifunc=csscomplete#CompleteCSS
au myvimrc FileType html,mkd setlocal omnifunc=htmlcomplete#CompleteTags
au myvimrc FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
au myvimrc FileType python setlocal omnifunc=pythoncomplete#Complete
au myvimrc FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion. {{{2
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
" let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

" （on_source終わり）{{{2
endfunction
unlet s:bundle

" NeoComplCache {{{1
" 基本設定（以降はon_source）
let s:bundle = neobundle#get('neocomplcache')
let s:bundle.hooks = get(s:bundle, "hooks", {})
function! s:bundle.hooks.on_source(bundle)
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
"
" Enable heavy features.
" Use camel case completion.
"let g:neocomplcache_enable_camel_case_completion = 1
" Use underbar completion.
"let g:neocomplcache_enable_underbar_completion = 1
"
" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
\  'default': '',
\  'vimshell': $HOME.'/.vimshell_hist',
\  'scheme': $HOME.'/.gosh_completions',
\  'html': $MYVIMDIR.'/dict/bootstrap.dict',
\}
"
" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
  let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
"
" Plugin key-mappings.
inoremap <expr> <C-d> pumvisible() ? neocomplcache#undo_completion() : "\<Del>"
" inoremap <expr><C-l>     neocomplcache#complete_common_string()
"
" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplcache#smart_close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
endfunction
" <Tab>: completion.
inoremap <expr> <Tab>  pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab>  pumvisible() ? "\<C-p>" : "\<S-Tab>"
" <C-h>, <BS>: close popup and delete backword char.
" inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
"inoremap <expr><C-e>  neocomplcache#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"
"
" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplcache_enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplcache_enable_insert_char_pre = 1
"
" AutoComplPop like behavior.
"let g:neocomplcache_enable_auto_select = 1
"
" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplcache_enable_auto_select = 1
"let g:neocomplcache_disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"
"
" Enable omni completion.
au myvimrc FileType css setlocal omnifunc=csscomplete#CompleteCSS
au myvimrc FileType html,mkd setlocal omnifunc=htmlcomplete#CompleteTags
au myvimrc FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
au myvimrc FileType python setlocal omnifunc=pythoncomplete#Complete
au myvimrc FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"
" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
if !exists('g:neocomplcache_force_omni_patterns')
  let g:neocomplcache_force_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.php =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.c =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
let g:neocomplcache_omni_patterns.cpp =
\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
"
" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplcache_omni_patterns.perl =
\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
" （on_source終わり）
endfunction
unlet s:bundle

" NeoSnippet {{{1
" KEYMAP:
imap <expr> <C-e> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<End>"
smap <C-e> <Plug>(neosnippet_expand_or_jump)
xmap <C-e> <Plug>(neosnippet_expand_target)
" imap <expr> <Tab> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \ : pumvisible() ? "\<C-n>" : "\<Tab>"
smap <expr> <Tab> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\ : "\<Tab>"
" スニペットの保存場所を変更
let g:neosnippet#snippets_directory = $MYVIMDIR . '/neosnippets'
" スニペットファイルの保存時に再読み込み
au myvimrc BufWritePost *.snip NeoSnippetSource %:p

" CtrlP {{{1
"
" KEYMAP:
"  C-f/C-b: モード切替（file<=>mru<=>buffer）
"  C-r: 正規表現モードのオン／オフ
" CtrlPTag
nnoremap <C-@> :<C-u>CtrlPTag<CR>
" CtrlPMRUFiles
nnoremap <C-o> :<C-u>CtrlPMRUFiles<CR>
" タブで開く
" t: Tab, e: Enter, h: Horizontal(split), v: Vertical(vsplit)
let g:ctrlp_prompt_mappings = {
\ 'AcceptSelection("t")': ['<CR>'],
\ 'AcceptSelection("e")': ['<C-CR>'],
\ 'AcceptSelection("h")': ['<C-s>'],
\ 'AcceptSelection("v")': ['<C-v>'],
\ 'ToggleByFname()':      ['<C-t>'],
\ 'PrtDelete()':          ['<del>', '<C-d>'],
\ 'PrtInsert()':          ['<C-@>', '<C-\>'],
\ 'MarkToOpen()':         ['<C-Space>', '<C-z>'],
\}
" CtrlP動作モード（'w'：ワークディレクトリ）
let g:ctrlp_working_path_mode = 'w'
" 新規ファイルをタブで開く
let g:ctrlp_open_new_file = 't'
" 開いたタブを一番最後にする
let g:ctrlp_tabpage_position = 'l'
" ウィンドウの設定
let g:ctrlp_match_window = 'max:20'
" キャッシュを使う
let g:ctrlp_use_caching = 1
let g:ctrlp_cache_dir = $HOME . '/.cache/ctrlp'
" キャッシュを終了後も残す（<F5>でキャッシュ更新）
let g:ctrlp_clear_cache_on_exit = 0
" MRUファイルの数
let g:ctrlp_mruf_max = 10000
" MRUファイルの大文字小文字無視
let g:ctrlp_mruf_case_sensitive = 0
" 拡張機能を有効にする
let g:ctrlp_extensions = ['tag', 'changes', 'quickfix', 'bookmarkdir']
" コマンドエイリアス
command! -nargs=? -complete=dir Bookmark CtrlPBookmarkDirAdd <args>
" migemoを使って日本語正規表現検索
if executable('cmigemo')
  let g:ctrlp_use_migemo = 1
endif

" fugitive {{{1
" 説明 {{{
" DESC:
"  VimにGitコマンドを追加。
" COMMAND:
"  :Gstatus      : git status
"    Gstatusのバッファ上で
"      - : add/reset
"      D : diff
"      C : commit
"      cvc : commit -v
"  :Gwrite/:Gadd : git add
"  :Gdiff        : git diff
"  :Gcommit -v   : git commit -v
" }}}
command! Gs Gstatus
command! Ga Gwrite
command! Gw Gwrite
command! Gd Gdiff
command! Gc Gcommit -v
command! Gca Gcommit -va
command! Gl Glog
command! Gb Gblame
command! Gpush call s:my_git_vimproc('push')
command! Gpull call s:my_git_vimproc('pull')
" Gpush/Gpullのためのvimproc
function! s:my_git_vimproc(gitcommand) "{{{
  let command = 'git ' . a:gitcommand
  let sub = vimproc#popen2(command)
  let res = ''
  while !sub.stdout.eof
    let res .= sub.stdout.read()
    let res .= sub.stderr.read()
  endwhile
  let [cond, status] = sub.waitpid()
  if 0 != status
    echohl ErrorMsg
  endif
  for line in split(res, '\r\n\|\r\|\n')
    echomsg "[".command."] ".line
  endfor
  echohl None
endfunction "}}}

" Ref {{{1
"
" COMMAND:
"  :Ref refe Array
let g:ref_use_vimproc = 1 " 0:disable / 1:enable
let g:ref_open = 'vsplit'
let g:ref_detect_filetype = {
\ 'ruby': 'refe',
\ 'ruby.rspec': 'refe',
\}
au myvimrc FileType ref call MyRefMappings()
function! MyRefMappings() "{{{
  nnoremap <buffer> ,] <Plug>(ref-keyword)
  nnoremap <buffer> ,[ <Plug>(ref-back)
  nnoremap <buffer> <C-h> <Plug>(ref-back)
  nnoremap <buffer> <C-l> <Plug>(ref-forward)
endfunction "}}}
" ref/refe
let g:ref_refe_version = 2
" ref/webdict
let g:ref_source_webdict_sites = {
\ 'default': 'weblio',
\ 'weblio': 'http://ejje.weblio.jp/content/%s',
\}
" ローカルファイルを参照するため、.local.vimrcに以下を宣言
" ref/javascript
" let g:ref_javascript_doc_path = 'jsref/htdocs'
" ref/jquery
" let g:ref_jquery_doc_path = 'jqapi'

" QuickRun {{{1
" 説明 {{{2
" デフォルトの設定を見る場合、
" let g:quickrun#default_configを使う。
" <C-c> で実行を強制終了させる
" COMMAND:
"  :QuickRun -args foo
" KEYMAP:
"  ,r : バッファの内容を実行

" 基本設定 {{{2
" quickrun.vim が実行していない場合には <C-c> を呼び出す
nnoremap <expr> <silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
" カラー出力用outputter追加
let s:ansi_buffer = quickrun#outputter#buffer#new()
function! s:ansi_buffer.init(session)
  call call(quickrun#outputter#buffer#new().init, [a:session], self)
endfunction
function! s:ansi_buffer.finish(session)
  AnsiEsc
  call call(quickrun#outputter#buffer#new().finish, [a:session], self)
endfunction
call quickrun#register_outputter("ansi_buffer", s:ansi_buffer)
unlet s:ansi_buffer

" 共通設定 {{{2
"  実行にvimprocを使う
"  エラー時はquickfixに表示する
let g:quickrun_config = {}
let g:quickrun_config = {
\  "_": {
\    'runner': 'vimproc',
\    'runner/vimproc/updatetime': 100,
\    'outputter': 'error',
\    'outputter/error': 'quickfix',
\    'outputter/error/success': 'buffer',
\    'outputter/buffer/split': ':belowright 7',
\    'outputter/buffer/close_on_empty': 1,
\    'hook/animation/enable': 1,
\    'hook/animation/wait': 10,
\  },
\}
" アニメーション
call quickrun#module#register(shabadou#make_quickrun_hook_anim(
\ "animation",
\ ['QuickRun: ／', 'QuickRun: ―', 'QuickRun: ＼', 'QuickRun: ｜',],
\ 12,
\), 1)

" ruby.rspec {{{2
au myvimrc BufWinEnter,BufNewFile *_spec.rb set filetype=ruby.rspec syntax=ruby
let g:quickrun_config['ruby.rspec'] = {
\ 'command': 'rspec',
\ 'cmdopt': '--color',
\ 'outputter': 'ansi_buffer',
\}

" vim.vspec {{{2
au myvimrc BufRead,BufNew,BufNewFile *_spec.vim setlocal ft=vim.vspec
if (has('win32') || has('win64')) && exists('$CYGWIN_HOME')
  let g:quickrun_config['vim.vspec'] = {
  \ 'exec': '%c --login -c ' .
  \         '"cd %%{MyGetCygwinDir(%s:p:h)}/..; ' .
  \         '%%{MyGetCygwinDir(expand($MYVIMDIR))}/bundle/vim-vspec/bin/vspec ' .
  \         '%%{MyGetCygwinDir(expand($MYVIMDIR))}/bundle/vim-vspec ' .
  \         '%%{MyGetCygwinDir(expand($MYVIMDIR))}/bundle/vim-vspec-matchers ' .
  \         '. ' .
  \         '%%{MyGetCygwinDir(%s:p)}"',
  \ 'command': $CYGWIN_HOME . '\bin\bash.exe',
  \}
  let g:quickrun_config['vim.vspec.alt'] = {
  \ 'exec': '%c --login -c ' .
  \         '"cd %%{MyGetCygwinDir(%s:p:h)}/..; rake test"',
  \ 'command': $CYGWIN_HOME . '\bin\bash.exe',
  \}
elseif executable('bash')
  let g:quickrun_config['vim.vspec'] = {
  \ 'exec': '%c %o %a %s',
  \ 'command': $MYVIMDIR . '/bundle/vim-vspec/bin/vspec',
  \ 'args': $MYVIMDIR . '/bundle/vim-vspec ..',
  \}
  let g:quickrun_config['vim.vspec.alt'] = {
  \ 'exec': 'rake test',
  \}
endif

" html, mkd {{{2
" （tyru/open-browser.vim プラグインが必要）
let g:quickrun_config['html'] = {'command': 'open', 'exec': '%c %s', 'outputter': 'browser' }
let g:quickrun_config['xhtml'] = {'command': 'open', 'exec': '%c %s', 'outputter': 'browser' }
let g:quickrun_config['mkd'] = {'command': 'kramdown', 'outputter': 'browser'}

" javascript {{{2
let g:quickrun_config['javascript'] = {'command': 'node'}
let g:quickrun_config['jshint'] = {
\ 'exec': '%c %s:p',
\ 'command': 'jshint',
\ 'outputter': 'quickfix',
\ 'quickfix/errorformat': '%f: line %l\\,\ col %c\\, %m',
\ 'vimproc/sleep': 0,
\ 'hook/unite_quickfix/enable': 0,
\ 'hook/close_unite_quickfix/enable': 0,
\ 'hook/close_buffer/enable_exit': 1,
\ 'hook/u_nya_/enable': 0,
\}
au myvimrc BufWritePost *.js QuickRun jshint

" database {{{2
let g:quickrun_config['sql'] = {'type': executable('sqlite3') ? 'sql.sqlite3' : ''}
let g:quickrun_config['sql.alt'] = {'type': executable('sqlplus') ? 'sql.oracle' : ''}
let g:quickrun_config['sql.sqlite3'] = {
\ 'exec': '%c %o %a < %S',
\ 'command': 'sqlite3',
\ 'cmdopt': '-header -column',
\}
let g:quickrun_config['sql.oracle'] = {
\ 'exec': '%c %o \@%s',
\ 'command': 'sqlplus',
\ 'cmdopt': '-S /nolog',
\ 'hook/output_encode/encoding': 'sjis',
\}

" MiniBufExplorer {{{1
"
" 自動起動
let g:miniBufExplAutoStart = 0
" バッファが２つ以上で開く
" let g:miniBufExplBuffersNeeded = 2
" Diffモードでは隠す
let g:miniBufExplHideWhenDiff = 1
" バッファリストのサイクル化
let g:miniBufExplCycleArround = 1
" 表示行数を制限
let g:miniBufExplMaxSize = 1
" カラーリング
let g:did_minibufexplorer_syntax_inits = 1
" for buffers that have NOT CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveNormal ctermfg=black ctermbg=lightgray guifg=black guibg=lightgray
" for buffers that have CHANGED and are VISIBLE and is the active buffer
hi MBEVisibleActiveChanged ctermfg=black ctermbg=lightred guifg=black guibg=lightred
" buffers that have NOT CHANGED and are VISIBLE
hi MBEVisibleNormal cterm=bold ctermfg=white gui=bold guifg=white guibg=black
" buffers that have CHANGED and are VISIBLE
hi MBEVisibleChanged cterm=bold ctermfg=lightred gui=bold guifg=lightred guibg=black
" for buffers that have NOT CHANGED and are NOT VISIBLE.
hi MBENormal ctermfg=darkgray guifg=darkgray guibg=black
" for buffers that HAVE CHANGED and are NOT VISIBLE
hi MBEChanged ctermfg=red guifg=red guibg=black

" lightline {{{1
let g:lightline = {}
" let g:lightline.colorscheme = 'wombat'
let g:lightline.active = {
\ 'left': [['mode', 'paste'], ['filename', 'fugitive', 'anzu']],
\ 'right': [['lineinfo', 'syntastic'], ['percent'], ['pwd', 'fileformat', 'fileencoding', 'filetype']]
\}
let g:lightline.inactive = {
\ 'left': [],
\ 'right': [['filename']]
\}
let g:lightline.component_function = {
\ 'modified': 'MyModified',
\ 'readonly': 'MyReadonly',
\ 'pwd': 'MyPwd',
\ 'filename': 'MyFilename',
\ 'fugitive': 'MyFugitive',
\ 'anzu': 'anzu#search_status',
\ 'syntastic': 'SyntasticStatuslineFlag',
\ 'fileformat': 'MyFileformat',
\ 'filetype': 'MyFiletype',
\ 'fileencoding': 'MyFileencoding',
\ 'mode': 'MyMode'
\}
function! MyModified() " {{{2
  "return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : ''
endfunction
function! MyReadonly() " {{{2
  "return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '[RO]' : ''
endfunction
function! MyFilename() " {{{2
  return (&ft == 'vimfiler' ? vimfiler#get_status_string() :
\         &ft == 'unite' ? unite#get_status_string() :
\         &ft == 'vimshell' ? vimshell#get_status_string() :
\         '' != expand('%:t') ? expand('%:t') : '[No Name]') .
\        ('' != MyModified() ? ' ' . MyModified() : '') .
\        ('' != MyReadonly() ? ' ' . MyReadonly() : '')
endfunction
function! MyPwd() " {{{2
  let path = ''
  if winwidth(0) > 100
    let path = getcwd()
    while len(path) >= 50 && stridx(path, '/') >= 0
      let path = '...' . strpart(path, stridx(path, '/') + 1)
    endwhile
  endif
  return path
endfunction
function! MyFugitive() " {{{2
  try
    if winwidth(0) > 80 && &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction
function! MyFileformat() " {{{2
  return winwidth(0) > 80 ? &fileformat : ''
endfunction
function! MyFiletype() " {{{2
  return winwidth(0) > 80 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction
function! MyFileencoding() " {{{2
  return winwidth(0) > 80 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction
function! MyMode() " {{{2
  return &ft == 'help' ? 'Help' :
\        &ft == 'minibufexpl' ? 'MBE' :
\        &ft == 'quickrun' ? 'QuickRun' :
\        &ft == 'qf' ? 'QuickFix' :
\        &ft == 'unite' ? 'Unite' :
\        &ft == 'vimshell' ? 'VimShell' :
\        winwidth(0) > 60 ? lightline#mode() : ''
endfunction

" Tagbar {{{1
let g:tagbar_auto_focus = 1
if executable('jsctags')
  let g:tagbar_type_javascript = {'ctagsbin': '/opt/local/bin/jsctags'}
endif

" surround {{{1
" KEYMAP:
"  s : side
"  cs'" : 'を"に変換する
"  ds' : 'で囲まれた範囲を消す
" 置換時の空白を入れない
let g:surround_34 = "\"\r\""
let g:surround_39 = "\'\r\'"
let g:surround_40 = "(\r)"
let g:surround_41 = "( \r )"
let g:surround_91 = "[\r]"
let g:surround_93 = "[ \r ]"
let g:surround_123 = "{\r}"
let g:surround_125 = "{ \r }"

" migemo-search {{{1
if executable('cmigemo')
  cnoremap <expr> <silent> <CR> getcmdtype() =~ '[/?]' ? migemosearch#replace_search_word() . "\<CR>zvzz" : "\<CR>"
endif

" Emmet {{{1
"
" KEYMAP:
"  <C-e> : 展開
"  <C-_> : コメントアウト／イン
"          （_と/が同じキーマップになってるのでCtrl+/でできる）
"let g:user_emmet_leader_key = '<C-e>'
let g:user_emmet_expandabbr_key = ',e'
let g:user_emmet_togglecomment_key = '<C-_>'
" タグのコンプリート
let g:use_emmet_complete_tag = 1

" カスタマイズ設定
let g:user_emmet_settings = {
\  'lang': 'ja',
\  'indentation': "  ",
\  'html': {
\    'filters': 'html',
\    'snippets': {
\      'meta:viewport': "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">",
\      'css:bs': "<link href=\"css/bootstrap.min.css\" rel=\"stylesheet\">",
\      'cd': "<![CDATA[|]]>",
\      'js:jq': "<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n<script>\n\\$(function() {\n\t|\n})()\n</script>",
\      'js:bs': "<script src=\"https://code.jquery.com/jquery.js\"></script>\n<script src=\"js/bootstrap.min.js\"></script>",
\    },
\  },
\  'javascript': {
\    'snippets': {
\      'jq': "\\$(function() {\n\t\\${cursor}\\${child}\n});",
\      'jq:json': "\\$.getJSON(\"${cursor}\", function(data) {\n\t\\${child}\n});",
\      'jq:each': "\\$.each(data, function(index, item) {\n\t\\${child}\n});",
\      'fn': "(function() {\n\t\\${cursor}\n})();",
\      'tm': "setTimeout(function() {\n\t\\${cursor}\n}, 100);",
\    },
\    'use_pipe_for_cursor': 0,
\  },
\  'css': {
\    'filters': 'fc',
\    'snippets': {
\      'box-shadow': "-webkit-box-shadow: 0 0 0 # 000;\n-moz-box-shadow: 0 0 0 0 # 000;\nbox-shadow: 0 0 0 # 000;",
\    },
\  },
\  'vim': {
\    'snippets': {
\      'nn': 'nnoremap <silent> ${cursor} :<C-u>',
\      'nnu': 'nnoremap <silent> [unite]${cursor}<CR> :<C-u>Unite<Space>\n\\<Space>-no-empty<Space>-silent<Space>-buffer-name=<CR>',
\    },
\  },
\  'java': {
\    'snippets': {
\     'main': "public static void main(String[] args) {\n\t|\n}",
\     'println': "System.out.println(\"|\");",
\     'class': "public class | {\n}\n",
\    },
\  },
\  'php': {
\    'extends': 'html',
\    'filters': 'html,c',
\  },
\  'less': {
\    'filters': 'fc',
\    'extends': 'css',
\  },
\  'lorem_lipsum_ja': {
\    '^\%(lorem\|lipsum\)\(\d*\)$': function('emmet#lorem#ja#expand'),
\  },
\}

" rcodetools {{{1
"
" DESC: xmpfilterの呼び出し設定
" <F1>でバッファ全体にxmpfilterを実行
"{{{ xmpfilter mapping (disable)
"nmap <silent> <F1> mzggVG!xmpfilter -a<cr>'z
"imap <silent> <F1> <Esc><F1>
"" <F2>で現在行/選択行にxmpfilterを実行
"map <silent> <F2> !xmpfilter -a<cr>
"nmap <silent> <F2> V<F2>
"imap <silent> <F2> <Esc><F2>a
"" <F3>で現在行/選択行に「# =>」マークを追加
"vmap <silent> <F3> !xmpfilter -m<cr>
"nmap <silent> <F3> V<F3>
"imap <silent> <F3> <Esc><F3>a
"" <F4>で現在行/選択行の「# =>」マークを削除
"vmap <silent> <F4> ms:call RemoveRubyEval()<CR>
"nmap <silent> <F4> V<F4>
"imap <silent> <F4> <Esc><F4>a
"" RemoveRubyEval() の定義
"function! RemoveRubyEval() range
  "let begv = a:firstline
  "let endv = a:lastline
  "normal Hmt
  "set lz
  "execute ":" . begv . "," . endv . 's/\s*# \(=>\|!!\).*$//e'
  "normal 'tzt`s
  "set nolz
  "redraw
"endfunction
"" JRuby用<F11>でバッファ全体にjxmpfilterを実行
"nmap <silent> <F11> mzggVG!jxmpfilter -a<cr>'z
"imap <silent> <F11> <Esc><F11>
"}}}

" IndentGuides {{{1
" vim立ち上げたときに、自動的にIndentGuidesをオンにする
let g:indent_guides_enable_on_vim_startup = 1
" ガイドをスタートするインデントの量
let g:indent_guides_start_level = 2
" 自動カラーを無効にする
let g:indent_guides_auto_colors = 0
" 奇数インデントのカラー
au myvimrc VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=#262626 ctermbg=gray
" 偶数インデントのカラー
au myvimrc VimEnter,Colorscheme * :hi IndentGuidesEven guibg=#3c3c3c ctermbg=darkgray
" ハイライト色の変化の幅
let g:indent_guides_color_change_percent = 30
" ガイドの幅
let g:indent_guides_guide_size = 1
" 無視するファイルタイプ
let g:indent_guides_exclude_filetypes = ['help', 'unite', 'vimfiler', 'vimshell', 'startify']

" Syntastic {{{1
let g:syntastic_mode_map = {
\ 'mode': 'active',
\ 'passive_filetypes': ['html']
\}
if executable('rubocop')
  let g:syntastic_ruby_checkers = ['rubocop']
endif

" EasyMotion {{{1
" 大文字小文字を無視しない
let g:EasyMotion_smartcase = 1
" migemo検索
let g:EasyMotion_use_migemo = 1
" 使用する文字
let g:EasyMotion_keys = 'FDSAJKLGHREWQUIOPVCXZMTYBN/.;'
" 大文字で表示する
let g:EasyMotion_use_upper = 1
" JKモーションでカラム位置キープ
let g:EasyMotion_startofline = 0
" フォールディングを飛ばさない
let g:EasyMotion_skipfoldedline = 0
" Enterで直近に飛ぶ
let g:EasyMotion_enter_jump_first = 1

" Startify {{{1
" ヘッダー {{{
" let g:startify_custom_header = map(split(system('date'), '\n'), '"   ". v:val') + ['','']
hi StartifyHeader ctermfg=10 guifg=#A8FF60
let g:startify_custom_header = [
\ '                                            ..',
\ '                                          .::::.',
\ '                             ___________ :;;;;:`____________',
\ '                             \_       _/ ?????L \_        _/',
\ '                               |.....| ????????> .:......"',
\ '                               |:::::| $$$$$$"`.:::::::" ,',
\ '                              ,|:::::| $$$$"`.:::::::" .OOS.',
\ '                            ,7D|;;;;;| $$"`.;;;;;;;" .OOO888S.',
\ '                          .GDDD|;;;;;| ?`.;;;;;;;" .OO8DDDDDNNS.',
\ '                           "DDO|IIIII| .7IIIII7" .DDDDDDDDNNNF`',
\ '                             "D|IIIIII7IIIII7" .DDDDDDDDNNNF`',
\ '                               |EEEEEEEEEE7" .DDDDDDDNNNNF`',
\ '                               |EEEEEEEEZ" .DDDDDDDDNNNF`',
\ '                               |888888Z" .DDDDDDDDNNNF`',
\ '                               |8888Z" ,DDDDDDDNNNNF`',
\ '                               |88Z"    "DNNNNNNN"',
\ '                               """        "MMMM"',
\ '                                            ""',
\ '     _    _ _                                           _   _      __     ___             ',
\ '    / \  | | |  _   _  ___  _   _   _ __   ___  ___  __| | (_)___  \ \   / (_)_.__ ___    ',
\ '   / _ \ | | | | | | |/ _ \| | | | |  _ \ / _ \/ _ \/ _` | | / __|  \ \ / /| |  _ ` _ \   ',
\ '  / ___ \| | | | |_| | (_) | |_| | | | | |  __/  __/ (_| | | \__ \   \ V / | | | | | | |_ ',
\ ' /_/   \_\_|_|  \__, |\___/ \__,_| |_| |_|\___|\___|\__,_| |_|___/    \_/  |_|_| |_| |_(_)',
\ '                |___/                                                                     ',
\ '',
\ ]
" }}}
" メニュー
let g:startify_list_order = [
\ ['   Bookmarks:'],
\  'bookmarks',
\ ['   Sessions:'],
\  'sessions',
\ ['   MRU:'],
\  'files',
\ ]
" スペシャルメニューなし
let g:startify_enable_special = 0
" MRUファイルの数
let g:startify_files_number = 3
" 無視するファイル
let g:startify_skiplist = ['COMMIT_EDITMSG']
" セッションファイルのディレクトリ
let g:startify_session_dir = '~/.cache/startify'
" メニューに使用する文字
let g:startify_custom_indices = ['0', 'f', 'd', 's', 'a', 'v', 'c', 'x', 'z', 'b', 'n', 'm', ',', '.']
" ブックマーク
let g:startify_bookmarks = [
\ resolve($MYVIMRC),
\ ]

" Restart {{{1
let g:restart_sessionoptions = 'blank,curdir,folds,help,localoptions,tabpages'

" textobj-user {{{1
" entire
let g:textobj_entire_no_default_key_mappings = 1
omap aa <Plug>(textobj-entire-a)
vmap aa <Plug>(textobj-entire-a)
omap ia <Plug>(textobj-entire-i)
vmap ia <Plug>(textobj-entire-i)
" postexpr
let g:textobj_postexpr_no_default_key_mappings = 1
omap af <Plug>(textobj-postexpr-a)
vmap af <Plug>(textobj-postexpr-a)
omap if <Plug>(textobj-postexpr-i)
vmap if <Plug>(textobj-postexpr-i)
" wiw
let g:textobj_wiw_no_default_key_mappings = 1
omap a_ <Plug>(textobj-wiw-a)
vmap a_ <Plug>(textobj-wiw-a)
omap i_ <Plug>(textobj-wiw-i)
vmap i_ <Plug>(textobj-wiw-i)
" between
let g:textobj_between_no_default_key_mappings = 1
omap a= <Plug>(textobj-between-a)
vmap a= <Plug>(textobj-between-a)
omap i= <Plug>(textobj-between-i)
vmap i= <Plug>(textobj-between-i)
" multitextojb
let g:textobj_multitextobj_textobjects_a =
\ ["a'", 'a"', 'a<', 'a(', 'a[', 'a]', 'a{', 'a}']
let g:textobj_multitextobj_textobjects_i =
\ ["i'", 'i"', 'i<', 'i(', 'i[', 'i]', 'i{', 'i}']
omap am <Plug>(textobj-multitextobj-a)
vmap am <Plug>(textobj-multitextobj-a)
omap im <Plug>(textobj-multitextobj-i)
vmap im <Plug>(textobj-multitextobj-i)
" multiblock
let g:textobj_multiblock_blocks =
\ [["if", "endif"], ['if', 'fi'], ['if', 'end'],
\  ["function", "endfunction"], ["def", "end"]]
omap aM <Plug>(textobj-multiblock-a)
vmap aM <Plug>(textobj-multiblock-a)
omap iM <Plug>(textobj-multiblock-i)
vmap iM <Plug>(textobj-multiblock-i)

" smartchr {{{1
inoremap <expr> = smartchr#loop('=', '==', '<=', '>=')

" Acceralated Smooth Scroll {{{1
map <silent> <Space> <Plug>(ac-smooth-scroll-c-d)
map <silent> <S-Space> <Plug>(ac-smooth-scroll-c-u)
vmap <silent> <Space> <Plug>(ac-smooth-scroll-c-d_v)
vmap <silent> <S-Space> <Plug>(ac-smooth-scroll-c-u_v)

" Switch {{{1
nnoremap <expr> <C-a> strpart(getline("."), col(".") - 1, 1) =~ '\d' ? "\<C-a>" : ":\<C-u>Switch\<CR>"

" ShowMarks {{{1
let g:showmarks_ignore_type = 'hqmp'

" Gitv {{{1
let g:Gitv_OpenHorizontal = 1

" Conque {{{1
" 終了時に閉じる
let g:ConqueTerm_CloseOnEnd = 1
" InsertモードでC-wを使用できるようにする
let g:ConqueTerm_CWInsert = 1
" カラー
let g:ConqueTerm_Color = 1
" trail非表示
au myvimrc FileType conque_term setlocal nolist

" submode {{{1
let s:bundle = neobundle#get('vim-submode')
let s:bundle.hooks = get(s:bundle, "hooks", {})
function! s:bundle.hooks.on_source(bundle)
" xで連続で消した履歴を一つにまとめる
nnoremap <silent> <Plug>(my-submode-x) :<C-u>call <SID>my_submode_x()<CR>
function! s:my_submode_x() "{{{
  undojoin
  normal! "_x
endfunction "}}}
" サブモード抜け時の挙動が気になるので無効化
" call submode#enter_with('my-submode-x', 'n', '', 'x', '"_x')
" call submode#map('my-submode-x', 'n', 'r', 'x', '<Plug>(my-submode-x)')
" （on_source終わり） {{{2
endfunction
unlet s:bundle

" anzu {{{1
nmap n <Plug>(anzu-n)
nmap N <Plug>(anzu-N)
let g:anzu_status_format = "(%i/%l)"
au myvimrc CursorHold,CursorHoldI,WinLeave,TabLeave * call anzu#clear_search_status()

" editqf {{{1
let g:editqf_saveqf_filename  = "~/.editqf_save_data"

"}}}1-------------------------------------------------------------------------

